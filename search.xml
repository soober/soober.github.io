<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[利用OpenGL ES渲染图片(下)]]></title>
    <url>%2F2019%2F02%2F28%2F%E5%88%A9%E7%94%A8OpenGL%20ES%E6%B8%B2%E6%9F%93%E5%9B%BE%E7%89%87(%E4%B8%8B)%2F</url>
    <content type="text"><![CDATA[思路：不采用GLKBaseEffect，使用编译链接自定义的着色器（shader）。用简单的glsl语言来实现顶点、片元着色器，并对图形进行简单的变换。1.创建图层2.创建上下文3.清空缓存区4.设置RenderBuffer5.设置FrameBuffer6.开始绘制 代码实现12345678910111213141516171819202122-(void)layoutSubviews&#123; //1.设置图层 [self setupLayer]; //2.设置图形上下文 [self setupContext]; //3.清空缓存区 [self deleteRenderAndFrameBuffer]; //4.设置RenderBuffer [self setupRenderBuffer]; //5.设置FrameBuffer [self setupFrameBuffer]; //6.开始绘制 [self renderLayer]; &#125; 设置图层头文件引入:1#import &lt;OpenGLES/ES2/gl.h&gt; 属性创建:123456789//在iOS和tvOS上绘制OpenGL ES内容的图层，继承与CALayer@property(nonatomic,strong)CAEAGLLayer *myEagLayer;@property(nonatomic,strong)EAGLContext *myContext;@property(nonatomic,assign)GLuint myColorRenderBuffer;@property(nonatomic,assign)GLuint myColorFrameBuffer;@property(nonatomic,assign)GLuint myPrograme; 设置图层:12345678910111213141516171819202122232425262728293031323334353637//1.设置图层-(void)setupLayer&#123; //给图层开辟空间 /* 重写layerClass，将CCView返回的图层从CALayer替换成CAEAGLLayer */ self.myEagLayer = (CAEAGLLayer *)self.layer; //设置放大倍数 [self setContentScaleFactor:[[UIScreen mainScreen]scale]]; //CALayer 默认是透明的，必须将它设为不透明才能将其可见。 self.myEagLayer.opaque = YES; //设置描述属性，这里设置不维持渲染内容以及颜色格式为RGBA8 /* kEAGLDrawablePropertyRetainedBacking 表示绘图表面显示后，是否保留其内容。这个key的值，是一个通过NSNumber包装的bool值。如果是false，则显示内容后不能依赖于相同的内容，ture表示显示后内容不变。一般只有在需要内容保存不变的情况下，才建议设置使用,因为会导致性能降低、内存使用量增减。一般设置为flase. kEAGLDrawablePropertyColorFormat 可绘制表面的内部颜色缓存区格式，这个key对应的值是一个NSString指定特定颜色缓存区对象。默认是kEAGLColorFormatRGBA8； kEAGLColorFormatRGBA8：32位RGBA的颜色，4*8=32位 kEAGLColorFormatRGB565：16位RGB的颜色， kEAGLColorFormatSRGBA8：sRGB代表了标准的红、绿、蓝，即CRT显示器、LCD显示器、投影机、打印机以及其他设备中色彩再现所使用的三个基本色素。sRGB的色彩空间基于独立的色彩坐标，可以使色彩在不同的设备使用传输中对应于同一个色彩坐标体系，而不受这些设备各自具有的不同色彩坐标的影响。 */ self.myEagLayer.drawableProperties = [NSDictionary dictionaryWithObjectsAndKeys:[NSNumber numberWithBool:false],kEAGLDrawablePropertyRetainedBacking,kEAGLColorFormatRGBA8,kEAGLDrawablePropertyColorFormat,nil]; &#125;+(Class)layerClass&#123; return [CAEAGLLayer class];&#125; 设置上下文1234567891011121314151617181920212223//2.设置上下文-(void)setupContext&#123; //1.指定OpenGL ES 渲染API版本，我们使用2.0 EAGLRenderingAPI api = kEAGLRenderingAPIOpenGLES2; //2.创建图形上下文 EAGLContext *context = [[EAGLContext alloc]initWithAPI:api]; //3.判断是否创建成功 if (!context) &#123; NSLog(@"Create context failed!"); return; &#125; //4.设置图形上下文 if (![EAGLContext setCurrentContext:context]) &#123; NSLog(@"setCurrentContext failed!"); return; &#125; //5.将局部context，变成全局的 self.myContext = context; &#125; 清空缓存区12345678910111213141516171819202122232425262728293031//3.清空缓存区-(void)deleteRenderAndFrameBuffer&#123; //1.导入框架#import &lt;OpenGLES/ES2/gl.h&gt; /* 2.创建2个帧缓存区，渲染缓存区，帧缓存区 @property (nonatomic , assign) GLuint myColorRenderBuffer; @property (nonatomic , assign) GLuint myColorFrameBuffer; A.离屏渲染，详细解释见课件 B.buffer的分类,详细见课件 buffer分为frame buffer 和 render buffer2个大类。其中frame buffer 相当于render buffer的管理者。frame buffer object即称FBO，常用于离屏渲染缓存等。render buffer则又可分为3类。colorBuffer、depthBuffer、stencilBuffer。 //绑定buffer标识符 glGenRenderbuffers(&lt;#GLsizei n#&gt;, &lt;#GLuint *renderbuffers#&gt;) glGenFramebuffers(&lt;#GLsizei n#&gt;, &lt;#GLuint *framebuffers#&gt;) //绑定空间 glBindRenderbuffer(&lt;#GLenum target#&gt;, &lt;#GLuint renderbuffer#&gt;) glBindFramebuffer(&lt;#GLenum target#&gt;, &lt;#GLuint framebuffer#&gt;) */ glDeleteBuffers(1, &amp;_myColorRenderBuffer); self.myColorRenderBuffer = 0; glDeleteBuffers(1, &amp;_myColorFrameBuffer); self.myColorFrameBuffer = 0; &#125; 设置RenderBuffer12345678910111213141516171819202122//4.设置RenderBuffer-(void)setupRenderBuffer&#123; //1.定义一个缓存区 GLuint buffer; //2.申请一个缓存区标志 glGenRenderbuffers(1, &amp;buffer); //3. self.myColorRenderBuffer = buffer; //4.将标识符绑定到GL_RENDERBUFFER glBindRenderbuffer(GL_RENDERBUFFER, self.myColorRenderBuffer); //frame buffer仅仅是管理者，不需要分配空间；render buffer的存储空间的分配，对于不同的render buffer，使用不同的API进行分配，而只有分配空间的时候，render buffer句柄才确定其类型 //myColorRenderBuffer渲染缓存区分配存储空间 [self.myContext renderbufferStorage:GL_RENDERBUFFER fromDrawable:self.myEagLayer]; &#125; 设置FrameBuffer1234567891011121314151617181920212223//5.设置FrameBuffer-(void)setupFrameBuffer&#123; //1.定义一个缓存区 GLuint buffer; //2.申请一个缓存区标志 glGenRenderbuffers(1, &amp;buffer); //3. self.myColorFrameBuffer = buffer; //4. glBindFramebuffer(GL_FRAMEBUFFER, self.myColorFrameBuffer); //生成空间之后，则需要将renderbuffer跟framebuffer进行绑定，调用glFramebufferRenderbuffer函数进行绑定，后面的绘制才能起作用 //5.将_myColorRenderBuffer 通过glFramebufferRenderbuffer函数绑定到GL_COLOR_ATTACHMENT0上。 glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_RENDERBUFFER, self.myColorRenderBuffer); //接下来，可以调用OpenGL ES进行绘制处理，最后则需要在EGALContext的OC方法进行最终的渲染绘制。这里渲染的color buffer,这个方法会将buffer渲染到CALayer上。- (BOOL)presentRenderbuffer:(NSUInteger)target; &#125; 开始绘制123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146//6.开始绘制-(void)renderLayer&#123; //设置清屏颜色 glClearColor(0.0f, 1.0f, 0.0f, 1.0f); //清除屏幕 glClear(GL_COLOR_BUFFER_BIT); //1.设置视口大小 CGFloat scale = [[UIScreen mainScreen]scale]; glViewport(self.frame.origin.x * scale, self.frame.origin.y * scale, self.frame.size.width * scale, self.frame.size.height * scale); //2.读取顶点着色程序、片元着色程序 NSString *vertFile = [[NSBundle mainBundle]pathForResource:@"shaderv" ofType:@"vsh"]; NSString *fragFile = [[NSBundle mainBundle]pathForResource:@"shaderf" ofType:@"fsh"]; NSLog(@"vertFile:%@",vertFile); NSLog(@"fragFile:%@",fragFile); //3.加载shader self.myPrograme = [self loadShaders:vertFile Withfrag:fragFile]; //4.链接 glLinkProgram(self.myPrograme); GLint linkStatus; //获取链接状态 glGetProgramiv(self.myPrograme, GL_LINK_STATUS, &amp;linkStatus); if (linkStatus == GL_FALSE) &#123; GLchar message[512]; glGetProgramInfoLog(self.myPrograme, sizeof(message), 0, &amp;message[0]); NSString *messageString = [NSString stringWithUTF8String:message]; NSLog(@"Program Link Error:%@",messageString); return; &#125; NSLog(@"Program Link Success!"); //5.使用program glUseProgram(self.myPrograme); //6.设置顶点、纹理坐标 //前3个是顶点坐标，后2个是纹理坐标 GLfloat attrArr[] = &#123; 0.5f, -0.5f, -1.0f, 1.0f, 0.0f, -0.5f, 0.5f, -1.0f, 0.0f, 1.0f, -0.5f, -0.5f, -1.0f, 0.0f, 0.0f, 0.5f, 0.5f, -1.0f, 1.0f, 1.0f, -0.5f, 0.5f, -1.0f, 0.0f, 1.0f, 0.5f, -0.5f, -1.0f, 1.0f, 0.0f, &#125;; /* 1.解决渲染图片倒置问题： GLfloat attrArr[] = &#123; 0.5f, -0.5f, 0.0f, 1.0f, 1.0f, //右下 -0.5f, 0.5f, 0.0f, 0.0f, 0.0f, // 左上 -0.5f, -0.5f, 0.0f, 0.0f, 1.0f, // 左下 0.5f, 0.5f, 0.0f, 1.0f, 0.0f, // 右上 -0.5f, 0.5f, 0.0f, 0.0f, 0.0f, // 左上 0.5f, -0.5f, 0.0f, 1.0f, 1.0f, // 右下 &#125;; */ //-----处理顶点数据-------- //顶点缓存区 GLuint attrBuffer; //申请一个缓存区标识符 glGenBuffers(1, &amp;attrBuffer); //将attrBuffer绑定到GL_ARRAY_BUFFER标识符上 glBindBuffer(GL_ARRAY_BUFFER, attrBuffer); //把顶点数据从CPU内存复制到GPU上 glBufferData(GL_ARRAY_BUFFER, sizeof(attrArr), attrArr, GL_DYNAMIC_DRAW); //将顶点数据通过myPrograme中的传递到顶点着色程序的position //1.glGetAttribLocation,用来获取vertex attribute的入口的.2.告诉OpenGL ES,通过glEnableVertexAttribArray，3.最后数据是通过glVertexAttribPointer传递过去的。 //注意：第二参数字符串必须和shaderv.vsh中的输入变量：position保持一致 GLuint position = glGetAttribLocation(self.myPrograme, "position"); //2.设置合适的格式从buffer里面读取数据 glEnableVertexAttribArray(position); //3.设置读取方式 //参数1：index,顶点数据的索引 //参数2：size,每个顶点属性的组件数量，1，2，3，或者4.默认初始值是4. //参数3：type,数据中的每个组件的类型，常用的有GL_FLOAT,GL_BYTE,GL_SHORT。默认初始值为GL_FLOAT //参数4：normalized,固定点数据值是否应该归一化，或者直接转换为固定值。（GL_FALSE） //参数5：stride,连续顶点属性之间的偏移量，默认为0； //参数6：指定一个指针，指向数组中的第一个顶点属性的第一个组件。默认为0 glVertexAttribPointer(position, 3, GL_FLOAT, GL_FALSE, sizeof(GLfloat) * 5, NULL); //----处理纹理数据------- //1.glGetAttribLocation,用来获取vertex attribute的入口的. //注意：第二参数字符串必须和shaderv.vsh中的输入变量：textCoordinate保持一致 GLuint textCoor = glGetAttribLocation(self.myPrograme, "textCoordinate"); //2.设置合适的格式从buffer里面读取数据 glEnableVertexAttribArray(textCoor); //3.设置读取方式 //参数1：index,顶点数据的索引 //参数2：size,每个顶点属性的组件数量，1，2，3，或者4.默认初始值是4. //参数3：type,数据中的每个组件的类型，常用的有GL_FLOAT,GL_BYTE,GL_SHORT。默认初始值为GL_FLOAT //参数4：normalized,固定点数据值是否应该归一化，或者直接转换为固定值。（GL_FALSE） //参数5：stride,连续顶点属性之间的偏移量，默认为0； //参数6：指定一个指针，指向数组中的第一个顶点属性的第一个组件。默认为0 glVertexAttribPointer(textCoor, 2, GL_FLOAT, GL_FALSE, sizeof(GLfloat)*5, (float *)NULL + 3); //加载纹理 [self setupTexture:@"timg-3"]; //注意，想要获取shader里面的变量，这里记得要在glLinkProgram后面，后面，后面！ /* 一个一致变量在一个图元的绘制过程中是不会改变的，所以其值不能在glBegin/glEnd中设置。一致变量适合描述在一个图元中、一帧中甚至一个场景中都不变的值。一致变量在顶点shader和片断shader中都是只读的。首先你需要获得变量在内存中的位置，这个信息只有在连接程序之后才可获得 */ //rotate等于shaderv.vsh中的uniform属性，rotateMatrix GLuint rotate = glGetUniformLocation(self.myPrograme, "rotateMatrix"); //获取渲染的弧度 float radians = 10 * 3.14159f / 180.0f; //求得弧度对于的sin\cos值 float s = sin(radians); float c = cos(radians); //z轴旋转矩阵 参考3D数学围绕z轴渲染矩阵公式 //为什么和公式不一样？因为在3D中用的是横向量，在OpenGL ES用的是列向量 GLfloat zRotation[16] = &#123; c, -s, 0, 0, s, c, 0, 0, 0, 0, 1.0, 0, 0.0, 0, 0, 1.0 &#125;; //设置旋转矩阵 glUniformMatrix4fv(rotate, 1, GL_FALSE, (GLfloat *)&amp;zRotation[0]); glDrawArrays(GL_TRIANGLES, 0, 6); [self.myContext presentRenderbuffer:GL_RENDERBUFFER]; &#125; 加载shader 与 链接shader12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#pragma mark --shader//加载shader-(GLuint)loadShaders:(NSString *)vert Withfrag:(NSString *)frag&#123; //定义2个零时着色器对象 GLuint verShader, fragShader; //创建program GLint program = glCreateProgram(); //编译顶点着色程序、片元着色器程序 //参数1：编译完存储的底层地址 //参数2：编译的类型，GL_VERTEX_SHADER（顶点）、GL_FRAGMENT_SHADER(片元) //参数3：文件路径 [self compileShader:&amp;verShader type:GL_VERTEX_SHADER file:vert]; [self compileShader:&amp;fragShader type:GL_FRAGMENT_SHADER file:frag]; //创建最终的程序 glAttachShader(program, verShader); glAttachShader(program, fragShader); //释放不需要的shader glDeleteShader(verShader); glDeleteShader(fragShader); return program;&#125;//链接shader- (void)compileShader:(GLuint *)shader type:(GLenum)type file:(NSString *)file&#123; //读取文件路径字符串 NSString* content = [NSString stringWithContentsOfFile:file encoding:NSUTF8StringEncoding error:nil]; const GLchar* source = (GLchar *)[content UTF8String]; //创建一个shader（根据type类型） *shader = glCreateShader(type); //将顶点着色器源码附加到着色器对象上。 //参数1：shader,要编译的着色器对象 *shader //参数2：numOfStrings,传递的源码字符串数量 1个 //参数3：strings,着色器程序的源码（真正的着色器程序源码） //参数4：lenOfStrings,长度，具有每个字符串长度的数组，或NULL，这意味着字符串是NULL终止的 glShaderSource(*shader, 1, &amp;source,NULL); //把着色器源代码编译成目标代码 glCompileShader(*shader); &#125; 设置纹理1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495//设置纹理- (GLuint)setupTexture:(NSString *)fileName &#123; //1、获取图片的CGImageRef CGImageRef spriteImage = [UIImage imageNamed:fileName].CGImage; //判断图片是否获取成功 if (!spriteImage) &#123; NSLog(@"Failed to load image %@", fileName); exit(1); &#125; //2、读取图片的大小，宽和高 size_t width = CGImageGetWidth(spriteImage); size_t height = CGImageGetHeight(spriteImage); //3.获取图片字节数 宽*高*4（RGBA） GLubyte * spriteData = (GLubyte *) calloc(width * height * 4, sizeof(GLubyte)); //4.创建上下文 /* 参数1：data,指向要渲染的绘制图像的内存地址 参数2：width,bitmap的宽度，单位为像素 参数3：height,bitmap的高度，单位为像素 参数4：bitPerComponent,内存中像素的每个组件的位数，比如32位RGBA，就设置为8 参数5：bytesPerRow,bitmap的没一行的内存所占的比特数 参数6：colorSpace,bitmap上使用的颜色空间 kCGImageAlphaPremultipliedLast：RGBA */ CGContextRef spriteContext = CGBitmapContextCreate(spriteData, width, height, 8, width*4,CGImageGetColorSpace(spriteImage), kCGImageAlphaPremultipliedLast); //5、在CGContextRef上绘图 /* CGContextDrawImage 使用的是Core Graphics框架，坐标系与UIKit 不一样。UIKit框架的原点在屏幕的左上角，Core Graphics框架的原点在屏幕的左下角。 CGContextDrawImage 参数1：绘图上下文 参数2：rect坐标 参数3：绘制的图片 */ CGRect rect = CGRectMake(0, 0, width, height); //使用默认方式绘制，发现图片是倒的。 CGContextDrawImage(spriteContext, CGRectMake(0, 0, width, height), spriteImage); /* 解决图片倒置的方法(2): CGContextTranslateCTM(spriteContext, rect.origin.x, rect.origin.y); CGContextTranslateCTM(spriteContext, 0, rect.size.height); CGContextScaleCTM(spriteContext, 1.0, -1.0); CGContextTranslateCTM(spriteContext, -rect.origin.x, -rect.origin.y); CGContextDrawImage(spriteContext, rect, spriteImage); */ //6、画图完毕就释放上下文 CGContextRelease(spriteContext); //5、绑定纹理到默认的纹理ID（这里只有一张图片，故而相当于默认于片元着色器里面的colorMap，如果有多张图不可以这么做） glBindTexture(GL_TEXTURE_2D, 0); //设置纹理属性 /* 参数1：纹理维度 参数2：线性过滤、为s,t坐标设置模式 参数3：wrapMode,环绕模式 */ glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR ); glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR ); glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE); glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE); float fw = width, fh = height; //载入纹理2D数据 /* 参数1：纹理模式，GL_TEXTURE_1D、GL_TEXTURE_2D、GL_TEXTURE_3D 参数2：加载的层次，一般设置为0 参数3：纹理的颜色值GL_RGBA 参数4：宽 参数5：高 参数6：border，边界宽度 参数7：format 参数8：type 参数9：纹理数据 */ glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, fw, fh, 0, GL_RGBA, GL_UNSIGNED_BYTE, spriteData); //绑定纹理 /* 参数1：纹理维度 参数2：纹理ID,因为只有一个纹理，给0就可以了。 */ glBindTexture(GL_TEXTURE_2D, 0); //释放spriteData free(spriteData); return 0;&#125; GLSL程序编写openGL ES的可编程管线中的顶点着色器和片元着色器需要开发者自行编写, 对应的语言为GLSL(OpenGL Shading Language), 其中顶点着色器处理传入的顶点坐标, 片元着色器将顶点坐标进行光栅化处理, 显示出图形 顶点着色器程序: shaderVertex.fsh12345678910111213141516attribute vec4 position;// 处理顶点数据attribute vec2 textCoordinate;// 处理纹理uniform mat4 rotateMatrix;//处理图形旋转varying lowp vec2 varyTextCoord;void main()&#123; varyTextCoord = textCoordinate; vec4 vPos = position; vPos = vPos * rotateMatrix;//每个顶点坐标进行旋转角度处理 gl_Position = vPos;//内建变量gl_Position,必须赋值&#125; 片元着色器程序: shaderFrgment.fsh123456789varying lowp vec2 varyTextCoord;uniform sampler2D colorMap;void main()&#123; gl_FragColor = texture2D(colorMap, varyTextCoord);//内建变量gl_FragColor,必须赋值&#125; 顶点着色器调用次数与顶点数量相关, 片元着色器调用与像素多少相关, 所以片元着色器的调用次数比较多 运行结果 可以看到图形是反的, 这是因为纹理本身是倒置的, 下面将讲解解决图形倒置的三种方法 解决图形倒置的方法1. 设置图形旋转角度可以看到上面的图形除了倒置之外, 还有一些倾斜, 是因为我们在代码中设置了图形的旋转角度为10度, 那么我们将这个参数调整为180度, 即可将图形倒置回来 另外, 若不想让图形旋转, 则需要注释掉这部分代码, 并注释顶点着色器中关于rotateMatrix的部分 2. 调整纹理坐标纹理的坐标是倒置的, 那么我们调整纹理坐标, 也可以将图形倒置回来 3. 利用CGContext 效果]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>opengles</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用OpenGL ES渲染图片(上)]]></title>
    <url>%2F2019%2F02%2F28%2F%E5%88%A9%E7%94%A8OpenGL%20ES%E6%B8%B2%E6%9F%93%E5%9B%BE%E7%89%87(%E4%B8%8A)%2F</url>
    <content type="text"><![CDATA[OpenGL与OpenGL ES发展历史图形编程接⼝ 2D图形编程接⼝口: GDI , Skiz, OpenVG 3D图形编程接⼝口: DirectX , OpenGL/OpenGL ES , Embedded Systems OpenGL的特点 跨操作系统平台运⾏ 隐藏底层硬件信息 专⽤渲染接⼝ OpenGL历史变更 1992年年7⽉月SGI发布OpenGL1.0版本 (硅图)SGI Window NT版本的OpenGL 1995年年OpenGL1.1版本发布 2003年年7⽉月SGI与ARB发OpenGL 1.5 2004年年8⽉月OpenGL2.0版本发布 OpenGL Shading Language(GLSL) shader OpenGL ES的版本 OpenGL ES 1.X :针对固定功能流⽔水管线硬件 OpenGL ES 2.X :针对可编程流⽔水管线硬件 OpenGL ES 3.X :OpenGL ES 2.0的扩展 着⾊色器器渲染过程在渲染过程中，必须存储2种着⾊器，分别是顶点着⾊器、⽚元着⾊器。顶点着⾊器是第⼀个着⾊器、⽚元着色器是最后一个。顶点着⾊器中处理顶点、⽚元着⾊器处理像素点颜色。 屏幕渲染方式 On-Screen Rendering(当前屏幕渲染) : 指的是GPU的渲染操作是在当前用于显示的屏幕缓存区中进行的。 Off-Screen Rendering(离幕渲染) : 指的是GPU在当前屏幕缓存区以外新开辟一个缓存区进⾏渲染操作 ⼀般情况下，OpenGL ES会将应用提供到渲染服务的动画直接渲染显示(使用基本的渲染的流程) 但对于一些复杂的图像动画的渲染，并不能够直接渲染叠加显示出来。⽽是需要根据Command Buffer分通道进行渲染再组合。这个组合过程中，就有些渲染通道是不会直接显示出来的。标记此次渲染需要更多的渲染通道和合并步骤，⽽这些没有直接渲染显示在屏幕上的通道就是离屏渲染通道。 离屏渲染需要更多的渲染通道，⽽不同的渲染通道间切换需要消耗一定的时间，所以离屏渲染可能会发生卡顿。 相⽐于当前屏幕渲染，离屏渲染的代价相对⽽言较高。主要有以下2个原因:1.创建新的缓存区2.上下⽂切换 哪些情况会使用离屏渲染(off-Screen Render)? drawRect layer.shouldRasterize = true; 有mask或者阴影(layer.makesToBounds)shouldRasterize(光栅化)、masks(遮罩)、shadows(阴影) edge antialiasing(抗锯⻮齿)、group opacity(不不透明) Text(UILabel,CATextLayer,CoreText) 为什么要用FrameBuffer和 RenderBuffer?它们是什么关系? A renderbuffer object is a 2D image buffer allocated by the application. The renderbuffer can be used to allocate and store color, depth, or stencil values and can be used as a color, depth, or stencil attachment in a framebuffer object. A renderbuffer is similar to an off-screen window system provided drawable surface, such as a pbuffer. A renderbuffer, however, cannot be directly used as a GL texture. ⼀个renderbuffer对象是应⽤分配的一个2D图像缓存区。renderbuffer能够被用来分配和存储颜色、深度或者模板值。也能够在一个framebuffer被⽤用作颜色、深度、模板的附件。⼀个renderbuffer是一个类似于屏幕窗口系统提供可绘制的表面。⽐如pBuffer。⼀个renderbuffer, 并不能直接被当做⼀个GL纹理使用。 A framebuffer object (often referred to as an FBO) is a collection of color, depth, and stencil buffer attachment points; state that describes properties such as the size and format of the color, depth, and stencil buffers attached to the FBO; and the names of the texture and renderbuffer objects attached to the FBO. Various 2D images can be attached to the color attachment point in the framebuffer object. These include a renderbuffer object that stores color values, a mip-level of a 2D texture or a cube map face, or even a mip-level of a 2D slice in a 3D texture. Similarly, various 2D images contain- ing depth values can be attached to the depth attachment point of an FBO. These can include a renderbuffer, a mip-level of a 2D texture or a cubemap face that stores depth values. The only 2D image that can be attached to the stencil attachment point of an FBO is a renderbuffer object that stores stencil values. ⼀个frameBuffer对象(通常被称为⼀个FBO)。是一个颜色、深度和模板缓存区附着点的集合。描述属性的状态，例如颜⾊、深度和模板缓存区的⼤⼩和格式，都关联到FBO(Frame Buffer Object)。并且纹理的名字和renderBuffer对象也都是关联于FBO。各种各样的2D图形能够被附着framebuffer对象的颜色附着点。它们包含了renderbuffer对象存储的颜色值、一个2D纹理或⽴⽅体贴图。或者一个mip-level的⼆维切面在3D纹理。同样，各种各样的2D图形包含了当时的深度值可以附加到⼀个FBO的深度附着点钟去。唯一的二维图像，能够附着在FBO的模板附着点，是一个renderbuffer对象存储模板值。 基本图形硬件流⽔线设计 应⽤用程序层 -&gt; 硬件抽象层 -&gt; 硬件层应⽤用层: 游戏和应⽤用层软件开发⼈人员为主体，通过调⽤用API进行上层开发，不需要考虑移植性问题。硬件抽象层: 抽象出硬件的加速功能，进行有利于应用层开发的封装,并向应用层提供开发API硬件层: 将硬件驱动提供给抽象层，以实现抽象层加速功能的有效性。 shader着色器。着⾊器其实就是一段在GPU运行的程序。我们平时的程序，是在CPU运行。由于GPU的硬件设计结构与CPU有着很⼤的不同，所以GPU需要一些新的编程语⾔. 渲染流水线分为两种，其中一种为可编程渲染流⽔线。另外一种为固定渲染流水线。(也称可编程管线或固定管线，管线就是流⽔线的意思)。渲染流水线可否编程，取决于程序猿能否在顶点着⾊器以及片段着色器上进行编码。⽽现在的渲染流水线，基本都是可编程的，当然，它们也支持固定渲染流⽔线的功能 渲染流⽔线的具体流程1、应⽤层 :在这⼀层，我们⽬前使⽤的是DirectX与OpenGL。对于这一部分，主要是一些API的调⽤2、硬件抽象层 :应⽤程序层主要与内存，CPU打交道，诸如碰撞检测，场景图监理，视锥裁剪等经典算法在此阶段执行。在阶段的末端，几何体的数据(顶点坐标，法向量，纹理坐标，纹理)等通过数据总线传送到图形硬件3、硬件层 :硬件层在渲染流水线中最为复杂，也最为重要。可编程渲染流⽔线与固定渲染流水线的区别在于是否对着⾊器进⾏编程。 ⾸先我们先了解固定渲染流水线, 它主要分为以下⼏个阶段:顶点变换 -&gt; 图元转配与光栅化 -&gt; ⽚段纹理映射和着色 -&gt; 光栅化操作 硬件层—固定渲染管线流程图 : 光栅化(Rasterization):将顶点数据转换为片元的过程, ⽚元中每个一个元素对于帧缓存区的一个像素;光栅化其实是一个将⼏何图元变成一个二维图像的过程, 光栅化的过程就是为了产出⽚元 硬件层—可编程渲染流⽔水线流程图: GPU图形渲染管线应用程序阶段 :主要是⾼级编程语言开发,如C,OC,C++输出: 通过数据总线,把⼏何体的数据(顶点坐标\法线\纹理坐标\纹理)等传送到GPU上几何阶段 :输⼊: 应⽤程序末端的内容负责任务: 顶点坐标变换,光照,裁剪,投影,屏幕映射输出: 经过变换和投影之后的屏幕坐标,颜色,纹理坐标光栅化阶段 :参考前面的解释 为什么需要对三维空间的顶点进行坐标空间转换?输⼊到计算机当中的是一系列三维坐标的点,但是我们看到的屏幕是⼆维坐标点. 所以需要一系列的坐标转换:ObjectSpace(物体空间/模型空间)-&gt; WorldSpace(世界空间)-&gt;EyeSpace(观察空间)-&gt;ClicpAndProjectSpace(屏幕空间) CPU与GPU之间的关系GPU具有⾼并行的结构，所以在处理图形数据和复杂算法时比CPU更加有效率 CPU在执行任务的时候，一个时刻只会处理一个数据，不存在真正意义上的并行，⽽GPU则有多个处理器核，在一个时刻可以并⾏处理多个数据]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>opengles</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo搭建Github-Pages博客记录]]></title>
    <url>%2F2019%2F02%2F22%2FHexo%E6%90%AD%E5%BB%BAGithub-Pages%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[一直都很想搭一个自己的博客, 但一直很忙(其实是懒)没弄, 最近终于搭建好了, 过程中也遇到了一些问题, 写个流水账记录下. 准备工作 一个github账号 安装了node.js, npm, git (mac用户的安装xcode就已经装好git了) 搭建github博客创建仓库新建一个用户名.github.io的仓库, 用户名必须为你的github用户名. 比如我的用户名为soober, 那么需要创建sooober.github.io的仓库. 配置SSH key提交代码需要拥有你的github权限, 使用ssh key来解决本地和服务器的连接问题 用git bash(mac用户, 用终端即可)执行如下命令：1cd ~/. ssh 1ssh-keygen -t rsa -C &quot;邮件地址&quot; 一路回车(密码可以不用输入,直接回车)最终会生成一个文件在用户目录下，找到.ssh\id_rsa.pub文件，复制里面的内容，打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key, 将复制的内容粘贴到key那里，title自己写一个，保存。 测试SSH配置是否成功1$ ssh -T git@github.com 如果看到以下信息,说明配置成功 Hexo框架搭建Hexo是一个简单、快速、强大的基于 Github Pages 的博客发布工具，支持Markdown格式，有众多优秀插件和主题。由于github pages存放的都是静态文件，博客存放的不只是文章内容，还有文章列表、分类、标签、翻页等动态内容，假如每次写完一篇文章都要手动更新博文目录和相关链接信息，相信谁都会疯掉，所以hexo所做的就是将这些md文件都放在本地，每次写完文章后调用写好的命令来批量完成相关页面的生成，然后再将有改动的页面提交到github。[官网] (http://hexo.io)[github] (https://github.com/hexojs/hexo) 安装1$ npm install -g hexo 初始化选择博客存储位置, 创建hexo文件夹,然后初始化12$ cd hexo$ hexo init hexo会自动下载一些文件到这个目录，包括node_modules，目录结构如下图：其中, _config.yml这里面都是一些全局配置，每个参数的意思都比较简单明了，就不作详细介绍了。需要特别注意的地方是，冒号后面必须有一个空格，否则可能会出问题。 接着生成和启动hexo服务12$ hexo g # 生成$ hexo s # 启动服务 执行以上命令之后，hexo就会在public文件夹生成相关html文件，这些文件将来都是要提交到github去的： hexo s是开启本地预览服务，打开浏览器访问 http://localhost:4000 即可看到博客预览内容(使用ctrl+c结束本地预览) 主题设置一个好看的主题可以让你的博客看上去赏心悦目, 我选择用了Next主题, 你可以再这里选择你喜欢的主题样式 首先下载这个主题：12$ cd your-hexo-site$ git clone https://github.com/iissnan/hexo-theme-next themes/next 下载后的主题都在hexo/themes下存放 接着修改hexo根目录_config.yml中的theme: landscape改为theme: next，如下, 然后重新执行hexo g来重新生成。123456# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/# theme: landscape# theme: yiliatheme: next 如果出现一些莫名其妙的问题，可以先执行hexo clean来清理一下public的内容，然后再重新生成。 初始化本地git仓库如果你的本地仓库还没有进行远程仓库管理,需要进行以下步骤设置Git的user name和email：12$ git config --global user.name // 你的github用户名，非昵称$ git config --global user.email // 填写你的github注册邮箱 在本地的hexo init生成的文件夹中初始化git仓库：1$ git init 将本地仓库和远程仓库连接(这一步貌似可以不做):1$ git remote add origin git@github.com:your_github_user_name/your_github_user_name.github.io.git(远程仓库ssh地址) 做完以上这些步骤，说明你的仓库可以使用ssh方式来上传下载代码，而不需要输入用户名和密码了 网站部署首先, 配置hexo根目录_config.yml中有关deploy的部分：123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: git@github.com:soober/soober.github.io.git branch: master 接着, 安装插件1npm install hexo-deployer-git --save 然后执行发布命令123$ hexo clean //清除缓存文件db.json和已生成的静态文件public$ hexo g //生成网站静态文件到默认设置的public文件夹$ hexo d //部署网站到设定的仓库 执行这个命令可能会碰到一些问题, 终端里会直接给出修改建议, 我是按照给出的参考命令执行的, 具体问题忘记截图了=-= 此时你的博客就部署到了page上了, 打开你的用户名.github.io, 即可看到你发布到github的博客了 常用hexo命令常见命令1234567hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）hexo deploy #部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本 缩写1234hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy 组合命令12hexo s -g #生成并本地预览hexo d -g #生成并上传 绑定域名 不想绑定域名的可以跳过这一步骤. 想绑定域名还没有域名的, 可以去阿里或者腾讯注册一个域名, 我是在腾讯买的一个.com域名. 传送门-腾讯云 有个域名之后, 进行域名解析.域名解析配置最常见有2种方式，CNAME和A记录，其中CNAME填写域名，A记录填写IP. 获取ip需要你去ping一下你的用户名.github.io (腾讯的需要进行个人身份认证之后才能正常访问域名) 设置CNAME 在 hexo 项目下，source 文件夹下面创建 CNAME 文件（没有后缀名的），在里面写上购买的域名然后在 github 上面，打开 username.github.io 项目的（Settings）设置，然后在 GitHub Pages的 Custom domain设置里填上购买的域名。比如：好了,新域名配置完成，可以访问了 一些报错处理 ERROR Plugin load failed: hexo-server原因：Besides, utilities are separated into a standalone module. hexo.util is not reachable anymore.解决方法，执行命令： 1sudo npm install hexo-server 有关-ejs, -stylus, -marked的一些错误提示解决办法, 执行命令: 1234567npm install hexo-renderer-ejs --savenpm install hexo-renderer-stylus --savenpm install hexo-renderer-marked --save//这个时候再重新生成静态文件，命令：hexo generate （或hexo g）//启动本地服务器：hexo server （或hexo s） 参考http://blog.haoji.me]]></content>
      <categories>
        <category>利器</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next主题配置遇到的一些问题]]></title>
    <url>%2F2019%2F02%2F22%2FNext%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题一: 归档/分类/标签页面或子页面显示错误 Cannot GET XXXHexo在生成静态页的时候，需要使用对应的插件： * hexo-generator-index #生成首页 * hexo-generator-archive #生成归档页 * hexo-generator-tag #生成标签页 * hex0-generator-category #生成分类页 对应安装命令:1234$ npm install hexo-generator-index --save$ npm install hexo-generator-archive --save$ npm install hexo-generator-tag --save$ npm install hexo-generator-category --save 注意, 其中tag/category都需要有对应的本地文件, 即在 /source/ 目录下新建 categories 目录和 tags 目录(也可以用hexo new page xxx对应生成)，里面的要有 index.md 文件，文件格式如下, 注意type不能写错: tags index.md 12345---title: 标签date: 2019-02-20 18:25:04type: &quot;tags&quot;--- categories index.md 12345---title: 文章分类date: 2019-02-20 18:16:44type: &quot;categories&quot;--- 然后每次写的新文章顶部写入categories/tags的value值, hexo即可自动帮你进行分类或标签管理, 示例如下:1234567---title: Git基本操作date: 2019-02-21 20:38:37categories: 学习笔记tags: [Git]top: 90--- 当然, next的主题配置文件里也要打开对应的注释, 如下12345678910111213menu: home: / || home about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat# Enable/Disable menu icons.menu_icons: enable: true 问题二: 配置博客单篇文章阅读次数, 阅读次数不能正常显示采用的是leanCloud配置方法, 具体配置教程请参考这里 若按照如上教程配置之后, 阅读次数仍无法显示, 可以参考我的解决办法:即打开leanCloud中关于Counter的权限, 我将add_fields和create两个选项的权限改为所有用户后, 博客文章的阅读次数就正常显示了=-=, 如下图: *另外Valine的介绍页上显示可以直接进行自动配置文章阅读次数了, 但是我试验失败, 估计是和之前npm install hexo-leancloud-counter-security --save有了什么冲突. 参考主题个性化设置theme-next.iissnan.comnext个性化主题配置 配置评论功能Valine - 一款快速、简洁且高效的无后端评论系统 文章阅读次数配置Hexo Next leancloud文章阅读次数配置以及插件无效问题解决 问题搜索参考hexo博客归档不分页显示设置方法Counter not initialized解决办法]]></content>
      <categories>
        <category>利器</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git基本操作]]></title>
    <url>%2F2019%2F02%2F21%2FGit%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[(一) 从远程仓库克隆(拉取)项目到本地$ git clone [remote_url] 成功执行后, 本地就已经有配置好git的远程项目了(项目路径默认为终端当前所在路径, 可以通过pwd查看当前路径, 并通过cd调整你想让项目存放的路径) (二)为本地项目添加远程库 创建本地版本库$ git init 通过git init命令把本地项目目录变成Git可以管理的仓库 关联远程仓库$ git remote add origin [remote_url]若操作过程中出现问题,想删除关联远程仓库,可使用:$ git remote remove origin 把本地库的内容推送到远程$ git add .$ git commit -m &quot;the first commit project&quot;$ git push -u origin master 把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。 由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。 若远程仓库有些初始文件(如readme, .gitignore), 则需要在push前先使用命令git pull origin master同步代码 推送成功后，可以立刻在远程仓库页面中看到远程库的内容已经和本地一模一样了. 若过程中出现错误, 解决参照传送门 若.gitignore文件未生效, 解决参照传送门 (三)代码的更新与提交更新取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch] 提交$ cd projectname //转到项目文件夹下$ git add . //追踪新文件,并放到暂存区$ git commit -m &quot;update message&quot; //将文件纳入本地仓库$ git push // 将本地仓库同步到远程仓库 刷新远程仓库页面, 可以发现代码已经上传到远程仓库了]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenGL(七)-纹理(下)]]></title>
    <url>%2F2019%2F02%2F20%2FOpenGL(%E4%B8%83)-%E7%BA%B9%E7%90%86(%E4%B8%8B)%2F</url>
    <content type="text"><![CDATA[绘制一个隧道 定义绘制批次类123456789101112131415161718192021222324GLShaderManager shaderManager; //着色器管理器GLMatrixStack modelViewMatrix; //模型视图矩阵GLMatrixStack projectionMatrix; //投影矩阵GLFrustum viewFrustum; //视景体GLGeometryTransform transformPipeline; //几何变换管线//4个批次容器类GLBatch floorBatch;//地面GLBatch ceilingBatch;//天花板GLBatch leftWallBatch;//左墙面GLBatch rightWallBatch;//右墙面//深度初始值，-65。GLfloat viewZ = -65.0f;// 纹理标识符号#define TEXTURE_BRICK 0 //墙面#define TEXTURE_FLOOR 1 //地板#define TEXTURE_CEILING 2 //纹理天花板#define TEXTURE_COUNT 3 //纹理个数GLuint textures[TEXTURE_COUNT];//纹理标记数组//文件tag名字数组const char *szTextureFiles[TEXTURE_COUNT] = &#123; "brick.tga", "floor.tga", "ceiling.tga" &#125;; 初始化 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176//在这个函数里能够在渲染环境中进行任何需要的初始化，它这里的设置并初始化纹理对象void SetupRC()&#123; GLbyte *pBytes; GLint iWidth,iHeight,iComponents; GLenum eFormat; GLint iLoop; //背景 glClearColor(0.0f, 0.0f, 0.0f,1.0f); shaderManager.InitializeStockShaders(); //1.加载纹理 /* glGenTextures (GLsizei n, GLuint *textures) 参数1:n,纹理数量 参数2:textures,纹理对象标识数组 */ glGenTextures(TEXTURE_COUNT, textures); for (iLoop =0; iLoop &lt; TEXTURE_COUNT; iLoop++) &#123; //2.绑定纹理 /* glBindTexture (GLenum target, GLuint texture); 参数1:target,使用的纹理类型GL_TEXTURE_1D\GL_TEXTURE_2D\GL_TEXTURE_3D 参数2:texture,纹理的标记 */ glBindTexture(GL_TEXTURE_2D, textures[iLoop]); //3.加载tga文件 /* GLbyte *gltReadTGABits(const char *szFileName, GLint *iWidth, GLint *iHeight, GLint *iComponents, GLenum *eFormat, GLbyte *pData); 参数1:szFileName 纹理文件的名称 参数2:iWidth 获取纹理文件的宽度 参数3:iHeight获取纹理文件的高度 参数4:iComponents获取纹理文件的组件 参数5:eFormat获取纹理文件的格式 返回值:指向图像数据的指针 */ pBytes = gltReadTGABits(szTextureFiles[iLoop], &amp;iWidth, &amp;iHeight, &amp;iComponents, &amp;eFormat); //放大过滤器 glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST); //缩小过滤器 glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST); //环绕方式--S glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE); //环绕方式--T glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE); //载入纹理 /* glTexImage2D (GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels); 参数1:target,使用的纹理类型GL_TEXTURE_1D\GL_TEXTURE_2D\GL_TEXTURE_3D 参数2:level ,Mip贴图的层次 参数3:internalformat,纹理单元的颜色组成方式(从读取像素图中获得) 参数4:width 参数5:height 参数6:border 参数7:format 参数8:type,像素数据的数据类型-GL_UNSIGNED_BYTE 参数9:pixels,指向纹理图像数据的指针 */ glTexImage2D(GL_TEXTURE_2D, 0, iComponents, iWidth, iHeight, 0, eFormat, GL_UNSIGNED_BYTE, pBytes); //生成MIP图层 /* 参数1:GL_TEXTURE_1D\GL_TEXTURE_2D\GL_TEXTURE_3D */ glGenerateMipmap(GL_TEXTURE_2D); free(pBytes); &#125; //建立立体图像!!! GLfloat z; /* void Begin(GLenum primitive, GLuint nVerts, GLuint nTextureUnits = 0); 参数1:绘图模式 参数2:顶点个数 参数3:纹理,默认等于0 */ floorBatch.Begin(GL_TRIANGLE_STRIP, 28,1);//共绘制了7个四边形, 共28个顶点 //参考图 - floor.png for (z = 60.0f; z &gt;= 0.0f; z -= 10.0f) &#123; //指定顶点对应纹理的坐标 floorBatch.MultiTexCoord2f(0, 0, 0); //指定左下角顶点 floorBatch.Vertex3f(-10.0f, -10.0f, z); //指定右下角顶点以及纹理坐标 floorBatch.MultiTexCoord2f(0, 1, 0); floorBatch.Vertex3f(10.0f, -10.0f, z); //指定顶点对应纹理的坐标 floorBatch.MultiTexCoord2f(0, 0, 1.0f); floorBatch.Vertex3f(-10.0f, -10.0f, z-10.0f); //指定顶点对应纹理的坐标 floorBatch.MultiTexCoord2f(0, 1.0f, 1.0f); floorBatch.Vertex3f(10.0f, -10.0f, z-10.0f); &#125; floorBatch.End(); //参考图- ceiling.png ceilingBatch.Begin(GL_TRIANGLE_STRIP, 28, 1); for(z = 60.0f; z &gt;= 0.0f; z -=10.0f) &#123; ceilingBatch.MultiTexCoord2f(0, 0.0f, 1.0f); ceilingBatch.Vertex3f(-10.0f, 10.0f, z - 10.0f); ceilingBatch.MultiTexCoord2f(0, 1.0f, 1.0f); ceilingBatch.Vertex3f(10.0f, 10.0f, z - 10.0f); ceilingBatch.MultiTexCoord2f(0, 0.0f, 0.0f); ceilingBatch.Vertex3f(-10.0f, 10.0f, z); ceilingBatch.MultiTexCoord2f(0, 1.0f, 0.0f); ceilingBatch.Vertex3f(10.0f, 10.0f, z); &#125; ceilingBatch.End(); //参考图 - leftWall.png leftWallBatch.Begin(GL_TRIANGLE_STRIP, 28, 1); for(z = 60.0f; z &gt;= 0.0f; z -=10.0f) &#123; leftWallBatch.MultiTexCoord2f(0, 0.0f, 0.0f); leftWallBatch.Vertex3f(-10.0f, -10.0f, z); leftWallBatch.MultiTexCoord2f(0, 0.0f, 1.0f); leftWallBatch.Vertex3f(-10.0f, 10.0f, z); leftWallBatch.MultiTexCoord2f(0, 1.0f, 0.0f); leftWallBatch.Vertex3f(-10.0f, -10.0f, z - 10.0f); leftWallBatch.MultiTexCoord2f(0, 1.0f, 1.0f); leftWallBatch.Vertex3f(-10.0f, 10.0f, z - 10.0f); &#125; leftWallBatch.End(); //参考图 - rightWall.png rightWallBatch.Begin(GL_TRIANGLE_STRIP, 28, 1); for(z = 60.0f; z &gt;= 0.0f; z -=10.0f) &#123; rightWallBatch.MultiTexCoord2f(0, 0.0f, 0.0f); rightWallBatch.Vertex3f(10.0f, -10.0f, z); rightWallBatch.MultiTexCoord2f(0, 0.0f, 1.0f); rightWallBatch.Vertex3f(10.0f, 10.0f, z); rightWallBatch.MultiTexCoord2f(0, 1.0f, 0.0f); rightWallBatch.Vertex3f(10.0f, -10.0f, z - 10.0f); rightWallBatch.MultiTexCoord2f(0, 1.0f, 1.0f); rightWallBatch.Vertex3f(10.0f, 10.0f, z - 10.0f); &#125; rightWallBatch.End();&#125; 窗口设置123456789101112131415161718192021222324//改变视景体和视口，在改变窗口大小或初始化窗口调用void ChangeSize(int w, int h)&#123; if (h == 0) &#123; h = 1; &#125; glViewport(0, 0, w, h); //透视投影纵横比 GLfloat fAspect; fAspect = (GLfloat)w / (GLfloat)h; //设置透视投影 viewFrustum.SetPerspective(80.0f, fAspect, 1.0, 120.0); //获取到投影矩阵 projectionMatrix.LoadMatrix(viewFrustum.GetProjectionMatrix()); //通过变换管线来管理投影矩阵堆栈 transformPipeline.SetMatrixStacks(modelViewMatrix, projectionMatrix); &#125; 调用，绘制场景123456789101112131415161718192021222324252627282930313233343536void RenderScene(void)&#123; glClear(GL_COLOR_BUFFER_BIT); modelViewMatrix.PushMatrix(); modelViewMatrix.Translate(0.0f, 0.0f, viewZ); //纹理替换矩阵着色器 /* 参数1:GLT_SHADER_TEXTURE_REPLACE 参数2:模型视图矩阵 &amp; 投影矩阵 参数3:纹理层次 */ shaderManager.UseStockShader(GLT_SHADER_TEXTURE_REPLACE,transformPipeline.GetModelViewProjectionMatrix(),0); //地板 glBindTexture(GL_TEXTURE_2D, textures[TEXTURE_FLOOR]); floorBatch.Draw(); //天花板 glBindTexture(GL_TEXTURE_2D, textures[TEXTURE_CEILING]); ceilingBatch.Draw(); //左右墙壁 glBindTexture(GL_TEXTURE_2D, textures[TEXTURE_BRICK]); leftWallBatch.Draw(); rightWallBatch.Draw(); modelViewMatrix.PopMatrix(); glutSwapBuffers(); &#125; 效果图]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>opengl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenGL(七)-纹理(上)]]></title>
    <url>%2F2019%2F02%2F20%2FOpenGL(%E4%B8%83)-%E7%BA%B9%E7%90%86(%E4%B8%8A)%2F</url>
    <content type="text"><![CDATA[设定金字塔坐标注意纹理坐标的设置方式:1234567//设置顶点对应的纹理坐标// s , t 相当于 x , y// MultiTexCoord2f(GLuint texture, GLclampf s, GLclampf t);//参数1:纹理的层次//参数2:s坐标//参数3:t坐标pyramidBatch.MultiTexCoord2f(0, 0.0f, 0.0f); 绘制金字塔纹理1.顶点/纹理坐标数据设置及图形绘制123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137GLBatch pyramidBatch;//绘制批次类 //1.pyramidBatch //通过三角形批次类pyramidBatch 来组件图形 //参数1:类型 //参数2:顶点数 6 * 3 = 18 //参数3:需要使用到纹理,默认为0,可以不写这个参数 pyramidBatch.Begin(GL_TRIANGLES, 18,1); //2.金字塔各个面的点坐标设置 //金字塔底部 //底部四边形 = 三角形X + 三角形Y //三角形X //----------vBlackLeft------------ //设置法线坐标-光照 pyramidBatch.Normal3f(0.0f, -1.0f, 0.0f); //设置顶点对应的纹理坐标 // MultiTexCoord2f(GLuint texture, GLclampf s, GLclampf t); //参数1:纹理的层次 //参数2:s坐标 //参数3:t坐标 pyramidBatch.MultiTexCoord2f(0, 0.0f, 0.0f); //设置顶点坐标 pyramidBatch.Vertex3f(-1.0f, -1.0f, -1.0f); //------vBackRight------------ pyramidBatch.Normal3f(0.0f, -1.0f, 0.0f); pyramidBatch.MultiTexCoord2f(0, 1.0f, 0.0f); pyramidBatch.Vertex3f(1.0f, -1.0f, -1.0f); //------vFrontRight点------------ pyramidBatch.Normal3f(0.0f, -1.0f, 0.0f); pyramidBatch.MultiTexCoord2f(0, 1.0f, 1.0f); pyramidBatch.Vertex3f(1.0f, -1.0f, 1.0f); //三角形Y pyramidBatch.Normal3f(0.0f, -1.0f, 0.0f); pyramidBatch.MultiTexCoord2f(0, 0.0f, 1.0f); pyramidBatch.Vertex3f(-1.0f, -1.0f, 1.0f); pyramidBatch.Normal3f(0.0f, -1.0f, 0.0f); pyramidBatch.MultiTexCoord2f(0, 0.0f, 0.0f); pyramidBatch.Vertex3f(-1.0f, -1.0f, -1.0f); pyramidBatch.Normal3f(0.0f, -1.0f, 0.0f); pyramidBatch.MultiTexCoord2f(0, 1.0f, 1.0f); pyramidBatch.Vertex3f(1.0f, -1.0f, 1.0f); //塔顶 M3DVector3f vApex = &#123;0.0f,1.0f,0.0f&#125;; M3DVector3f vFrontLeft = &#123;-1.0f,-1.0f,1.0f&#125;; M3DVector3f vFrontRight = &#123;1.0f,-1.0f,1.0f&#125;; M3DVector3f vBackLeft = &#123;-1.0f,-1.0f,-1.0f&#125;; M3DVector3f vBackRight = &#123;1.0f,-1.0f,-1.0f&#125;; //目的:为了临时存储法线向量 M3DVector3f n; //金字塔的前面 //三角形:(Apex,vFrontLeft,vFrontRight) //找法线 //m3dFindNormal(M3DVector3f result, const M3DVector3f point1, const M3DVector3f point2,const M3DVector3f point3); //参数1:结果 //参数2-4:3个顶点 m3dFindNormal(n, vApex, vFrontLeft, vFrontRight); //vApex pyramidBatch.Normal3fv(n); pyramidBatch.MultiTexCoord2f(0, 0.5, 1.0f); pyramidBatch.Vertex3fv(vApex); //vFrontLeft pyramidBatch.Normal3fv(n); pyramidBatch.MultiTexCoord2f(0, 0.0f, 0.0f); pyramidBatch.Vertex3fv(vFrontLeft); //vFrongRight pyramidBatch.Normal3fv(n); pyramidBatch.MultiTexCoord2f(0, 1.0f, 0.0f); pyramidBatch.Vertex3fv(vFrontRight); //金字塔的左边 //三角形:(Apex,vBackLeft,vFrontLeft) m3dFindNormal(n, vApex, vBackLeft, vFrontLeft); //vApex pyramidBatch.Normal3fv(n); pyramidBatch.MultiTexCoord2f(0, 0.5f, 1.0f); pyramidBatch.Vertex3fv(vApex); //vBackLeft pyramidBatch.Normal3fv(n); pyramidBatch.MultiTexCoord2f(0, 1.0f, 0.0f); pyramidBatch.Vertex3fv(vBackLeft); //vFrontLeft pyramidBatch.Normal3fv(n); pyramidBatch.MultiTexCoord2f(0, 0.0f, 0.0f); pyramidBatch.Vertex3fv(vFrontLeft); //金字塔右边 //三角形：（vApex, vFrontRight, vBackRight） m3dFindNormal(n, vApex, vFrontRight, vBackRight); pyramidBatch.Normal3fv(n); pyramidBatch.MultiTexCoord2f(0, 0.5f, 1.0f); pyramidBatch.Vertex3fv(vApex); pyramidBatch.Normal3fv(n); pyramidBatch.MultiTexCoord2f(0, 1.0f, 0.0f); pyramidBatch.Vertex3fv(vFrontRight); pyramidBatch.Normal3fv(n); pyramidBatch.MultiTexCoord2f(0, 0.0f, 0.0f); pyramidBatch.Vertex3fv(vBackRight); //金字塔后边 //三角形：（vApex, vBackRight, vBackLeft） m3dFindNormal(n, vApex, vBackRight, vBackLeft); pyramidBatch.Normal3fv(n); pyramidBatch.MultiTexCoord2f(0, 0.5f, 1.0f); pyramidBatch.Vertex3fv(vApex); pyramidBatch.Normal3fv(n); pyramidBatch.MultiTexCoord2f(0, 0.0f, 0.0f); pyramidBatch.Vertex3fv(vBackRight); pyramidBatch.Normal3fv(n); pyramidBatch.MultiTexCoord2f(0, 1.0f, 0.0f); pyramidBatch.Vertex3fv(vBackLeft); //结束批次设置 pyramidBatch.End(); 2.加载2D纹理1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980// 将TGA文件加载为2D纹理。//参数1:纹理文件名称//参数2:缩小时过滤器使用的哪一种//参数3:放大小时过滤器使用的哪一种//参数4:纹理坐标环绕方式bool LoadTGATexture(const char *szFileName, GLenum minFilter, GLenum magFilter, GLenum wrapMode)&#123; GLbyte *pBits; int nWidth,nHeight,nComponents; GLenum eFormat; //1.读取纹理的像素 //参数1:纹理文件的名称 //参数2:文件的宽度地址 //参数3:文件的高度地址 //参数4:文件的组件地址 //参数5:文件格式地址 //返回值:pBits ,指向图像数据的指针 pBits = gltReadTGABits(szFileName, &amp;nWidth, &amp;nHeight, &amp;nComponents, &amp;eFormat); if (pBits == NULL) &#123; printf("读取纹理像素失败\n"); return false; &#125; //2.设置纹理参数 //设置s,t的环绕方式 //glTexParameteri (GLenum target, GLenum pname, GLint param); //参数1:纹理维度 //参数2:为S/T坐标设置环绕模式 //参数3:wrapMode,环绕模式 glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, wrapMode); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, wrapMode); //设置放大\缩小的过滤方式 glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, minFilter); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, magFilter); //3.精密包装像素数据 //glPixelStorei (GLenum pname, GLint param); //参数1:GL_UNPACK_ALIGNMENT ,OpenGL 如何从数据缓存区中解包图像数据 //参数2:设置GL_UNPACK_ALIGNMENT的值 glPixelStorei(GL_UNPACK_ALIGNMENT, 1); //4.载入纹理 //glTexImage2D (GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels); //参数1:纹理的维度 //参数2:mip贴图层次 //参数3:加载纹理颜色成分(从读取像素图获取的) //参数4:加载纹理的宽 //参数5:加载纹理的高 //参数6:纹理的边框 //参数7:像素数据的类型 //参数8:指向纹理数据的指针 //详细可参考PPT glTexImage2D(GL_TEXTURE_2D, 0, nComponents, nWidth, nHeight, 0, eFormat, GL_UNSIGNED_BYTE, pBits); //使用完释放 free(pBits); //只有minFilter 等于以下四种模式，才可以生成Mip贴图 //GL_NEAREST_MIPMAP_NEAREST具有非常好的性能，并且闪烁现象非常弱 //GL_LINEAR_MIPMAP_NEAREST常常用于对游戏进行加速，它使用了高质量的线性过滤器 //GL_LINEAR_MIPMAP_LINEAR 和GL_NEAREST_MIPMAP_LINEAR 过滤器在Mip层之间执行了一些额外的插值，以消除他们之间的过滤痕迹。 //GL_LINEAR_MIPMAP_LINEAR 三线性Mip贴图。纹理过滤的黄金准则，具有最高的精度。 if(minFilter == GL_LINEAR_MIPMAP_LINEAR || minFilter == GL_LINEAR_MIPMAP_NEAREST || minFilter == GL_NEAREST_MIPMAP_LINEAR || minFilter == GL_NEAREST_MIPMAP_NEAREST) //加载Mip,纹理生成所有的Mip层 //参数：GL_TEXTURE_1D、GL_TEXTURE_2D、GL_TEXTURE_3D glGenerateMipmap(GL_TEXTURE_2D); return true;&#125; 3.SetUp12345678910111213141516171819202122232425262728293031323334353637void SetupRC()&#123; glClearColor(0.7f, 0.7f,0.7f, 1.0f); shaderManager.InitializeStockShaders(); //开启深度测试 glEnable(GL_DEPTH_TEST); //纹理对象的处理 //1.分配纹理对象 // glGenTextures (GLsizei n, GLuint *textures); //参数1:纹理对象的个数 //参数2:纹理对象的指针 glGenTextures(1, &amp;textureID); //2.绑定纹理状态 //glBindTexture (GLenum target, GLuint texture); //参数1:纹理的状态,GL_TEXTURE_1D\GL_TEXTURE_2D\GL_TEXTURE_3D glBindTexture(GL_TEXTURE_2D, textureID); //3.将TGA文件加载成2D纹理 //函数是开发者自己设计的 //参数1:纹理文件名称 //参数2:缩小时过滤器使用的哪一种 //参数3:放大小时过滤器使用的哪一种 //参数4:纹理坐标环绕方式 LoadTGATexture("brick.tga", GL_LINEAR, GL_LINEAR, GL_CLAMP_TO_EDGE); //4.设置渲染图像的顶点--金字塔 MakePyramid(pyramidBatch); cameraFrame.MoveForward(-10.0); &#125; 4.渲染1234567891011121314151617181920212223242526272829303132333435363738394041424344454647void RenderScene(void)&#123; //光照位置 static GLfloat vLightPos[] = &#123;1.0f,1.0f,0.0f&#125;; //关照颜色 static GLfloat vWhite[] = &#123;1.0f,0.0f,0.0f,1.0f&#125;; //glClear(GL_COLOR_BUFFER_BIT| GL_DEPTH_BUFFER|GL_STENCIL_BUFFER_BIT); glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT); modelViewMatrix.PushMatrix(); //观察者 M3DMatrix44f mCamera; cameraFrame.GetCameraMatrix(mCamera); modelViewMatrix.MultMatrix(mCamera); // M3DMatrix44f mObjectFrame; objectFrame.GetMatrix(mObjectFrame); modelViewMatrix.MultMatrix(mObjectFrame); //错误地方!!! //glBindTexture(GL_TEXTURE_2D, 0); glBindTexture(GL_TEXTURE_2D, textureID); //点光源着色器 //参数1:GLT_SHADER_TEXTURE_POINT_LIGHT_DIFF //参数2:模型视图矩阵 //参数3:投影矩阵 //参数4:光源的位置 //参数5:光的颜色 //参数6:图形颜色(如使用了纹理,则设置为0) shaderManager.UseStockShader(GLT_SHADER_TEXTURE_POINT_LIGHT_DIFF,transformPipeline.GetModelViewMatrix(),transformPipeline.GetProjectionMatrix(),vLightPos,vWhite,0); pyramidBatch.Draw(); modelViewMatrix.PopMatrix(); glutSwapBuffers(); &#125; 效果图]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>opengl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenGL(六)-坐标系统]]></title>
    <url>%2F2019%2F02%2F20%2FOpenGL(%E5%85%AD)-%E5%9D%90%E6%A0%87%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[在OpenGL 中有5种坐标系。1.局部坐标系(物体空间)2.世界空间3.观察空间(视觉空间)4.裁剪空间5.屏幕空间 下图是一个顶点最终转化到片段之前需要经历的所有不同的状态变化: 局部空间： 指的是物体所在的坐标空间，即是建立一个建模软件创建一个模型立方体。创建的立方体的原点可能是[0,0,0]。但它在你的程序里可能处于不同的位置。所以你的模型文件的顶点都以[0,0,0]这个为初始位置。但是他们最终显示在世界坐标系的那个位置不由局部坐标系决定。 你的模型文件所有的顶点都处于局部空间中。 比如我创建一个立体箱子,它的范围和原点都是针对局部坐标的。 世界空间： 如果我们将我们所有的物体导入到程序当中，它们有可能会全挤在世界的原点(0, 0, 0)上，这并不是我们想要的结果。我们想为每一个物体定义一个位置，从而能在更大的世界当中放置它们。世界空间中的坐标正如其名：是指顶点相对于（游戏）世界的坐标。如果你希望将物体分散在世界上摆放（特别是非常真实的那样），这就是你希望物体变换到的空间。物体的坐标将会从局部变换到世界空间；该变换是由模型矩阵(Model Matrix)实现的 模型矩阵是一种变换矩阵，它能通过对物体进行位移、缩放、旋转来将它置于它本应该在的位置或朝向。你可以将它想像为变换一个房子，你需要先将它缩小（它在局部空间中太大了），并将其位移至郊区的一个小镇，然后在y轴上往左旋转一点以搭配附近的房子。你也可以把上一节将箱子到处摆放在场景中用的那个矩阵大致看作一个模型矩阵；我们将箱子的局部坐标变换到场景/世界中的不同位置。 观察空间： 观察空间经常被人们称之OpenGL的摄像机(Camera)（所以有时也称为摄像机空间(Camera Space)或视觉空间(Eye Space)）。观察空间是将世界空间坐标转化为用户视野前方的坐标而产生的结果。因此观察空间就是从摄像机的视角所观察到的空间。而这通常是由一系列的位移和旋转的组合来完成，平移/旋转场景从而使得特定的对象被变换到摄像机的前方。这些组合在一起的变换通常存储在一个观察矩阵(View Matrix)里，它被用来将世界坐标变换到观察空间 裁剪空间： 在一个顶点着色器运行的最后，OpenGL期望所有的坐标都能落在一个特定的范围内，且任何在这个范围之外的点都应该被裁剪掉(Clipped)。被裁剪掉的坐标就会被忽略，所以剩下的坐标就将变为屏幕上可见的片段。这也就是裁剪空间(Clip Space)名字的由来。 因为将所有可见的坐标都指定在-1.0到1.0的范围内不是很直观，所以我们会指定自己的坐标集(Coordinate Set)并将它变换回标准化设备坐标系，就像OpenGL期望的那样。 为了将顶点坐标从观察变换到裁剪空间，我们需要定义一个投影矩阵(Projection Matrix)，它指定了一个范围的坐标，比如在每个维度上的-1000到1000。投影矩阵接着会将在这个指定的范围内的坐标变换为标准化设备坐标的范围(-1.0, 1.0)。所有在范围外的坐标不会被映射到在-1.0到1.0的范围之间，所以会被裁剪掉。在上面这个投影矩阵所指定的范围内，坐标(1250, 500, 750)将是不可见的，这是由于它的x坐标超出了范围，它被转化为一个大于1.0的标准化设备坐标，所以被裁剪掉了。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>opengl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenGL(五)-矩阵变换]]></title>
    <url>%2F2019%2F02%2F20%2FOpenGL(%E4%BA%94)-%E7%9F%A9%E9%98%B5%E5%8F%98%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[关键函数讲解平移123456789101112//创建单元矩阵 M3DMatrix44f m3;m3dLoadIdentity44(m3);/* m3dTranslationMatrix44(M3DMatrix44f m, float x, float y, float z) 参数1:结果矩阵,平移之后的结果矩阵 参数2:沿着X轴移动多少,正数\负数 参数3:沿着Y轴移动多少,正数\负数 参数4:沿着Z轴移动多少,正数\负数 */m3dTranslationMatrix44(m3, 0.0f, 10.0f, 0.0f); 旋转1234567891011121314151617181920 /* m3dRotationMatrix44(M3DMatrix44f m, float angle, float x, float y, float z); 参数1:结果矩阵,旋转之后的结果矩阵 参数2:旋转多少弧度 参数3:是否围绕X轴旋转,是(1),不是(0) 参数4:是否围绕Y轴旋转,是(1),不是(0) 参数5:是否围绕Z轴旋转,是(1),不是(0) */ m3dRotationMatrix44(m3, m3dDegToRad(45.0f), 1.0f, 0.0f, 0.0f);``` ### 缩放```objc /* void m3dScaleMatrix44(M3DMatrix44f m, float xScale, float yScale, float zScale) 参数1:结果矩阵 参数2:围绕X轴放大\缩小;放大x&gt;1,缩小:0.5f 参数3:围绕Y轴放大\缩小;放大x&gt;1,缩小:0.5f 参数4:围绕Z轴放大\缩小;放大x&gt;1,缩小:0.5f */ m3dScaleMatrix44(m3, 1.0f, 10.0f, 1.0f); 案例1 : 利用矩阵的平移、旋转、综合变化等, 实现矩阵的移动.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119GLBatch squareBatch;GLfloat blockSize = 0.1f;GLfloat vVerts[] = &#123; -blockSize, -blockSize, 0.0f, blockSize, -blockSize, 0.0f, blockSize, blockSize, 0.0f, -blockSize, blockSize, 0.0f&#125;;GLfloat xPos = 0.0f;GLfloat yPos = 0.0f;void SetupRC()&#123; //背景颜色 glClearColor(0.0f, 0.0f, 1.0f, 1.0f ); shaderManager.InitializeStockShaders(); // 加载矩形 squareBatch.Begin(GL_TRIANGLE_FAN, 4); squareBatch.CopyVertexData3f(vVerts); squareBatch.End();&#125;//移动（移动只是计算了X,Y移动的距离，以及碰撞检测）void SpecialKeys(int key, int x, int y)&#123; GLfloat stepSize = 0.025f; if(key == GLUT_KEY_UP) yPos += stepSize; if(key == GLUT_KEY_DOWN) yPos -= stepSize; if(key == GLUT_KEY_LEFT) xPos -= stepSize; if(key == GLUT_KEY_RIGHT) xPos += stepSize; // 碰撞检测 if(xPos &lt; (-1.0f + blockSize)) xPos = -1.0f + blockSize; if(xPos &gt; (1.0f - blockSize)) xPos = 1.0f - blockSize; if(yPos &lt; (-1.0f + blockSize)) yPos = -1.0f + blockSize; if(yPos &gt; (1.0f - blockSize)) yPos = 1.0f - blockSize; // 每次操作方向键之后, 重新调用RenderScene进行新的场景渲染 glutPostRedisplay();&#125;void RenderScene(void)&#123; glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT); GLfloat vRed[] = &#123; 1.0f, 0.0f, 0.0f, 1.0f &#125;; //!!!矩阵变化 - 关键代码!!! M3DMatrix44f mFinalTransform, mTranslationMatrix, mRotationMatrix; //平移 xPos,yPos m3dTranslationMatrix44(mTranslationMatrix, xPos, yPos, 0.0f); // 每次重绘时，旋转5度 static float yRot = 0.0f; yRot += 5.0f; m3dRotationMatrix44(mRotationMatrix, m3dDegToRad(yRot), 0.0f, 0.0f, 1.0f); //将旋转和移动的结果合并到mFinalTransform 中 m3dMatrixMultiply44(mFinalTransform, mTranslationMatrix, mRotationMatrix); //将矩阵结果提交到固定着色器（平面着色器）中。 shaderManager.UseStockShader(GLT_SHADER_FLAT, mFinalTransform, vRed); //!!!矩形重新绘制, 即会出现一个既平移了方向又旋转了角度的新矩形 squareBatch.Draw(); // 执行缓冲区交换 glutSwapBuffers();&#125;void ChangeSize(int w, int h)&#123; glViewport(0, 0, w, h);&#125;int main(int argc, char* argv[])&#123; gltSetWorkingDirectory(argv[0]); glutInit(&amp;argc, argv); glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGBA | GLUT_DEPTH); glutInitWindowSize(600, 600); glutCreateWindow("Move Block with Arrow Keys"); GLenum err = glewInit(); if (GLEW_OK != err) &#123; fprintf(stderr, "Error: %s\n", glewGetErrorString(err)); return 1; &#125; glutReshapeFunc(ChangeSize);//设置视口大小 glutDisplayFunc(RenderScene);//渲染场景 glutSpecialFunc(SpecialKeys);//键盘方向键操作 SetupRC(); glutMainLoop(); return 0;&#125; 效果图:注: 本例是键盘的上下左右方向键来控制矩形的旋转平移, 具体代码参见上面 案例2 : 利用模型视图矩阵和投影矩阵让一个球体旋转绘制球体123gltMakeSphere(torusBatch, 0.4f, 10, 20);glPolygonMode(GL_FRONT_AND_BACK, GL_LINE); 设置模型视图矩阵 和 投影矩阵12345678910111213141516171819202122232425262728293031323334//建立一个基于时间变化的动画static CStopWatch rotTimer;//当前时间 * 60sfloat yRot = rotTimer.GetElapsedSeconds() * 60.0f;glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);//矩阵变量M3DMatrix44f mTranlate,mRotate,mModelView,mModelViewProjection;//将圆球像Z轴负方向移动2.5个单位长度m3dTranslationMatrix44(mTranlate, 0.0f , 0.0f,-2.5f);//旋转m3dRotationMatrix44(mRotate, m3dDegToRad(yRot), 0.0f, 1.0f, 0.0f);//将平移和旋转的矩阵进行叉乘,产生一个新的矩阵mModelViewm3dMatrixMultiply44(mModelView, mTranlate, mRotate);//模型视图矩阵 和 投影矩阵//将投影矩阵 与 模型视图矩阵进行叉乘 ,将变化最终结果通过矩阵叉乘的方式应用到mModelViewProjection中来m3dMatrixMultiply44(mModelViewProjection, viewFrustum.GetProjectionMatrix(), mModelView);GLfloat vBlack[] = &#123;0.0f,0.0f,0.0f,1.0f&#125;;//平面着色器来渲染图像shaderManager.UseStockShader(GLT_SHADER_FLAT,mModelViewProjection,vBlack);//开始绘图torusBatch.Draw();glutSwapBuffers();glutPostRedisplay(); 效果图]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>opengl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenGL(四)-两种方式实现抗锯齿效果]]></title>
    <url>%2F2019%2F02%2F20%2FOpenGL(%E5%9B%9B)-%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E6%8A%97%E9%94%AF%E9%BD%BF%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[方式一 : 利用混合(GLBlend)实现抗锯齿 核心代码如下:12345678910111213141516171819202122232425262728293031323334// 选择菜单void ProcessMenu(int value)&#123; switch (value) &#123; case 1: //打开抗锯齿功能 //1.开启混合功能 glEnable(GL_BLEND); //2.指定混合因子 //注意:如果你修改了混合方程式,当你使用混合抗锯齿功能时,请一定要改为默认混合方程式 glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); //3.开启对点\线\多边形的抗锯齿功能 glEnable(GL_POINT_SMOOTH); glEnable(GL_LINE_SMOOTH); glEnable(GL_POLYGON_SMOOTH); break; case 2: //关闭抗锯齿功能 glDisable(GL_BLEND); glDisable(GL_LINE_SMOOTH); glDisable(GL_POINT_SMOOTH); glDisable(GL_POLYGON_SMOOTH); break; default: break; &#125; glutPostRedisplay();&#125; 方式二 : 利用多重采样实现抗锯齿12345678//用多重采样来解决锯齿问题.可选 glEnable(GLUT_MULTISAMPLE); //绘制 moonBatch.Draw(); //绘制完成,则关闭 glDisable(GLUT_MULTISAMPLE); 效果图: 关闭抗锯齿: 打开抗锯齿:]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>opengl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenGL(三)-深度测试]]></title>
    <url>%2F2019%2F02%2F20%2FOpenGL(%E4%B8%89)-%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[什么叫深度?所谓深度,就是在坐标系中,像素Z坐标距离观察者的距离.观察者可以在任何位置.OpenGL会有专门一块缓存区来存放Z值, 即深度缓冲区. 深度缓冲区作用?一般情况下,我们绘制图形时,后面绘制的会覆盖前面的图形.这样就会产生一个性能问题:就是遮盖部分,先绘制的会被覆盖,那么这块区域就是无意义的绘制.深度测试就是用来解决这个问题的.它是如何处理的呢?有了深度缓冲区之后,绘制的时候会检查Z值,靠近观察者的不覆盖, 远离观察者的被覆盖,而不是靠绘制顺序来决定. 如何使用深度缓冲区测试?glEnable(GLDEPTHTEST);开启之后,就会先测试深度值再绘制默认情况下, Z值小的会被覆盖 如果观察者,在Z轴的正方向,Z值大则靠近观察者如果观察者,在Z轴的负方向,Z值小则靠近观察者 如何解决深度值相同,造成的冲突问题? 第一种方法:在第二次绘制时, 稍微偏移一点点解决这个问题.注意:必须非常小心确保Z值的间隙.(比如贴在飞机上的五角星会悬浮起来的风险) 第二种方法:采用glPolygonOffset函数,使得可以调节片段的深度值.使深度值偏移而不产生悬浮.]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>opengl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenGL(二)-基本图元绘制]]></title>
    <url>%2F2019%2F02%2F20%2FOpenGL(%E4%BA%8C)-%E5%9F%BA%E6%9C%AC%E5%9B%BE%E5%85%83%E7%BB%98%E5%88%B6%2F</url>
    <content type="text"><![CDATA[OpenGL与着色器在OpenGL 3.0之前，OpenGL包含一个固定功能的管线，它可以在不使用着色器的情况下处理几何与像素数据。从3.1版本开始，固定管线从核心模式去掉。因此现在需要使用着色器来完成工作.我们会使用GLSL,(OpenGL Shading Language，它是在OpenGL 2.0版本发布的)。 语法与“C、C++”类似。 基础图形管线OpenGL中的图元只不过是顶点的集合以预定义的方式结合在一起。管线分为:2个部分，上半部分是 客户机端，下半部分是服务器端。服务器 和 客户端 在功能和运行上都是异步的。它们是各自独立的软件块或硬件块。 三种向OpenGL 着色器传递渲染数据的方法: 属性: 就是对一个顶点都要作改变的数据元素。实际上，顶点位置本身就是一个属性。属性可以是浮点类型、整型、布尔类型. Uniform: 通过设置Uniform 变量发送一个图元批次命令。Uniform 变量实际上可以无限次限制地使用，比如设置一个应用于整个表面的单个颜色值。还可以设置一个时间值 纹理 基本图元类型 注意着重区分以下三种绘制方式的区别 存储着色器的使用着色器有以下分类：• 单位着色器• 平面着色器• 上色着色器• 默认光源着色器• 点光源着色器• 纹理替换矩阵• 纹理调整着色器• 纹理光源着色器123456//定义着色器GLShaderMananger shaderManager;//初始化着色器 shaderManager.InitalizeStockShaders()//使用shaderManager userStockManager(参数列表) 单位着色器 GLShaderManager::UserStockShader(GLT_ATTRIBUTE_VERTEX,GLfloat vColor[4]); 平面着色器 GLShaderManager::UserStockShader(GLT_SHADER_FLAT,GLfloat mvp[16],GLfloat vColor[4]); 上色着色器 GLShaderManager::UserStockShader(GLT_SHADER_SHADED,GLfloat mvp[16]); 默认光源着色器 GLShaderManager::UserStockShader(GLT_SHADER_DEFAULT_LIGHT,GLfloat mvMatrix[16],GLfloat pMatrix[16],GLfloat vColor[4]); 点光源着色器 GLShaderManager::UserStockShader(GLT_SHADER_DEFAULT_LIGHT_DIEF,GLfloat mvMatrix[16],GLfloat pMatrix[16],GLfloat vLightPos[3],GLfloat vColor[4]); 纹理替换矩阵着色器 GLShaderManager::UserStockShader(GLT_SHADER_TEXTURE_REPLACE,GLfloat mvMatrix[16],GLint nTextureUnit); 纹理调整着色器 GLShaderManager::UserStockShader(GLT_SHADER_TEXTURE_MODULATE,GLfloat mvMatrix[16],GLfloat vColor[4],GLint nTextureUnit); 纹理光源着色器 GLShaderManager::UserStockShader(GLT_SHADER_TEXTURE_POINT_LIGHT_DIEF,GLfloat mvMatrix[16],GLfloat pMatrix[16],GLfloat vLightPos[3],GLfloat vBaseColor[4],GLint nTextureUnit); 绘制不同类型的图元123456789101112131415161718192021// 各种需要的类GLShaderManager shaderManager;GLMatrixStack modelViewMatrix;GLMatrixStack projectionMatrix;GLFrame cameraFrame;GLFrame objectFrame;//投影矩阵GLFrustum viewFrustum;//容器类（7种不同的图元对应7种容器对象）GLBatch pointBatch;GLBatch lineBatch;GLBatch lineStripBatch;GLBatch lineLoopBatch;GLBatch triangleBatch;GLBatch triangleStripBatch;GLBatch triangleFanBatch;//几何变换的管道GLGeometryTransform transformPipeline;M3DMatrix44f shadowMatrix; 点/线/线段/线环绘制12345678910111213141516171819202122232425262728293031323334// 准备一些随机点数据 GLfloat vCoast[24][3] = &#123; &#123;2.80, 1.20, 0.0 &#125;, &#123;2.0, 1.20, 0.0 &#125;, &#123;2.0, 1.08, 0.0 &#125;, &#123;2.0, 1.08, 0.0 &#125;, &#123;0.0, 0.80, 0.0 &#125;, &#123;-.32, 0.40, 0.0 &#125;, &#123;-.48, 0.2, 0.0 &#125;, &#123;-.40, 0.0, 0.0 &#125;, &#123;-.60, -.40, 0.0 &#125;, &#123;-.80, -.80, 0.0 &#125;, &#123;-.80, -1.4, 0.0 &#125;, &#123;-.40, -1.60, 0.0 &#125;, &#123;0.0, -1.20, 0.0 &#125;, &#123; .2, -.80, 0.0 &#125;, &#123;.48, -.40, 0.0 &#125;, &#123;.52, -.20, 0.0 &#125;, &#123;.48, .20, 0.0 &#125;, &#123;.80, .40, 0.0 &#125;, &#123;1.20, .80, 0.0 &#125;, &#123;1.60, .60, 0.0 &#125;, &#123;2.0, .60, 0.0 &#125;, &#123;2.2, .80, 0.0 &#125;, &#123;2.40, 1.0, 0.0 &#125;, &#123;2.80, 1.0, 0.0 &#125;&#125;; //用点的形式绘制(GL_POINTS) pointBatch.Begin(GL_POINTS, 24); pointBatch.CopyVertexData3f(vCoast); pointBatch.End(); //通过线的形式绘制(GL_LINES) lineBatch.Begin(GL_LINES, 24); lineBatch.CopyVertexData3f(vCoast); lineBatch.End(); //通过线段的形式绘制(GL_LINE_STRIP) lineStripBatch.Begin(GL_LINE_STRIP, 24); lineStripBatch.CopyVertexData3f(vCoast); lineStripBatch.End(); //通过线环的形式绘制(GL_LINE_LOOP) lineLoopBatch.Begin(GL_LINE_LOOP, 24); lineLoopBatch.CopyVertexData3f(vCoast); lineLoopBatch.End(); 效果如下: 三角形绘制方式 - GL_TRIANGLES123456789101112131415161718192021222324252627 //通过三角形绘制(GL_TRIANGLES) -- 生成一个金字塔的形状 GLfloat vPyramid[12][3] = &#123; -2.0f, 0.0f, -2.0f, 2.0f, 0.0f, -2.0f, 0.0f, 4.0f, 0.0f, 2.0f, 0.0f, -2.0f, 2.0f, 0.0f, 2.0f, 0.0f, 4.0f, 0.0f, 2.0f, 0.0f, 2.0f, -2.0f, 0.0f, 2.0f, 0.0f, 4.0f, 0.0f, -2.0f, 0.0f, 2.0f, -2.0f, 0.0f, -2.0f, 0.0f, 4.0f, 0.0f&#125;; //GL_TRIANGLES 每3个顶点定义一个新的三角形 triangleBatch.Begin(GL_TRIANGLES, 12); triangleBatch.CopyVertexData3f(vPyramid); triangleBatch.End();``` * 效果图:![GL_TRIANGLES.png](http://upload-images.jianshu.io/upload_images/1352344-a577c287b2f55072.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)###### 三角形扇绘制方式 - GL_TRIANGLE_FAN // 三角形扇绘制(GL_TRIANGLE_FAN) -- 生成一个六边形 GLfloat vPoints[100][3]; //超过我们需要的数组 int nVerts = 0; //半径 GLfloat r = 3.0f; //原点(x,y,z) = (0,0,0); vPoints[nVerts][0] = 0.0f; vPoints[nVerts][1] = 0.0f; vPoints[nVerts][2] = 0.0f; //M3D_2PI 就是2Pi 的意思，就一个圆的意思。 绘制圆形 for(GLfloat angle = 0; angle &lt; M3D_2PI; angle += M3D_2PI / 6.0f) { //数组下标自增（每自增1次就表示一个顶点） nVerts++; /* 弧长=半径*角度,这里的角度是弧度制,不是平时的角度制 既然知道了cos值,那么角度=arccos,求一个反三角函数就行了 */ //x点坐标 cos(angle) * 半径 vPoints[nVerts][0] = float(cos(angle)) * r; //y点坐标 sin(angle) * 半径 vPoints[nVerts][1] = float(sin(angle)) * r; //z点的坐标 vPoints[nVerts][2] = -0.5f; } // 结束扇形 : 前面一共绘制7个顶点（包括圆心） printf(&quot;三角形扇形顶点数:%d\n&quot;,nVerts); //添加闭合的终点, 若不添加, 则三角形扇形是无法闭合的。 nVerts++; vPoints[nVerts][0] = r; vPoints[nVerts][1] = 0; vPoints[nVerts][2] = 0.0f; //GL_TRIANGLE_FAN 以一个圆心为中心呈扇形排列，共用相邻顶点的一组三角形 triangleFanBatch.Begin(GL_TRIANGLE_FAN, 8); triangleFanBatch.CopyVertexData3f(vPoints); triangleFanBatch.End(); 1234* 效果图:![GL_TRIANGLE_FAN.png](http://upload-images.jianshu.io/upload_images/1352344-ec20836c62236f9b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)###### 三角形条带绘制方式 - GL_TRIANGLE_STRIP //三角形条带绘制(GL_TRIANGLE_STRIP) -- 生成一个小环或圆柱段 //顶点下标 int iCounter = 0; //半径 GLfloat radius = 3.0f; //从0度~360度，以0.3弧度为步长 for(GLfloat angle = 0.0f; angle &lt;= (2.0f*M3D_PI); angle += 0.3f) { //或许圆形的顶点的X,Y GLfloat x = radius * sin(angle); GLfloat y = radius * cos(angle); //绘制2个三角形（他们的x,y顶点一样，只是z点不一样） vPoints[iCounter][0] = x; vPoints[iCounter][1] = y; vPoints[iCounter][2] = -0.5; iCounter++; vPoints[iCounter][0] = x; vPoints[iCounter][1] = y; vPoints[iCounter][2] = 0.5; iCounter++; } // 关闭循环 printf(&quot;三角形带的顶点数：%d\n&quot;,iCounter); //结束循环，在循环位置生成2个三角形 vPoints[iCounter][0] = vPoints[0][0]; vPoints[iCounter][1] = vPoints[0][1]; vPoints[iCounter][2] = -0.5; iCounter++; vPoints[iCounter][0] = vPoints[1][0]; vPoints[iCounter][1] = vPoints[1][1]; vPoints[iCounter][2] = 0.5; iCounter++; // GL_TRIANGLE_STRIP 共用一个条带（strip）上的顶点的一组三角形 triangleStripBatch.Begin(GL_TRIANGLE_STRIP, iCounter); triangleStripBatch.CopyVertexData3f(vPoints); triangleStripBatch.End(); ` 效果图:]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>opengl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenGL(一)-初识OpenGL及其在Mac上的环境搭建]]></title>
    <url>%2F2019%2F02%2F20%2FOpenGL(%E4%B8%80)-%E5%88%9D%E8%AF%86OpenGL%E5%8F%8A%E5%85%B6%E5%9C%A8Mac%E4%B8%8A%E7%9A%84%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[OpenGL是一种用于创建实时3D图像的编程接口。 走向3D三维(3D)表示一个正在描述或显示的物体具有三个维度：宽度，高度，深度。几个世纪以来，艺术家们已经知道如何让一幅画有立体感并具有真实感的深度，通过颜料在二维画布上创作的作品，它其实本质上画的是一个二维物体。类似，计算机3D图像实质上也是平面的，它只是在计算机屏幕上所显示的二维图像，但它可以提供深度的错觉。实际上如果我们需要一个物体的二维画面从不同角度上感知三维空间，我们可以通过透视、隐藏直线消除、颜色、着色和其他技巧来创建深度幻觉。 2D + 透视 = 3D 3D图形术语 变化&amp;投影 光栅化：实际绘制或填充每个顶点之间的像素形成过程 着色：沿着顶点之间改变颜色值。着色器则是图形硬件上执行的单独程序，用来处理顶点和光栅化任务。 纹理贴图：初学可以简单理解为贴到图形上的图片（但纹理并不是图片， 二者不等价）。在GPU上，纹理是快捷有效的。 混合：混合是将不同的颜色混合在一起。 3D图形的常见用途实时3D图形的应用范围包括交互式游戏和模拟数据的可视化显示（供科学、医学或商业应用）；在计算机领域，3D图形的应用几乎没有止境。目前最常见的用途，游戏、AR、VR，都是基于openGL的。3D图形在科学视觉和工程应用中非常流行，物美价廉的3D硬件大量涌现使得这些应用技术空前的流行火爆。Mac OS X以及iOS都是使用openGL对所有窗口和控件进行渲染，从而创建了功能强大，引人入胜的可视化界面。例如设计使用的3D Max， 游戏制作的Unity 3D， Cocos2D底层都是使用了openGL。医学上的影像渲染也是依托于openGL。着色器在实时计算机图形中，最前沿的技术是可编程着色器（Programmable Shading）。图形卡不再是低能的渲染芯片。而是功能强大的高度可编程的渲染计算机。类似CPU的术语GPU应运而生。它代表图形处理单元，特指当今图形卡上的可编程芯片。它们是高度并行，并且具有非常快的速度。同样重要的是， 程序员可以进行重新配置图形卡的工作方式，几乎可以实现任何想要得到的特殊效果。3D编程的基本原则 并发工具包openGL基于一种底层渲染API，我们不能告诉它“在什么地方绘制”， 而是我们需要自己动手，通过载入三角形，应用必要的变化和正确的纹理、着色器并在必要应用混合模式来组合一个模型。这使得我们能够进行大量的底层控制，与使用高层工具包相比，使用openGL这样的底层API动人之处在于，我们不能仅仅是重现许多标准3D渲染，我们可以创造自己的算法，甚至可以取发现一些新的捷径、性能技巧和艺术视觉技术。 坐标系统在openGL或几乎所有的3D API中创建一个用于绘图窗口时， 必须制定希望使用的坐标系统以及指定的坐标如何映射到实际的屏幕像素。OpenGL在Mac上的环境搭建准备资源 CLTools glew libGLTools.a这些资源都可以从网上下载到配置Xcode的openGL环境 打开Xcode -&gt; macOS -&gt; Cocoa Application 添加OpenGL.framework 和 GLUT.framework 两个系统库 libGLTools.a直接拖到工程的Frameworks文件里面，另外删除文件：AppDelegate.h、AppDelegate.m、main.m、ViewController.h、ViewController.m；创建main.cpp文件 在main.cpp中复制以下代码， 来测试环境是否配置成功： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include &lt;stdio.h&gt;#include "GLTools.h"#include &lt;GLUT/GLUT.h&gt;GLBatch triangleBatch;GLShaderManager shaderManager;//窗口大小改变时接受新的宽度和高度，其中0,0代表窗口中视口的左下角坐标，w，h代表像素void ChangeSize(int w,int h)&#123; glViewport(0,0, w, h); &#125;//为程序作一次性的设置void SetupRC()&#123; //设置背影颜色 glClearColor(0.0f,0.0f,1.0f,1.0f); //初始化着色管理器 shaderManager.InitializeStockShaders(); //设置三角形，其中数组vVert包含所有3个顶点的x,y,笛卡尔坐标对。 GLfloat vVerts[] = &#123; -0.5f,0.0f,0.0f, 0.5f,0.0f,0.0f, 0.0f,0.5f,0.0f, &#125;; //批次处理 triangleBatch.Begin(GL_TRIANGLES,3); triangleBatch.CopyVertexData3f(vVerts); triangleBatch.End(); &#125;//开始渲染void RenderScene(void)&#123; //清除一个或一组特定的缓冲区 glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT|GL_STENCIL_BUFFER_BIT); //设置一组浮点数来表示红色 GLfloat vRed[] = &#123;1.0f,0.0f,0.0f,1.0f&#125;; //传递到存储着色器，即GLT_SHADER_IDENTITY着色器，这个着色器只是使用指定颜色以默认笛卡尔坐标第在屏幕上渲染几何图形 shaderManager.UseStockShader(GLT_SHADER_IDENTITY,vRed); //提交着色器 triangleBatch.Draw(); //将在后台缓冲区进行渲染，然后在结束时交换到前台 glutSwapBuffers(); &#125;int main(int argc,char* argv[])&#123; //设置当前工作目录，针对MAC OS X gltSetWorkingDirectory(argv[0]); //初始化GLUT库 glutInit(&amp;argc, argv); /*初始化双缓冲窗口，其中标志GLUT_DOUBLE、GLUT_RGBA、GLUT_DEPTH、GLUT_STENCIL分别指 双缓冲窗口、RGBA颜色模式、深度测试、模板缓冲区*/ glutInitDisplayMode(GLUT_DOUBLE|GLUT_RGBA|GLUT_DEPTH|GLUT_STENCIL); //GLUT窗口大小，标题窗口 glutInitWindowSize(800,600); glutCreateWindow("Triangle"); //注册回调函数 glutReshapeFunc(ChangeSize); glutDisplayFunc(RenderScene); //驱动程序的初始化中没有出现任何问题。 GLenum err = glewInit(); if(GLEW_OK != err) &#123; fprintf(stderr,"glew error:%s\n",glewGetErrorString(err)); return 1; &#125; //调用SetupRC SetupRC(); glutMainLoop(); return 0; &#125; 编译， 将报错的地方文件&lt;&gt;系统引入， 改为“”普通引入 效果图 那么环境搭建到此就成功了。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>opengl</tag>
      </tags>
  </entry>
</search>
