<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[OpenGL(一)-初识OpenGL及其在Mac上的环境搭建]]></title>
    <url>%2F2019%2F02%2F20%2FOpenGL(%E4%B8%80)-%E5%88%9D%E8%AF%86OpenGL%E5%8F%8A%E5%85%B6%E5%9C%A8Mac%E4%B8%8A%E7%9A%84%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[OpenGL是一种用于创建实时3D图像的编程接口。 ##走向3D三维(3D)表示一个正在描述或显示的物体具有三个维度：宽度，高度，深度。几个世纪以来，艺术家们已经知道如何让一幅画有立体感并具有真实感的深度，通过颜料在二维画布上创作的作品，它其实本质上画的是一个二维物体。类似，计算机3D图像实质上也是平面的，它只是在计算机屏幕上所显示的二维图像，但它可以提供深度的错觉。实际上如果我们需要一个物体的二维画面从不同角度上感知三维空间，我们可以通过透视、隐藏直线消除、颜色、着色和其他技巧来创建深度幻觉。 2D + 透视 = 3D ##3D图形术语 变化&amp;投影 光栅化：实际绘制或填充每个顶点之间的像素形成过程 着色：沿着顶点之间改变颜色值。着色器则是图形硬件上执行的单独程序，用来处理顶点和光栅化任务。 纹理贴图：初学可以简单理解为贴到图形上的图片（但纹理并不是图片， 二者不等价）。在GPU上，纹理是快捷有效的。 混合：混合是将不同的颜色混合在一起。##3D图形的常见用途实时3D图形的应用范围包括交互式游戏和模拟数据的可视化显示（供科学、医学或商业应用）；在计算机领域，3D图形的应用几乎没有止境。目前最常见的用途，游戏、AR、VR，都是基于openGL的。3D图形在科学视觉和工程应用中非常流行，物美价廉的3D硬件大量涌现使得这些应用技术空前的流行火爆。Mac OS X以及iOS都是使用openGL对所有窗口和控件进行渲染，从而创建了功能强大，引人入胜的可视化界面。例如设计使用的3D Max， 游戏制作的Unity 3D， Cocos2D底层都是使用了openGL。医学上的影像渲染也是依托于openGL。 ##着色器在实时计算机图形中，最前沿的技术是可编程着色器（Programmable Shading）。图形卡不再是低能的渲染芯片。而是功能强大的高度可编程的渲染计算机。类似CPU的术语GPU应运而生。它代表图形处理单元，特指当今图形卡上的可编程芯片。它们是高度并行，并且具有非常快的速度。同样重要的是， 程序员可以进行重新配置图形卡的工作方式，几乎可以实现任何想要得到的特殊效果。##3D编程的基本原则 并发工具包openGL基于一种底层渲染API，我们不能告诉它“在什么地方绘制”， 而是我们需要自己动手，通过载入三角形，应用必要的变化和正确的纹理、着色器并在必要应用混合模式来组合一个模型。这使得我们能够进行大量的底层控制，与使用高层工具包相比，使用openGL这样的底层API动人之处在于，我们不能仅仅是重现许多标准3D渲染，我们可以创造自己的算法，甚至可以取发现一些新的捷径、性能技巧和艺术视觉技术。 坐标系统在openGL或几乎所有的3D API中创建一个用于绘图窗口时， 必须制定希望使用的坐标系统以及指定的坐标如何映射到实际的屏幕像素。##OpenGL在Mac上的环境搭建###准备资源 CLTools glew libGLTools.a这些资源都可以从网上下载到###配置Xcode的openGL环境 打开Xcode -&gt; macOS -&gt; Cocoa Application 添加OpenGL.framework 和 GLUT.framework 两个系统库 libGLTools.a直接拖到工程的Frameworks文件里面，另外删除文件：AppDelegate.h、AppDelegate.m、main.m、ViewController.h、ViewController.m；创建main.cpp文件 在main.cpp中复制以下代码， 来测试环境是否配置成功： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include &lt;stdio.h&gt;#include &quot;GLTools.h&quot;#include &lt;GLUT/GLUT.h&gt;GLBatch triangleBatch;GLShaderManager shaderManager;//窗口大小改变时接受新的宽度和高度，其中0,0代表窗口中视口的左下角坐标，w，h代表像素void ChangeSize(int w,int h)&#123; glViewport(0,0, w, h); &#125;//为程序作一次性的设置void SetupRC()&#123; //设置背影颜色 glClearColor(0.0f,0.0f,1.0f,1.0f); //初始化着色管理器 shaderManager.InitializeStockShaders(); //设置三角形，其中数组vVert包含所有3个顶点的x,y,笛卡尔坐标对。 GLfloat vVerts[] = &#123; -0.5f,0.0f,0.0f, 0.5f,0.0f,0.0f, 0.0f,0.5f,0.0f, &#125;; //批次处理 triangleBatch.Begin(GL_TRIANGLES,3); triangleBatch.CopyVertexData3f(vVerts); triangleBatch.End(); &#125;//开始渲染void RenderScene(void)&#123; //清除一个或一组特定的缓冲区 glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT|GL_STENCIL_BUFFER_BIT); //设置一组浮点数来表示红色 GLfloat vRed[] = &#123;1.0f,0.0f,0.0f,1.0f&#125;; //传递到存储着色器，即GLT_SHADER_IDENTITY着色器，这个着色器只是使用指定颜色以默认笛卡尔坐标第在屏幕上渲染几何图形 shaderManager.UseStockShader(GLT_SHADER_IDENTITY,vRed); //提交着色器 triangleBatch.Draw(); //将在后台缓冲区进行渲染，然后在结束时交换到前台 glutSwapBuffers(); &#125;int main(int argc,char* argv[])&#123; //设置当前工作目录，针对MAC OS X gltSetWorkingDirectory(argv[0]); //初始化GLUT库 glutInit(&amp;argc, argv); /*初始化双缓冲窗口，其中标志GLUT_DOUBLE、GLUT_RGBA、GLUT_DEPTH、GLUT_STENCIL分别指 双缓冲窗口、RGBA颜色模式、深度测试、模板缓冲区*/ glutInitDisplayMode(GLUT_DOUBLE|GLUT_RGBA|GLUT_DEPTH|GLUT_STENCIL); //GLUT窗口大小，标题窗口 glutInitWindowSize(800,600); glutCreateWindow(&quot;Triangle&quot;); //注册回调函数 glutReshapeFunc(ChangeSize); glutDisplayFunc(RenderScene); //驱动程序的初始化中没有出现任何问题。 GLenum err = glewInit(); if(GLEW_OK != err) &#123; fprintf(stderr,&quot;glew error:%s\n&quot;,glewGetErrorString(err)); return 1; &#125; //调用SetupRC SetupRC(); glutMainLoop(); return 0; &#125; 编译， 将报错的地方文件&lt;&gt;系统引入， 改为“”普通引入##效果图 那么环境搭建到此就成功了。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>opengl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenGL(七)-纹理(上)]]></title>
    <url>%2F2019%2F02%2F20%2FOpenGL(%E4%B8%83)-%E7%BA%B9%E7%90%86(%E4%B8%8A)%2F</url>
    <content type="text"><![CDATA[###设定金字塔坐标 注意纹理坐标的设置方式: //设置顶点对应的纹理坐标 // s , t 相当于 x , y // MultiTexCoord2f(GLuint texture, GLclampf s, GLclampf t); //参数1:纹理的层次 //参数2:s坐标 //参数3:t坐标 pyramidBatch.MultiTexCoord2f(0, 0.0f, 0.0f); ###绘制金字塔纹理 ######1. 顶点/纹理坐标数据设置及图形绘制123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137GLBatch pyramidBatch;//绘制批次类 //1.pyramidBatch //通过三角形批次类pyramidBatch 来组件图形 //参数1:类型 //参数2:顶点数 6 * 3 = 18 //参数3:需要使用到纹理,默认为0,可以不写这个参数 pyramidBatch.Begin(GL_TRIANGLES, 18,1); //2.金字塔各个面的点坐标设置 //金字塔底部 //底部四边形 = 三角形X + 三角形Y //三角形X //----------vBlackLeft------------ //设置法线坐标-光照 pyramidBatch.Normal3f(0.0f, -1.0f, 0.0f); //设置顶点对应的纹理坐标 // MultiTexCoord2f(GLuint texture, GLclampf s, GLclampf t); //参数1:纹理的层次 //参数2:s坐标 //参数3:t坐标 pyramidBatch.MultiTexCoord2f(0, 0.0f, 0.0f); //设置顶点坐标 pyramidBatch.Vertex3f(-1.0f, -1.0f, -1.0f); //------vBackRight------------ pyramidBatch.Normal3f(0.0f, -1.0f, 0.0f); pyramidBatch.MultiTexCoord2f(0, 1.0f, 0.0f); pyramidBatch.Vertex3f(1.0f, -1.0f, -1.0f); //------vFrontRight点------------ pyramidBatch.Normal3f(0.0f, -1.0f, 0.0f); pyramidBatch.MultiTexCoord2f(0, 1.0f, 1.0f); pyramidBatch.Vertex3f(1.0f, -1.0f, 1.0f); //三角形Y pyramidBatch.Normal3f(0.0f, -1.0f, 0.0f); pyramidBatch.MultiTexCoord2f(0, 0.0f, 1.0f); pyramidBatch.Vertex3f(-1.0f, -1.0f, 1.0f); pyramidBatch.Normal3f(0.0f, -1.0f, 0.0f); pyramidBatch.MultiTexCoord2f(0, 0.0f, 0.0f); pyramidBatch.Vertex3f(-1.0f, -1.0f, -1.0f); pyramidBatch.Normal3f(0.0f, -1.0f, 0.0f); pyramidBatch.MultiTexCoord2f(0, 1.0f, 1.0f); pyramidBatch.Vertex3f(1.0f, -1.0f, 1.0f); //塔顶 M3DVector3f vApex = &#123;0.0f,1.0f,0.0f&#125;; M3DVector3f vFrontLeft = &#123;-1.0f,-1.0f,1.0f&#125;; M3DVector3f vFrontRight = &#123;1.0f,-1.0f,1.0f&#125;; M3DVector3f vBackLeft = &#123;-1.0f,-1.0f,-1.0f&#125;; M3DVector3f vBackRight = &#123;1.0f,-1.0f,-1.0f&#125;; //目的:为了临时存储法线向量 M3DVector3f n; //金字塔的前面 //三角形:(Apex,vFrontLeft,vFrontRight) //找法线 //m3dFindNormal(M3DVector3f result, const M3DVector3f point1, const M3DVector3f point2,const M3DVector3f point3); //参数1:结果 //参数2-4:3个顶点 m3dFindNormal(n, vApex, vFrontLeft, vFrontRight); //vApex pyramidBatch.Normal3fv(n); pyramidBatch.MultiTexCoord2f(0, 0.5, 1.0f); pyramidBatch.Vertex3fv(vApex); //vFrontLeft pyramidBatch.Normal3fv(n); pyramidBatch.MultiTexCoord2f(0, 0.0f, 0.0f); pyramidBatch.Vertex3fv(vFrontLeft); //vFrongRight pyramidBatch.Normal3fv(n); pyramidBatch.MultiTexCoord2f(0, 1.0f, 0.0f); pyramidBatch.Vertex3fv(vFrontRight); //金字塔的左边 //三角形:(Apex,vBackLeft,vFrontLeft) m3dFindNormal(n, vApex, vBackLeft, vFrontLeft); //vApex pyramidBatch.Normal3fv(n); pyramidBatch.MultiTexCoord2f(0, 0.5f, 1.0f); pyramidBatch.Vertex3fv(vApex); //vBackLeft pyramidBatch.Normal3fv(n); pyramidBatch.MultiTexCoord2f(0, 1.0f, 0.0f); pyramidBatch.Vertex3fv(vBackLeft); //vFrontLeft pyramidBatch.Normal3fv(n); pyramidBatch.MultiTexCoord2f(0, 0.0f, 0.0f); pyramidBatch.Vertex3fv(vFrontLeft); //金字塔右边 //三角形：（vApex, vFrontRight, vBackRight） m3dFindNormal(n, vApex, vFrontRight, vBackRight); pyramidBatch.Normal3fv(n); pyramidBatch.MultiTexCoord2f(0, 0.5f, 1.0f); pyramidBatch.Vertex3fv(vApex); pyramidBatch.Normal3fv(n); pyramidBatch.MultiTexCoord2f(0, 1.0f, 0.0f); pyramidBatch.Vertex3fv(vFrontRight); pyramidBatch.Normal3fv(n); pyramidBatch.MultiTexCoord2f(0, 0.0f, 0.0f); pyramidBatch.Vertex3fv(vBackRight); //金字塔后边 //三角形：（vApex, vBackRight, vBackLeft） m3dFindNormal(n, vApex, vBackRight, vBackLeft); pyramidBatch.Normal3fv(n); pyramidBatch.MultiTexCoord2f(0, 0.5f, 1.0f); pyramidBatch.Vertex3fv(vApex); pyramidBatch.Normal3fv(n); pyramidBatch.MultiTexCoord2f(0, 0.0f, 0.0f); pyramidBatch.Vertex3fv(vBackRight); pyramidBatch.Normal3fv(n); pyramidBatch.MultiTexCoord2f(0, 1.0f, 0.0f); pyramidBatch.Vertex3fv(vBackLeft); //结束批次设置 pyramidBatch.End(); ######2.加载2D纹理1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980// 将TGA文件加载为2D纹理。//参数1:纹理文件名称//参数2:缩小时过滤器使用的哪一种//参数3:放大小时过滤器使用的哪一种//参数4:纹理坐标环绕方式bool LoadTGATexture(const char *szFileName, GLenum minFilter, GLenum magFilter, GLenum wrapMode)&#123; GLbyte *pBits; int nWidth,nHeight,nComponents; GLenum eFormat; //1.读取纹理的像素 //参数1:纹理文件的名称 //参数2:文件的宽度地址 //参数3:文件的高度地址 //参数4:文件的组件地址 //参数5:文件格式地址 //返回值:pBits ,指向图像数据的指针 pBits = gltReadTGABits(szFileName, &amp;nWidth, &amp;nHeight, &amp;nComponents, &amp;eFormat); if (pBits == NULL) &#123; printf(&quot;读取纹理像素失败\n&quot;); return false; &#125; //2.设置纹理参数 //设置s,t的环绕方式 //glTexParameteri (GLenum target, GLenum pname, GLint param); //参数1:纹理维度 //参数2:为S/T坐标设置环绕模式 //参数3:wrapMode,环绕模式 glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, wrapMode); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, wrapMode); //设置放大\缩小的过滤方式 glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, minFilter); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, magFilter); //3.精密包装像素数据 //glPixelStorei (GLenum pname, GLint param); //参数1:GL_UNPACK_ALIGNMENT ,OpenGL 如何从数据缓存区中解包图像数据 //参数2:设置GL_UNPACK_ALIGNMENT的值 glPixelStorei(GL_UNPACK_ALIGNMENT, 1); //4.载入纹理 //glTexImage2D (GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels); //参数1:纹理的维度 //参数2:mip贴图层次 //参数3:加载纹理颜色成分(从读取像素图获取的) //参数4:加载纹理的宽 //参数5:加载纹理的高 //参数6:纹理的边框 //参数7:像素数据的类型 //参数8:指向纹理数据的指针 //详细可参考PPT glTexImage2D(GL_TEXTURE_2D, 0, nComponents, nWidth, nHeight, 0, eFormat, GL_UNSIGNED_BYTE, pBits); //使用完释放 free(pBits); //只有minFilter 等于以下四种模式，才可以生成Mip贴图 //GL_NEAREST_MIPMAP_NEAREST具有非常好的性能，并且闪烁现象非常弱 //GL_LINEAR_MIPMAP_NEAREST常常用于对游戏进行加速，它使用了高质量的线性过滤器 //GL_LINEAR_MIPMAP_LINEAR 和GL_NEAREST_MIPMAP_LINEAR 过滤器在Mip层之间执行了一些额外的插值，以消除他们之间的过滤痕迹。 //GL_LINEAR_MIPMAP_LINEAR 三线性Mip贴图。纹理过滤的黄金准则，具有最高的精度。 if(minFilter == GL_LINEAR_MIPMAP_LINEAR || minFilter == GL_LINEAR_MIPMAP_NEAREST || minFilter == GL_NEAREST_MIPMAP_LINEAR || minFilter == GL_NEAREST_MIPMAP_NEAREST) //加载Mip,纹理生成所有的Mip层 //参数：GL_TEXTURE_1D、GL_TEXTURE_2D、GL_TEXTURE_3D glGenerateMipmap(GL_TEXTURE_2D); return true;&#125; ######3.SetUp12345678910111213141516171819202122232425262728293031323334353637void SetupRC()&#123; glClearColor(0.7f, 0.7f,0.7f, 1.0f); shaderManager.InitializeStockShaders(); //开启深度测试 glEnable(GL_DEPTH_TEST); //纹理对象的处理 //1.分配纹理对象 // glGenTextures (GLsizei n, GLuint *textures); //参数1:纹理对象的个数 //参数2:纹理对象的指针 glGenTextures(1, &amp;textureID); //2.绑定纹理状态 //glBindTexture (GLenum target, GLuint texture); //参数1:纹理的状态,GL_TEXTURE_1D\GL_TEXTURE_2D\GL_TEXTURE_3D glBindTexture(GL_TEXTURE_2D, textureID); //3.将TGA文件加载成2D纹理 //函数是开发者自己设计的 //参数1:纹理文件名称 //参数2:缩小时过滤器使用的哪一种 //参数3:放大小时过滤器使用的哪一种 //参数4:纹理坐标环绕方式 LoadTGATexture(&quot;brick.tga&quot;, GL_LINEAR, GL_LINEAR, GL_CLAMP_TO_EDGE); //4.设置渲染图像的顶点--金字塔 MakePyramid(pyramidBatch); cameraFrame.MoveForward(-10.0); &#125; ######4.渲染1234567891011121314151617181920212223242526272829303132333435363738394041424344454647void RenderScene(void)&#123; //光照位置 static GLfloat vLightPos[] = &#123;1.0f,1.0f,0.0f&#125;; //关照颜色 static GLfloat vWhite[] = &#123;1.0f,0.0f,0.0f,1.0f&#125;; //glClear(GL_COLOR_BUFFER_BIT| GL_DEPTH_BUFFER|GL_STENCIL_BUFFER_BIT); glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT); modelViewMatrix.PushMatrix(); //观察者 M3DMatrix44f mCamera; cameraFrame.GetCameraMatrix(mCamera); modelViewMatrix.MultMatrix(mCamera); // M3DMatrix44f mObjectFrame; objectFrame.GetMatrix(mObjectFrame); modelViewMatrix.MultMatrix(mObjectFrame); //错误地方!!! //glBindTexture(GL_TEXTURE_2D, 0); glBindTexture(GL_TEXTURE_2D, textureID); //点光源着色器 //参数1:GLT_SHADER_TEXTURE_POINT_LIGHT_DIFF //参数2:模型视图矩阵 //参数3:投影矩阵 //参数4:光源的位置 //参数5:光的颜色 //参数6:图形颜色(如使用了纹理,则设置为0) shaderManager.UseStockShader(GLT_SHADER_TEXTURE_POINT_LIGHT_DIFF,transformPipeline.GetModelViewMatrix(),transformPipeline.GetProjectionMatrix(),vLightPos,vWhite,0); pyramidBatch.Draw(); modelViewMatrix.PopMatrix(); glutSwapBuffers(); &#125; ######效果图]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>opengl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenGL(三)-深度测试]]></title>
    <url>%2F2019%2F02%2F20%2FOpenGL(%E4%B8%89)-%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[##什么叫深度?所谓深度,就是在坐标系中,像素Z坐标距离观察者的距离.观察者可以在任何位置.OpenGL会有专门一块缓存区来存放Z值, 即深度缓冲区. ##深度缓冲区作用?一般情况下,我们绘制图形时,后面绘制的会覆盖前面的图形.这样就会产生一个性能问题:就是遮盖部分,先绘制的会被覆盖,那么这块区域就是无意义的绘制.深度测试就是用来解决这个问题的.它是如何处理的呢?有了深度缓冲区之后,绘制的时候会检查Z值,靠近观察者的不覆盖, 远离观察者的被覆盖,而不是靠绘制顺序来决定. ##如何使用深度缓冲区测试?glEnable(GLDEPTHTEST);开启之后,就会先测试深度值再绘制默认情况下, Z值小的会被覆盖 如果观察者,在Z轴的正方向,Z值大则靠近观察者如果观察者,在Z轴的负方向,Z值小则靠近观察者 ##如何解决深度值相同,造成的冲突问题? 第一种方法:在第二次绘制时, 稍微偏移一点点解决这个问题.注意:必须非常小心确保Z值的间隙.(比如贴在飞机上的五角星会悬浮起来的风险) 第二种方法:采用glPolygonOffset函数,使得可以调节片段的深度值.使深度值偏移而不产生悬浮.]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>opengl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenGL(七)-纹理(下)]]></title>
    <url>%2F2019%2F02%2F20%2FOpenGL(%E4%B8%83)-%E7%BA%B9%E7%90%86(%E4%B8%8B)%2F</url>
    <content type="text"><![CDATA[##绘制一个隧道 ######定义绘制批次类123456789101112131415161718192021222324GLShaderManager shaderManager; //着色器管理器GLMatrixStack modelViewMatrix; //模型视图矩阵GLMatrixStack projectionMatrix; //投影矩阵GLFrustum viewFrustum; //视景体GLGeometryTransform transformPipeline; //几何变换管线//4个批次容器类GLBatch floorBatch;//地面GLBatch ceilingBatch;//天花板GLBatch leftWallBatch;//左墙面GLBatch rightWallBatch;//右墙面//深度初始值，-65。GLfloat viewZ = -65.0f;// 纹理标识符号#define TEXTURE_BRICK 0 //墙面#define TEXTURE_FLOOR 1 //地板#define TEXTURE_CEILING 2 //纹理天花板#define TEXTURE_COUNT 3 //纹理个数GLuint textures[TEXTURE_COUNT];//纹理标记数组//文件tag名字数组const char *szTextureFiles[TEXTURE_COUNT] = &#123; &quot;brick.tga&quot;, &quot;floor.tga&quot;, &quot;ceiling.tga&quot; &#125;; ######初始化 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176//在这个函数里能够在渲染环境中进行任何需要的初始化，它这里的设置并初始化纹理对象void SetupRC()&#123; GLbyte *pBytes; GLint iWidth,iHeight,iComponents; GLenum eFormat; GLint iLoop; //背景 glClearColor(0.0f, 0.0f, 0.0f,1.0f); shaderManager.InitializeStockShaders(); //1.加载纹理 /* glGenTextures (GLsizei n, GLuint *textures) 参数1:n,纹理数量 参数2:textures,纹理对象标识数组 */ glGenTextures(TEXTURE_COUNT, textures); for (iLoop =0; iLoop &lt; TEXTURE_COUNT; iLoop++) &#123; //2.绑定纹理 /* glBindTexture (GLenum target, GLuint texture); 参数1:target,使用的纹理类型GL_TEXTURE_1D\GL_TEXTURE_2D\GL_TEXTURE_3D 参数2:texture,纹理的标记 */ glBindTexture(GL_TEXTURE_2D, textures[iLoop]); //3.加载tga文件 /* GLbyte *gltReadTGABits(const char *szFileName, GLint *iWidth, GLint *iHeight, GLint *iComponents, GLenum *eFormat, GLbyte *pData); 参数1:szFileName 纹理文件的名称 参数2:iWidth 获取纹理文件的宽度 参数3:iHeight获取纹理文件的高度 参数4:iComponents获取纹理文件的组件 参数5:eFormat获取纹理文件的格式 返回值:指向图像数据的指针 */ pBytes = gltReadTGABits(szTextureFiles[iLoop], &amp;iWidth, &amp;iHeight, &amp;iComponents, &amp;eFormat); //放大过滤器 glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST); //缩小过滤器 glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST); //环绕方式--S glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE); //环绕方式--T glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE); //载入纹理 /* glTexImage2D (GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels); 参数1:target,使用的纹理类型GL_TEXTURE_1D\GL_TEXTURE_2D\GL_TEXTURE_3D 参数2:level ,Mip贴图的层次 参数3:internalformat,纹理单元的颜色组成方式(从读取像素图中获得) 参数4:width 参数5:height 参数6:border 参数7:format 参数8:type,像素数据的数据类型-GL_UNSIGNED_BYTE 参数9:pixels,指向纹理图像数据的指针 */ glTexImage2D(GL_TEXTURE_2D, 0, iComponents, iWidth, iHeight, 0, eFormat, GL_UNSIGNED_BYTE, pBytes); //生成MIP图层 /* 参数1:GL_TEXTURE_1D\GL_TEXTURE_2D\GL_TEXTURE_3D */ glGenerateMipmap(GL_TEXTURE_2D); free(pBytes); &#125; //建立立体图像!!! GLfloat z; /* void Begin(GLenum primitive, GLuint nVerts, GLuint nTextureUnits = 0); 参数1:绘图模式 参数2:顶点个数 参数3:纹理,默认等于0 */ floorBatch.Begin(GL_TRIANGLE_STRIP, 28,1);//共绘制了7个四边形, 共28个顶点 //参考图 - floor.png for (z = 60.0f; z &gt;= 0.0f; z -= 10.0f) &#123; //指定顶点对应纹理的坐标 floorBatch.MultiTexCoord2f(0, 0, 0); //指定左下角顶点 floorBatch.Vertex3f(-10.0f, -10.0f, z); //指定右下角顶点以及纹理坐标 floorBatch.MultiTexCoord2f(0, 1, 0); floorBatch.Vertex3f(10.0f, -10.0f, z); //指定顶点对应纹理的坐标 floorBatch.MultiTexCoord2f(0, 0, 1.0f); floorBatch.Vertex3f(-10.0f, -10.0f, z-10.0f); //指定顶点对应纹理的坐标 floorBatch.MultiTexCoord2f(0, 1.0f, 1.0f); floorBatch.Vertex3f(10.0f, -10.0f, z-10.0f); &#125; floorBatch.End(); //参考图- ceiling.png ceilingBatch.Begin(GL_TRIANGLE_STRIP, 28, 1); for(z = 60.0f; z &gt;= 0.0f; z -=10.0f) &#123; ceilingBatch.MultiTexCoord2f(0, 0.0f, 1.0f); ceilingBatch.Vertex3f(-10.0f, 10.0f, z - 10.0f); ceilingBatch.MultiTexCoord2f(0, 1.0f, 1.0f); ceilingBatch.Vertex3f(10.0f, 10.0f, z - 10.0f); ceilingBatch.MultiTexCoord2f(0, 0.0f, 0.0f); ceilingBatch.Vertex3f(-10.0f, 10.0f, z); ceilingBatch.MultiTexCoord2f(0, 1.0f, 0.0f); ceilingBatch.Vertex3f(10.0f, 10.0f, z); &#125; ceilingBatch.End(); //参考图 - leftWall.png leftWallBatch.Begin(GL_TRIANGLE_STRIP, 28, 1); for(z = 60.0f; z &gt;= 0.0f; z -=10.0f) &#123; leftWallBatch.MultiTexCoord2f(0, 0.0f, 0.0f); leftWallBatch.Vertex3f(-10.0f, -10.0f, z); leftWallBatch.MultiTexCoord2f(0, 0.0f, 1.0f); leftWallBatch.Vertex3f(-10.0f, 10.0f, z); leftWallBatch.MultiTexCoord2f(0, 1.0f, 0.0f); leftWallBatch.Vertex3f(-10.0f, -10.0f, z - 10.0f); leftWallBatch.MultiTexCoord2f(0, 1.0f, 1.0f); leftWallBatch.Vertex3f(-10.0f, 10.0f, z - 10.0f); &#125; leftWallBatch.End(); //参考图 - rightWall.png rightWallBatch.Begin(GL_TRIANGLE_STRIP, 28, 1); for(z = 60.0f; z &gt;= 0.0f; z -=10.0f) &#123; rightWallBatch.MultiTexCoord2f(0, 0.0f, 0.0f); rightWallBatch.Vertex3f(10.0f, -10.0f, z); rightWallBatch.MultiTexCoord2f(0, 0.0f, 1.0f); rightWallBatch.Vertex3f(10.0f, 10.0f, z); rightWallBatch.MultiTexCoord2f(0, 1.0f, 0.0f); rightWallBatch.Vertex3f(10.0f, -10.0f, z - 10.0f); rightWallBatch.MultiTexCoord2f(0, 1.0f, 1.0f); rightWallBatch.Vertex3f(10.0f, 10.0f, z - 10.0f); &#125; rightWallBatch.End();&#125; ######窗口设置123456789101112131415161718192021222324//改变视景体和视口，在改变窗口大小或初始化窗口调用void ChangeSize(int w, int h)&#123; if (h == 0) &#123; h = 1; &#125; glViewport(0, 0, w, h); //透视投影纵横比 GLfloat fAspect; fAspect = (GLfloat)w / (GLfloat)h; //设置透视投影 viewFrustum.SetPerspective(80.0f, fAspect, 1.0, 120.0); //获取到投影矩阵 projectionMatrix.LoadMatrix(viewFrustum.GetProjectionMatrix()); //通过变换管线来管理投影矩阵堆栈 transformPipeline.SetMatrixStacks(modelViewMatrix, projectionMatrix); &#125; ######调用，绘制场景123456789101112131415161718192021222324252627282930313233343536void RenderScene(void)&#123; glClear(GL_COLOR_BUFFER_BIT); modelViewMatrix.PushMatrix(); modelViewMatrix.Translate(0.0f, 0.0f, viewZ); //纹理替换矩阵着色器 /* 参数1:GLT_SHADER_TEXTURE_REPLACE 参数2:模型视图矩阵 &amp; 投影矩阵 参数3:纹理层次 */ shaderManager.UseStockShader(GLT_SHADER_TEXTURE_REPLACE,transformPipeline.GetModelViewProjectionMatrix(),0); //地板 glBindTexture(GL_TEXTURE_2D, textures[TEXTURE_FLOOR]); floorBatch.Draw(); //天花板 glBindTexture(GL_TEXTURE_2D, textures[TEXTURE_CEILING]); ceilingBatch.Draw(); //左右墙壁 glBindTexture(GL_TEXTURE_2D, textures[TEXTURE_BRICK]); leftWallBatch.Draw(); rightWallBatch.Draw(); modelViewMatrix.PopMatrix(); glutSwapBuffers(); &#125; ######效果图]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>opengl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenGL(五)-矩阵变换]]></title>
    <url>%2F2019%2F02%2F20%2FOpenGL(%E4%BA%94)-%E7%9F%A9%E9%98%B5%E5%8F%98%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[##关键函数讲解 ###平移123456789101112//创建单元矩阵 M3DMatrix44f m3;m3dLoadIdentity44(m3);/* m3dTranslationMatrix44(M3DMatrix44f m, float x, float y, float z) 参数1:结果矩阵,平移之后的结果矩阵 参数2:沿着X轴移动多少,正数\负数 参数3:沿着Y轴移动多少,正数\负数 参数4:沿着Z轴移动多少,正数\负数 */m3dTranslationMatrix44(m3, 0.0f, 10.0f, 0.0f); ###旋转1234567891011 /* m3dRotationMatrix44(M3DMatrix44f m, float angle, float x, float y, float z); 参数1:结果矩阵,旋转之后的结果矩阵 参数2:旋转多少弧度 参数3:是否围绕X轴旋转,是(1),不是(0) 参数4:是否围绕Y轴旋转,是(1),不是(0) 参数5:是否围绕Z轴旋转,是(1),不是(0) */ m3dRotationMatrix44(m3, m3dDegToRad(45.0f), 1.0f, 0.0f, 0.0f);``` ###缩放 /* void m3dScaleMatrix44(M3DMatrix44f m, float xScale, float yScale, float zScale) 参数1:结果矩阵 参数2:围绕X轴放大\缩小;放大x&gt;1,缩小:0.5f 参数3:围绕Y轴放大\缩小;放大x&gt;1,缩小:0.5f 参数4:围绕Z轴放大\缩小;放大x&gt;1,缩小:0.5f */ m3dScaleMatrix44(m3, 1.0f, 10.0f, 1.0f); 12##案例1 : 利用矩阵的平移、旋转、综合变化等, 实现矩阵的移动. GLBatch squareBatch;GLfloat blockSize = 0.1f;GLfloat vVerts[] = { -blockSize, -blockSize, 0.0f, blockSize, -blockSize, 0.0f, blockSize, blockSize, 0.0f, -blockSize, blockSize, 0.0f}; GLfloat xPos = 0.0f;GLfloat yPos = 0.0f; void SetupRC(){ //背景颜色 glClearColor(0.0f, 0.0f, 1.0f, 1.0f ); shaderManager.InitializeStockShaders(); // 加载矩形 squareBatch.Begin(GL_TRIANGLE_FAN, 4); squareBatch.CopyVertexData3f(vVerts); squareBatch.End(); } //移动（移动只是计算了X,Y移动的距离，以及碰撞检测）void SpecialKeys(int key, int x, int y){ GLfloat stepSize = 0.025f; if(key == GLUT_KEY_UP) yPos += stepSize; if(key == GLUT_KEY_DOWN) yPos -= stepSize; if(key == GLUT_KEY_LEFT) xPos -= stepSize; if(key == GLUT_KEY_RIGHT) xPos += stepSize; // 碰撞检测 if(xPos &lt; (-1.0f + blockSize)) xPos = -1.0f + blockSize; if(xPos &gt; (1.0f - blockSize)) xPos = 1.0f - blockSize; if(yPos &lt; (-1.0f + blockSize)) yPos = -1.0f + blockSize; if(yPos &gt; (1.0f - blockSize)) yPos = 1.0f - blockSize; // 每次操作方向键之后, 重新调用RenderScene进行新的场景渲染 glutPostRedisplay(); } void RenderScene(void){ glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT); GLfloat vRed[] = { 1.0f, 0.0f, 0.0f, 1.0f }; //!!!矩阵变化 - 关键代码!!! M3DMatrix44f mFinalTransform, mTranslationMatrix, mRotationMatrix; //平移 xPos,yPos m3dTranslationMatrix44(mTranslationMatrix, xPos, yPos, 0.0f); // 每次重绘时，旋转5度 static float yRot = 0.0f; yRot += 5.0f; m3dRotationMatrix44(mRotationMatrix, m3dDegToRad(yRot), 0.0f, 0.0f, 1.0f); //将旋转和移动的结果合并到mFinalTransform 中 m3dMatrixMultiply44(mFinalTransform, mTranslationMatrix, mRotationMatrix); //将矩阵结果提交到固定着色器（平面着色器）中。 shaderManager.UseStockShader(GLT_SHADER_FLAT, mFinalTransform, vRed); //!!!矩形重新绘制, 即会出现一个既平移了方向又旋转了角度的新矩形 squareBatch.Draw(); // 执行缓冲区交换 glutSwapBuffers(); } void ChangeSize(int w, int h){ glViewport(0, 0, w, h);} int main(int argc, char* argv[]){ gltSetWorkingDirectory(argv[0]); glutInit(&amp;argc, argv); glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGBA | GLUT_DEPTH); glutInitWindowSize(600, 600); glutCreateWindow(&quot;Move Block with Arrow Keys&quot;); GLenum err = glewInit(); if (GLEW_OK != err) { fprintf(stderr, &quot;Error: %s\n&quot;, glewGetErrorString(err)); return 1; } glutReshapeFunc(ChangeSize);//设置视口大小 glutDisplayFunc(RenderScene);//渲染场景 glutSpecialFunc(SpecialKeys);//键盘方向键操作 SetupRC(); glutMainLoop(); return 0; } 1234567###效果图:注: 本例是键盘的上下左右方向键来控制矩形的旋转平移, 具体代码参见上面![利用矩阵变换实现模型变化.gif](http://upload-images.jianshu.io/upload_images/1352344-c8e919beceac3928.gif?imageMogr2/auto-orient/strip)##案例2 : 利用模型视图矩阵和投影矩阵让一个球体旋转###### 绘制球体 gltMakeSphere(torusBatch, 0.4f, 10, 20); glPolygonMode(GL_FRONT_AND_BACK, GL_LINE); 1###### 设置模型视图矩阵 和 投影矩阵 //建立一个基于时间变化的动画 static CStopWatch rotTimer; //当前时间 * 60s float yRot = rotTimer.GetElapsedSeconds() * 60.0f; glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); //矩阵变量 M3DMatrix44f mTranlate,mRotate,mModelView,mModelViewProjection; //将圆球像Z轴负方向移动2.5个单位长度 m3dTranslationMatrix44(mTranlate, 0.0f , 0.0f,-2.5f); //旋转 m3dRotationMatrix44(mRotate, m3dDegToRad(yRot), 0.0f, 1.0f, 0.0f); //将平移和旋转的矩阵进行叉乘,产生一个新的矩阵mModelView m3dMatrixMultiply44(mModelView, mTranlate, mRotate); //模型视图矩阵 和 投影矩阵 //将投影矩阵 与 模型视图矩阵进行叉乘 ,将变化最终结果通过矩阵叉乘的方式应用到mModelViewProjection中来 m3dMatrixMultiply44(mModelViewProjection, viewFrustum.GetProjectionMatrix(), mModelView); GLfloat vBlack[] = {0.0f,0.0f,0.0f,1.0f}; //平面着色器来渲染图像 shaderManager.UseStockShader(GLT_SHADER_FLAT,mModelViewProjection,vBlack); //开始绘图 torusBatch.Draw(); glutSwapBuffers(); glutPostRedisplay(); ` 效果图]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>opengl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenGL(六)-坐标系统]]></title>
    <url>%2F2019%2F02%2F20%2FOpenGL(%E5%85%AD)-%E5%9D%90%E6%A0%87%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[在OpenGL 中有5种坐标系。1.局部坐标系(物体空间)2.世界空间3.观察空间(视觉空间)4.裁剪空间5.屏幕空间 下图是一个顶点最终转化到片段之前需要经历的所有不同的状态变化: 局部空间： 指的是物体所在的坐标空间，即是建立一个建模软件创建一个模型立方体。创建的立方体的原点可能是[0,0,0]。但它在你的程序里可能处于不同的位置。所以你的模型文件的顶点都以[0,0,0]这个为初始位置。但是他们最终显示在世界坐标系的那个位置不由局部坐标系决定。 你的模型文件所有的顶点都处于局部空间中。 比如我创建一个立体箱子,它的范围和原点都是针对局部坐标的。 世界空间： 如果我们将我们所有的物体导入到程序当中，它们有可能会全挤在世界的原点(0, 0, 0)上，这并不是我们想要的结果。我们想为每一个物体定义一个位置，从而能在更大的世界当中放置它们。世界空间中的坐标正如其名：是指顶点相对于（游戏）世界的坐标。如果你希望将物体分散在世界上摆放（特别是非常真实的那样），这就是你希望物体变换到的空间。物体的坐标将会从局部变换到世界空间；该变换是由模型矩阵(Model Matrix)实现的 模型矩阵是一种变换矩阵，它能通过对物体进行位移、缩放、旋转来将它置于它本应该在的位置或朝向。你可以将它想像为变换一个房子，你需要先将它缩小（它在局部空间中太大了），并将其位移至郊区的一个小镇，然后在y轴上往左旋转一点以搭配附近的房子。你也可以把上一节将箱子到处摆放在场景中用的那个矩阵大致看作一个模型矩阵；我们将箱子的局部坐标变换到场景/世界中的不同位置。 观察空间： 观察空间经常被人们称之OpenGL的摄像机(Camera)（所以有时也称为摄像机空间(Camera Space)或视觉空间(Eye Space)）。观察空间是将世界空间坐标转化为用户视野前方的坐标而产生的结果。因此观察空间就是从摄像机的视角所观察到的空间。而这通常是由一系列的位移和旋转的组合来完成，平移/旋转场景从而使得特定的对象被变换到摄像机的前方。这些组合在一起的变换通常存储在一个观察矩阵(View Matrix)里，它被用来将世界坐标变换到观察空间 裁剪空间： 在一个顶点着色器运行的最后，OpenGL期望所有的坐标都能落在一个特定的范围内，且任何在这个范围之外的点都应该被裁剪掉(Clipped)。被裁剪掉的坐标就会被忽略，所以剩下的坐标就将变为屏幕上可见的片段。这也就是裁剪空间(Clip Space)名字的由来。 因为将所有可见的坐标都指定在-1.0到1.0的范围内不是很直观，所以我们会指定自己的坐标集(Coordinate Set)并将它变换回标准化设备坐标系，就像OpenGL期望的那样。 为了将顶点坐标从观察变换到裁剪空间，我们需要定义一个投影矩阵(Projection Matrix)，它指定了一个范围的坐标，比如在每个维度上的-1000到1000。投影矩阵接着会将在这个指定的范围内的坐标变换为标准化设备坐标的范围(-1.0, 1.0)。所有在范围外的坐标不会被映射到在-1.0到1.0的范围之间，所以会被裁剪掉。在上面这个投影矩阵所指定的范围内，坐标(1250, 500, 750)将是不可见的，这是由于它的x坐标超出了范围，它被转化为一个大于1.0的标准化设备坐标，所以被裁剪掉了。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>opengl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenGL(二)-基本图元绘制]]></title>
    <url>%2F2019%2F02%2F20%2FOpenGL(%E4%BA%8C)-%E5%9F%BA%E6%9C%AC%E5%9B%BE%E5%85%83%E7%BB%98%E5%88%B6%2F</url>
    <content type="text"><![CDATA[OpenGL与着色器在OpenGL 3.0之前，OpenGL包含一个固定功能的管线，它可以在不使用着色器的情况下处理几何与像素数据。从3.1版本开始，固定管线从核心模式去掉。因此现在需要使用着色器来完成工作.我们会使用GLSL,(OpenGL Shading Language，它是在OpenGL 2.0版本发布的)。 语法与“C、C++”类似。 ##基础图形管线OpenGL中的图元只不过是顶点的集合以预定义的方式结合在一起。管线分为:2个部分，上半部分是 客户机端，下半部分是服务器端。服务器 和 客户端 在功能和运行上都是异步的。它们是各自独立的软件块或硬件块。 三种向OpenGL 着色器传递渲染数据的方法: 属性: 就是对一个顶点都要作改变的数据元素。实际上，顶点位置本身就是一个属性。属性可以是浮点类型、整型、布尔类型. Uniform: 通过设置Uniform 变量发送一个图元批次命令。Uniform 变量实际上可以无限次限制地使用，比如设置一个应用于整个表面的单个颜色值。还可以设置一个时间值 纹理 基本图元类型 注意着重区分以下三种绘制方式的区别 ###存储着色器的使用着色器有以下分类：• 单位着色器• 平面着色器• 上色着色器• 默认光源着色器• 点光源着色器• 纹理替换矩阵• 纹理调整着色器 • 纹理光源着色器123456//定义着色器GLShaderMananger shaderManager;//初始化着色器 shaderManager.InitalizeStockShaders()//使用shaderManager userStockManager(参数列表) #####单位着色器 GLShaderManager::UserStockShader(GLT_ATTRIBUTE_VERTEX,GLfloat vColor[4]); #####平面着色器 GLShaderManager::UserStockShader(GLT_SHADER_FLAT,GLfloat mvp[16],GLfloat vColor[4]); #####上色着色器 GLShaderManager::UserStockShader(GLT_SHADER_SHADED,GLfloat mvp[16]); #####默认光源着色器 GLShaderManager::UserStockShader(GLT_SHADER_DEFAULT_LIGHT,GLfloat mvMatrix[16],GLfloat pMatrix[16],GLfloat vColor[4]); #####点光源着色器 GLShaderManager::UserStockShader(GLT_SHADER_DEFAULT_LIGHT_DIEF,GLfloat mvMatrix[16],GLfloat pMatrix[16],GLfloat vLightPos[3],GLfloat vColor[4]); #####纹理替换矩阵着色器 GLShaderManager::UserStockShader(GLT_SHADER_TEXTURE_REPLACE,GLfloat mvMatrix[16],GLint nTextureUnit); #####纹理调整着色器 GLShaderManager::UserStockShader(GLT_SHADER_TEXTURE_MODULATE,GLfloat mvMatrix[16],GLfloat vColor[4],GLint nTextureUnit); #####纹理光源着色器 GLShaderManager::UserStockShader(GLT_SHADER_TEXTURE_POINT_LIGHT_DIEF,GLfloat mvMatrix[16],GLfloat pMatrix[16],GLfloat vLightPos[3],GLfloat vBaseColor[4],GLint nTextureUnit); ###绘制不同类型的图元123456789101112131415161718192021// 各种需要的类GLShaderManager shaderManager;GLMatrixStack modelViewMatrix;GLMatrixStack projectionMatrix;GLFrame cameraFrame;GLFrame objectFrame;//投影矩阵GLFrustum viewFrustum;//容器类（7种不同的图元对应7种容器对象）GLBatch pointBatch;GLBatch lineBatch;GLBatch lineStripBatch;GLBatch lineLoopBatch;GLBatch triangleBatch;GLBatch triangleStripBatch;GLBatch triangleFanBatch;//几何变换的管道GLGeometryTransform transformPipeline;M3DMatrix44f shadowMatrix; ######点/线/线段/线环绘制12345678910111213141516171819202122232425262728293031323334// 准备一些随机点数据 GLfloat vCoast[24][3] = &#123; &#123;2.80, 1.20, 0.0 &#125;, &#123;2.0, 1.20, 0.0 &#125;, &#123;2.0, 1.08, 0.0 &#125;, &#123;2.0, 1.08, 0.0 &#125;, &#123;0.0, 0.80, 0.0 &#125;, &#123;-.32, 0.40, 0.0 &#125;, &#123;-.48, 0.2, 0.0 &#125;, &#123;-.40, 0.0, 0.0 &#125;, &#123;-.60, -.40, 0.0 &#125;, &#123;-.80, -.80, 0.0 &#125;, &#123;-.80, -1.4, 0.0 &#125;, &#123;-.40, -1.60, 0.0 &#125;, &#123;0.0, -1.20, 0.0 &#125;, &#123; .2, -.80, 0.0 &#125;, &#123;.48, -.40, 0.0 &#125;, &#123;.52, -.20, 0.0 &#125;, &#123;.48, .20, 0.0 &#125;, &#123;.80, .40, 0.0 &#125;, &#123;1.20, .80, 0.0 &#125;, &#123;1.60, .60, 0.0 &#125;, &#123;2.0, .60, 0.0 &#125;, &#123;2.2, .80, 0.0 &#125;, &#123;2.40, 1.0, 0.0 &#125;, &#123;2.80, 1.0, 0.0 &#125;&#125;; //用点的形式绘制(GL_POINTS) pointBatch.Begin(GL_POINTS, 24); pointBatch.CopyVertexData3f(vCoast); pointBatch.End(); //通过线的形式绘制(GL_LINES) lineBatch.Begin(GL_LINES, 24); lineBatch.CopyVertexData3f(vCoast); lineBatch.End(); //通过线段的形式绘制(GL_LINE_STRIP) lineStripBatch.Begin(GL_LINE_STRIP, 24); lineStripBatch.CopyVertexData3f(vCoast); lineStripBatch.End(); //通过线环的形式绘制(GL_LINE_LOOP) lineLoopBatch.Begin(GL_LINE_LOOP, 24); lineLoopBatch.CopyVertexData3f(vCoast); lineLoopBatch.End(); 效果如下: ######三角形绘制方式 - GL_TRIANGLES123456789101112131415161718192021222324252627 //通过三角形绘制(GL_TRIANGLES) -- 生成一个金字塔的形状 GLfloat vPyramid[12][3] = &#123; -2.0f, 0.0f, -2.0f, 2.0f, 0.0f, -2.0f, 0.0f, 4.0f, 0.0f, 2.0f, 0.0f, -2.0f, 2.0f, 0.0f, 2.0f, 0.0f, 4.0f, 0.0f, 2.0f, 0.0f, 2.0f, -2.0f, 0.0f, 2.0f, 0.0f, 4.0f, 0.0f, -2.0f, 0.0f, 2.0f, -2.0f, 0.0f, -2.0f, 0.0f, 4.0f, 0.0f&#125;; //GL_TRIANGLES 每3个顶点定义一个新的三角形 triangleBatch.Begin(GL_TRIANGLES, 12); triangleBatch.CopyVertexData3f(vPyramid); triangleBatch.End();``` * 效果图:![GL_TRIANGLES.png](http://upload-images.jianshu.io/upload_images/1352344-a577c287b2f55072.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)######三角形扇绘制方式 - GL_TRIANGLE_FAN // 三角形扇绘制(GL_TRIANGLE_FAN) -- 生成一个六边形 GLfloat vPoints[100][3]; //超过我们需要的数组 int nVerts = 0; //半径 GLfloat r = 3.0f; //原点(x,y,z) = (0,0,0); vPoints[nVerts][0] = 0.0f; vPoints[nVerts][1] = 0.0f; vPoints[nVerts][2] = 0.0f; //M3D_2PI 就是2Pi 的意思，就一个圆的意思。 绘制圆形 for(GLfloat angle = 0; angle &lt; M3D_2PI; angle += M3D_2PI / 6.0f) { //数组下标自增（每自增1次就表示一个顶点） nVerts++; /* 弧长=半径*角度,这里的角度是弧度制,不是平时的角度制 既然知道了cos值,那么角度=arccos,求一个反三角函数就行了 */ //x点坐标 cos(angle) * 半径 vPoints[nVerts][0] = float(cos(angle)) * r; //y点坐标 sin(angle) * 半径 vPoints[nVerts][1] = float(sin(angle)) * r; //z点的坐标 vPoints[nVerts][2] = -0.5f; } // 结束扇形 : 前面一共绘制7个顶点（包括圆心） printf(&quot;三角形扇形顶点数:%d\n&quot;,nVerts); //添加闭合的终点, 若不添加, 则三角形扇形是无法闭合的。 nVerts++; vPoints[nVerts][0] = r; vPoints[nVerts][1] = 0; vPoints[nVerts][2] = 0.0f; //GL_TRIANGLE_FAN 以一个圆心为中心呈扇形排列，共用相邻顶点的一组三角形 triangleFanBatch.Begin(GL_TRIANGLE_FAN, 8); triangleFanBatch.CopyVertexData3f(vPoints); triangleFanBatch.End(); 1234* 效果图:![GL_TRIANGLE_FAN.png](http://upload-images.jianshu.io/upload_images/1352344-ec20836c62236f9b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)######三角形条带绘制方式 - GL_TRIANGLE_STRIP //三角形条带绘制(GL_TRIANGLE_STRIP) -- 生成一个小环或圆柱段 //顶点下标 int iCounter = 0; //半径 GLfloat radius = 3.0f; //从0度~360度，以0.3弧度为步长 for(GLfloat angle = 0.0f; angle &lt;= (2.0f*M3D_PI); angle += 0.3f) { //或许圆形的顶点的X,Y GLfloat x = radius * sin(angle); GLfloat y = radius * cos(angle); //绘制2个三角形（他们的x,y顶点一样，只是z点不一样） vPoints[iCounter][0] = x; vPoints[iCounter][1] = y; vPoints[iCounter][2] = -0.5; iCounter++; vPoints[iCounter][0] = x; vPoints[iCounter][1] = y; vPoints[iCounter][2] = 0.5; iCounter++; } // 关闭循环 printf(&quot;三角形带的顶点数：%d\n&quot;,iCounter); //结束循环，在循环位置生成2个三角形 vPoints[iCounter][0] = vPoints[0][0]; vPoints[iCounter][1] = vPoints[0][1]; vPoints[iCounter][2] = -0.5; iCounter++; vPoints[iCounter][0] = vPoints[1][0]; vPoints[iCounter][1] = vPoints[1][1]; vPoints[iCounter][2] = 0.5; iCounter++; // GL_TRIANGLE_STRIP 共用一个条带（strip）上的顶点的一组三角形 triangleStripBatch.Begin(GL_TRIANGLE_STRIP, iCounter); triangleStripBatch.CopyVertexData3f(vPoints); triangleStripBatch.End(); ` 效果图:]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>opengl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenGL(四)-两种方式实现抗锯齿效果]]></title>
    <url>%2F2019%2F02%2F20%2FOpenGL(%E5%9B%9B)-%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E6%8A%97%E9%94%AF%E9%BD%BF%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[##方式一 : 利用混合(GLBlend)实现抗锯齿核心代码如下:12345678910111213141516171819202122232425262728293031323334// 选择菜单void ProcessMenu(int value)&#123; switch (value) &#123; case 1: //打开抗锯齿功能 //1.开启混合功能 glEnable(GL_BLEND); //2.指定混合因子 //注意:如果你修改了混合方程式,当你使用混合抗锯齿功能时,请一定要改为默认混合方程式 glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); //3.开启对点\线\多边形的抗锯齿功能 glEnable(GL_POINT_SMOOTH); glEnable(GL_LINE_SMOOTH); glEnable(GL_POLYGON_SMOOTH); break; case 2: //关闭抗锯齿功能 glDisable(GL_BLEND); glDisable(GL_LINE_SMOOTH); glDisable(GL_POINT_SMOOTH); glDisable(GL_POLYGON_SMOOTH); break; default: break; &#125; glutPostRedisplay();&#125; ##方式二 : 利用多重采样实现抗锯齿12345678//用多重采样来解决锯齿问题.可选 glEnable(GLUT_MULTISAMPLE); //绘制 moonBatch.Draw(); //绘制完成,则关闭 glDisable(GLUT_MULTISAMPLE); ##效果图: 关闭抗锯齿: 打开抗锯齿:]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>opengl</tag>
      </tags>
  </entry>
</search>
