{"meta":{"title":"Sober's Notes","subtitle":null,"description":"GET SOBER. STAY SOBER.","author":"Sober","url":"http://yoursite.com"},"pages":[{"title":"文章分类","date":"2019-02-20T10:16:44.000Z","updated":"2019-02-20T10:22:15.194Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-02-20T10:25:04.000Z","updated":"2019-02-21T03:15:45.212Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"关于","date":"2019-02-21T03:07:53.000Z","updated":"2019-02-21T03:17:54.815Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"一只iOS小菜鸟, 有问题欢迎骚扰. QQ: 2272117761Email: 2272117761@qq.com"}],"posts":[{"title":"Hexo搭建Github-Pages博客记录","slug":"Hexo搭建Github-Pages博客记录","date":"2019-02-22T07:00:37.000Z","updated":"2019-02-22T07:16:31.023Z","comments":true,"path":"2019/02/22/Hexo搭建Github-Pages博客记录/","link":"","permalink":"http://yoursite.com/2019/02/22/Hexo搭建Github-Pages博客记录/","excerpt":"一直都很想搭一个自己的博客, 但一直很忙(其实是懒)没弄, 最近终于搭建好了, 过程中也遇到了一些问题, 写个流水账记录下.","text":"一直都很想搭一个自己的博客, 但一直很忙(其实是懒)没弄, 最近终于搭建好了, 过程中也遇到了一些问题, 写个流水账记录下. 准备工作 一个github账号 安装了node.js, npm, git (mac用户的安装xcode就已经装好git了) 搭建github博客创建仓库新建一个用户名.github.io的仓库, 用户名必须为你的github用户名. 比如我的用户名为soober, 那么需要创建sooober.github.io的仓库. 配置SSH key提交代码需要拥有你的github权限, 使用ssh key来解决本地和服务器的连接问题 用git bash(mac用户, 用终端即可)执行如下命令：1cd ~/. ssh 1ssh-keygen -t rsa -C &quot;邮件地址&quot; 一路回车(密码可以不用输入,直接回车)最终会生成一个文件在用户目录下，找到.ssh\\id_rsa.pub文件，复制里面的内容，打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key, 将复制的内容粘贴到key那里，title自己写一个，保存。 测试SSH配置是否成功1$ ssh -T git@github.com 如果看到以下信息,说明配置成功 Hexo框架搭建Hexo是一个简单、快速、强大的基于 Github Pages 的博客发布工具，支持Markdown格式，有众多优秀插件和主题。由于github pages存放的都是静态文件，博客存放的不只是文章内容，还有文章列表、分类、标签、翻页等动态内容，假如每次写完一篇文章都要手动更新博文目录和相关链接信息，相信谁都会疯掉，所以hexo所做的就是将这些md文件都放在本地，每次写完文章后调用写好的命令来批量完成相关页面的生成，然后再将有改动的页面提交到github。[官网] (http://hexo.io)[github] (https://github.com/hexojs/hexo) 安装1$ npm install -g hexo 初始化选择博客存储位置, 创建hexo文件夹,然后初始化12$ cd hexo$ hexo init hexo会自动下载一些文件到这个目录，包括node_modules，目录结构如下图：其中, _config.yml这里面都是一些全局配置，每个参数的意思都比较简单明了，就不作详细介绍了。需要特别注意的地方是，冒号后面必须有一个空格，否则可能会出问题。 接着生成和启动hexo服务12$ hexo g # 生成$ hexo s # 启动服务 执行以上命令之后，hexo就会在public文件夹生成相关html文件，这些文件将来都是要提交到github去的： hexo s是开启本地预览服务，打开浏览器访问 http://localhost:4000 即可看到博客预览内容(使用ctrl+c结束本地预览) 主题设置一个好看的主题可以让你的博客看上去赏心悦目, 我选择用了Next主题, 你可以再这里选择你喜欢的主题样式 首先下载这个主题：12$ cd your-hexo-site$ git clone https://github.com/iissnan/hexo-theme-next themes/next 下载后的主题都在hexo/themes下存放 接着修改hexo根目录_config.yml中的theme: landscape改为theme: next，如下, 然后重新执行hexo g来重新生成。123456# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/# theme: landscape# theme: yiliatheme: next 如果出现一些莫名其妙的问题，可以先执行hexo clean来清理一下public的内容，然后再重新生成。 初始化本地git仓库如果你的本地仓库还没有进行远程仓库管理,需要进行以下步骤设置Git的user name和email：12$ git config --global user.name // 你的github用户名，非昵称$ git config --global user.email // 填写你的github注册邮箱 在本地的hexo init生成的文件夹中初始化git仓库：1$ git init 将本地仓库和远程仓库连接(这一步貌似可以不做):1$ git remote add origin git@github.com:your_github_user_name/your_github_user_name.github.io.git(远程仓库ssh地址) 做完以上这些步骤，说明你的仓库可以使用ssh方式来上传下载代码，而不需要输入用户名和密码了 网站部署首先, 配置hexo根目录_config.yml中有关deploy的部分：123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: git@github.com:soober/soober.github.io.git branch: master 接着, 安装插件1npm install hexo-deployer-git --save 然后执行发布命令123$ hexo clean //清除缓存文件db.json和已生成的静态文件public$ hexo g //生成网站静态文件到默认设置的public文件夹$ hexo d //部署网站到设定的仓库 执行这个命令可能会碰到一些问题, 终端里会直接给出修改建议, 我是按照给出的参考命令执行的, 具体问题忘记截图了=-= 此时你的博客就部署到了page上了, 打开你的用户名.github.io, 即可看到你发布到github的博客了 常用hexo命令常见命令1234567hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）hexo deploy #部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本 缩写1234hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy 组合命令12hexo s -g #生成并本地预览hexo d -g #生成并上传 绑定域名 不想绑定域名的可以跳过这一步骤. 想绑定域名还没有域名的, 可以去阿里或者腾讯注册一个域名, 我是在腾讯买的一个.com域名. 传送门-腾讯云 有个域名之后, 进行域名解析.域名解析配置最常见有2种方式，CNAME和A记录，其中CNAME填写域名，A记录填写IP. 获取ip需要你去ping一下你的用户名.github.io (腾讯的需要进行个人身份认证之后才能正常访问域名) 设置CNAME 在 hexo 项目下，source 文件夹下面创建 CNAME 文件（没有后缀名的），在里面写上购买的域名然后在 github 上面，打开 username.github.io 项目的（Settings）设置，然后在 GitHub Pages的 Custom domain设置里填上购买的域名。比如：好了,新域名配置完成，可以访问了 一些报错处理 ERROR Plugin load failed: hexo-server原因：Besides, utilities are separated into a standalone module. hexo.util is not reachable anymore.解决方法，执行命令： 1sudo npm install hexo-server 有关-ejs, -stylus, -marked的一些错误提示解决办法, 执行命令: 1234567npm install hexo-renderer-ejs --savenpm install hexo-renderer-stylus --savenpm install hexo-renderer-marked --save//这个时候再重新生成静态文件，命令：hexo generate （或hexo g）//启动本地服务器：hexo server （或hexo s） 参考http://blog.haoji.me","categories":[{"name":"利器","slug":"利器","permalink":"http://yoursite.com/categories/利器/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"next","slug":"next","permalink":"http://yoursite.com/tags/next/"}]},{"title":"Git基本操作","slug":"Git基本操作","date":"2019-02-21T12:38:37.000Z","updated":"2019-02-21T10:46:29.612Z","comments":true,"path":"2019/02/21/Git基本操作/","link":"","permalink":"http://yoursite.com/2019/02/21/Git基本操作/","excerpt":"(一) 从远程仓库克隆(拉取)项目到本地$ git clone [remote_url] 成功执行后, 本地就已经有配置好git的远程项目了(项目路径默认为终端当前所在路径, 可以通过pwd查看当前路径, 并通过cd调整你想让项目存放的路径)","text":"(一) 从远程仓库克隆(拉取)项目到本地$ git clone [remote_url] 成功执行后, 本地就已经有配置好git的远程项目了(项目路径默认为终端当前所在路径, 可以通过pwd查看当前路径, 并通过cd调整你想让项目存放的路径) (二)为本地项目添加远程库 创建本地版本库$ git init 通过git init命令把本地项目目录变成Git可以管理的仓库 关联远程仓库$ git remote add origin [remote_url]若操作过程中出现问题,想删除关联远程仓库,可使用:$ git remote remove origin 把本地库的内容推送到远程$ git add .$ git commit -m &quot;the first commit project&quot;$ git push -u origin master 把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。 由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。 若远程仓库有些初始文件(如readme, .gitignore), 则需要在push前先使用命令git pull origin master同步代码 推送成功后，可以立刻在远程仓库页面中看到远程库的内容已经和本地一模一样了. 若过程中出现错误, 解决参照传送门 若.gitignore文件未生效, 解决参照传送门 (三)代码的更新与提交更新取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch] 提交$ cd projectname //转到项目文件夹下$ git add . //追踪新文件,并放到暂存区$ git commit -m &quot;update message&quot; //将文件纳入本地仓库$ git push // 将本地仓库同步到远程仓库 刷新远程仓库页面, 可以发现代码已经上传到远程仓库了","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/categories/学习笔记/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}]},{"title":"OpenGL(七)-纹理(下)","slug":"OpenGL(七)-纹理(下)","date":"2019-02-19T16:38:43.000Z","updated":"2019-02-21T10:04:12.856Z","comments":true,"path":"2019/02/20/OpenGL(七)-纹理(下)/","link":"","permalink":"http://yoursite.com/2019/02/20/OpenGL(七)-纹理(下)/","excerpt":"绘制一个隧道","text":"绘制一个隧道 定义绘制批次类123456789101112131415161718192021222324GLShaderManager shaderManager; //着色器管理器GLMatrixStack modelViewMatrix; //模型视图矩阵GLMatrixStack projectionMatrix; //投影矩阵GLFrustum viewFrustum; //视景体GLGeometryTransform transformPipeline; //几何变换管线//4个批次容器类GLBatch floorBatch;//地面GLBatch ceilingBatch;//天花板GLBatch leftWallBatch;//左墙面GLBatch rightWallBatch;//右墙面//深度初始值，-65。GLfloat viewZ = -65.0f;// 纹理标识符号#define TEXTURE_BRICK 0 //墙面#define TEXTURE_FLOOR 1 //地板#define TEXTURE_CEILING 2 //纹理天花板#define TEXTURE_COUNT 3 //纹理个数GLuint textures[TEXTURE_COUNT];//纹理标记数组//文件tag名字数组const char *szTextureFiles[TEXTURE_COUNT] = &#123; \"brick.tga\", \"floor.tga\", \"ceiling.tga\" &#125;; 初始化 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176//在这个函数里能够在渲染环境中进行任何需要的初始化，它这里的设置并初始化纹理对象void SetupRC()&#123; GLbyte *pBytes; GLint iWidth,iHeight,iComponents; GLenum eFormat; GLint iLoop; //背景 glClearColor(0.0f, 0.0f, 0.0f,1.0f); shaderManager.InitializeStockShaders(); //1.加载纹理 /* glGenTextures (GLsizei n, GLuint *textures) 参数1:n,纹理数量 参数2:textures,纹理对象标识数组 */ glGenTextures(TEXTURE_COUNT, textures); for (iLoop =0; iLoop &lt; TEXTURE_COUNT; iLoop++) &#123; //2.绑定纹理 /* glBindTexture (GLenum target, GLuint texture); 参数1:target,使用的纹理类型GL_TEXTURE_1D\\GL_TEXTURE_2D\\GL_TEXTURE_3D 参数2:texture,纹理的标记 */ glBindTexture(GL_TEXTURE_2D, textures[iLoop]); //3.加载tga文件 /* GLbyte *gltReadTGABits(const char *szFileName, GLint *iWidth, GLint *iHeight, GLint *iComponents, GLenum *eFormat, GLbyte *pData); 参数1:szFileName 纹理文件的名称 参数2:iWidth 获取纹理文件的宽度 参数3:iHeight获取纹理文件的高度 参数4:iComponents获取纹理文件的组件 参数5:eFormat获取纹理文件的格式 返回值:指向图像数据的指针 */ pBytes = gltReadTGABits(szTextureFiles[iLoop], &amp;iWidth, &amp;iHeight, &amp;iComponents, &amp;eFormat); //放大过滤器 glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST); //缩小过滤器 glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST); //环绕方式--S glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE); //环绕方式--T glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE); //载入纹理 /* glTexImage2D (GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels); 参数1:target,使用的纹理类型GL_TEXTURE_1D\\GL_TEXTURE_2D\\GL_TEXTURE_3D 参数2:level ,Mip贴图的层次 参数3:internalformat,纹理单元的颜色组成方式(从读取像素图中获得) 参数4:width 参数5:height 参数6:border 参数7:format 参数8:type,像素数据的数据类型-GL_UNSIGNED_BYTE 参数9:pixels,指向纹理图像数据的指针 */ glTexImage2D(GL_TEXTURE_2D, 0, iComponents, iWidth, iHeight, 0, eFormat, GL_UNSIGNED_BYTE, pBytes); //生成MIP图层 /* 参数1:GL_TEXTURE_1D\\GL_TEXTURE_2D\\GL_TEXTURE_3D */ glGenerateMipmap(GL_TEXTURE_2D); free(pBytes); &#125; //建立立体图像!!! GLfloat z; /* void Begin(GLenum primitive, GLuint nVerts, GLuint nTextureUnits = 0); 参数1:绘图模式 参数2:顶点个数 参数3:纹理,默认等于0 */ floorBatch.Begin(GL_TRIANGLE_STRIP, 28,1);//共绘制了7个四边形, 共28个顶点 //参考图 - floor.png for (z = 60.0f; z &gt;= 0.0f; z -= 10.0f) &#123; //指定顶点对应纹理的坐标 floorBatch.MultiTexCoord2f(0, 0, 0); //指定左下角顶点 floorBatch.Vertex3f(-10.0f, -10.0f, z); //指定右下角顶点以及纹理坐标 floorBatch.MultiTexCoord2f(0, 1, 0); floorBatch.Vertex3f(10.0f, -10.0f, z); //指定顶点对应纹理的坐标 floorBatch.MultiTexCoord2f(0, 0, 1.0f); floorBatch.Vertex3f(-10.0f, -10.0f, z-10.0f); //指定顶点对应纹理的坐标 floorBatch.MultiTexCoord2f(0, 1.0f, 1.0f); floorBatch.Vertex3f(10.0f, -10.0f, z-10.0f); &#125; floorBatch.End(); //参考图- ceiling.png ceilingBatch.Begin(GL_TRIANGLE_STRIP, 28, 1); for(z = 60.0f; z &gt;= 0.0f; z -=10.0f) &#123; ceilingBatch.MultiTexCoord2f(0, 0.0f, 1.0f); ceilingBatch.Vertex3f(-10.0f, 10.0f, z - 10.0f); ceilingBatch.MultiTexCoord2f(0, 1.0f, 1.0f); ceilingBatch.Vertex3f(10.0f, 10.0f, z - 10.0f); ceilingBatch.MultiTexCoord2f(0, 0.0f, 0.0f); ceilingBatch.Vertex3f(-10.0f, 10.0f, z); ceilingBatch.MultiTexCoord2f(0, 1.0f, 0.0f); ceilingBatch.Vertex3f(10.0f, 10.0f, z); &#125; ceilingBatch.End(); //参考图 - leftWall.png leftWallBatch.Begin(GL_TRIANGLE_STRIP, 28, 1); for(z = 60.0f; z &gt;= 0.0f; z -=10.0f) &#123; leftWallBatch.MultiTexCoord2f(0, 0.0f, 0.0f); leftWallBatch.Vertex3f(-10.0f, -10.0f, z); leftWallBatch.MultiTexCoord2f(0, 0.0f, 1.0f); leftWallBatch.Vertex3f(-10.0f, 10.0f, z); leftWallBatch.MultiTexCoord2f(0, 1.0f, 0.0f); leftWallBatch.Vertex3f(-10.0f, -10.0f, z - 10.0f); leftWallBatch.MultiTexCoord2f(0, 1.0f, 1.0f); leftWallBatch.Vertex3f(-10.0f, 10.0f, z - 10.0f); &#125; leftWallBatch.End(); //参考图 - rightWall.png rightWallBatch.Begin(GL_TRIANGLE_STRIP, 28, 1); for(z = 60.0f; z &gt;= 0.0f; z -=10.0f) &#123; rightWallBatch.MultiTexCoord2f(0, 0.0f, 0.0f); rightWallBatch.Vertex3f(10.0f, -10.0f, z); rightWallBatch.MultiTexCoord2f(0, 0.0f, 1.0f); rightWallBatch.Vertex3f(10.0f, 10.0f, z); rightWallBatch.MultiTexCoord2f(0, 1.0f, 0.0f); rightWallBatch.Vertex3f(10.0f, -10.0f, z - 10.0f); rightWallBatch.MultiTexCoord2f(0, 1.0f, 1.0f); rightWallBatch.Vertex3f(10.0f, 10.0f, z - 10.0f); &#125; rightWallBatch.End();&#125; 窗口设置123456789101112131415161718192021222324//改变视景体和视口，在改变窗口大小或初始化窗口调用void ChangeSize(int w, int h)&#123; if (h == 0) &#123; h = 1; &#125; glViewport(0, 0, w, h); //透视投影纵横比 GLfloat fAspect; fAspect = (GLfloat)w / (GLfloat)h; //设置透视投影 viewFrustum.SetPerspective(80.0f, fAspect, 1.0, 120.0); //获取到投影矩阵 projectionMatrix.LoadMatrix(viewFrustum.GetProjectionMatrix()); //通过变换管线来管理投影矩阵堆栈 transformPipeline.SetMatrixStacks(modelViewMatrix, projectionMatrix); &#125; 调用，绘制场景123456789101112131415161718192021222324252627282930313233343536void RenderScene(void)&#123; glClear(GL_COLOR_BUFFER_BIT); modelViewMatrix.PushMatrix(); modelViewMatrix.Translate(0.0f, 0.0f, viewZ); //纹理替换矩阵着色器 /* 参数1:GLT_SHADER_TEXTURE_REPLACE 参数2:模型视图矩阵 &amp; 投影矩阵 参数3:纹理层次 */ shaderManager.UseStockShader(GLT_SHADER_TEXTURE_REPLACE,transformPipeline.GetModelViewProjectionMatrix(),0); //地板 glBindTexture(GL_TEXTURE_2D, textures[TEXTURE_FLOOR]); floorBatch.Draw(); //天花板 glBindTexture(GL_TEXTURE_2D, textures[TEXTURE_CEILING]); ceilingBatch.Draw(); //左右墙壁 glBindTexture(GL_TEXTURE_2D, textures[TEXTURE_BRICK]); leftWallBatch.Draw(); rightWallBatch.Draw(); modelViewMatrix.PopMatrix(); glutSwapBuffers(); &#125; 效果图","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/categories/学习笔记/"}],"tags":[{"name":"opengl","slug":"opengl","permalink":"http://yoursite.com/tags/opengl/"}]},{"title":"OpenGL(七)-纹理(上)","slug":"OpenGL(七)-纹理(上)","date":"2019-02-19T16:38:42.000Z","updated":"2019-02-21T10:04:06.817Z","comments":true,"path":"2019/02/20/OpenGL(七)-纹理(上)/","link":"","permalink":"http://yoursite.com/2019/02/20/OpenGL(七)-纹理(上)/","excerpt":"设定金字塔坐标注意纹理坐标的设置方式:1234567//设置顶点对应的纹理坐标// s , t 相当于 x , y// MultiTexCoord2f(GLuint texture, GLclampf s, GLclampf t);//参数1:纹理的层次//参数2:s坐标//参数3:t坐标pyramidBatch.MultiTexCoord2f(0, 0.0f, 0.0f);","text":"设定金字塔坐标注意纹理坐标的设置方式:1234567//设置顶点对应的纹理坐标// s , t 相当于 x , y// MultiTexCoord2f(GLuint texture, GLclampf s, GLclampf t);//参数1:纹理的层次//参数2:s坐标//参数3:t坐标pyramidBatch.MultiTexCoord2f(0, 0.0f, 0.0f); 绘制金字塔纹理1.顶点/纹理坐标数据设置及图形绘制123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137GLBatch pyramidBatch;//绘制批次类 //1.pyramidBatch //通过三角形批次类pyramidBatch 来组件图形 //参数1:类型 //参数2:顶点数 6 * 3 = 18 //参数3:需要使用到纹理,默认为0,可以不写这个参数 pyramidBatch.Begin(GL_TRIANGLES, 18,1); //2.金字塔各个面的点坐标设置 //金字塔底部 //底部四边形 = 三角形X + 三角形Y //三角形X //----------vBlackLeft------------ //设置法线坐标-光照 pyramidBatch.Normal3f(0.0f, -1.0f, 0.0f); //设置顶点对应的纹理坐标 // MultiTexCoord2f(GLuint texture, GLclampf s, GLclampf t); //参数1:纹理的层次 //参数2:s坐标 //参数3:t坐标 pyramidBatch.MultiTexCoord2f(0, 0.0f, 0.0f); //设置顶点坐标 pyramidBatch.Vertex3f(-1.0f, -1.0f, -1.0f); //------vBackRight------------ pyramidBatch.Normal3f(0.0f, -1.0f, 0.0f); pyramidBatch.MultiTexCoord2f(0, 1.0f, 0.0f); pyramidBatch.Vertex3f(1.0f, -1.0f, -1.0f); //------vFrontRight点------------ pyramidBatch.Normal3f(0.0f, -1.0f, 0.0f); pyramidBatch.MultiTexCoord2f(0, 1.0f, 1.0f); pyramidBatch.Vertex3f(1.0f, -1.0f, 1.0f); //三角形Y pyramidBatch.Normal3f(0.0f, -1.0f, 0.0f); pyramidBatch.MultiTexCoord2f(0, 0.0f, 1.0f); pyramidBatch.Vertex3f(-1.0f, -1.0f, 1.0f); pyramidBatch.Normal3f(0.0f, -1.0f, 0.0f); pyramidBatch.MultiTexCoord2f(0, 0.0f, 0.0f); pyramidBatch.Vertex3f(-1.0f, -1.0f, -1.0f); pyramidBatch.Normal3f(0.0f, -1.0f, 0.0f); pyramidBatch.MultiTexCoord2f(0, 1.0f, 1.0f); pyramidBatch.Vertex3f(1.0f, -1.0f, 1.0f); //塔顶 M3DVector3f vApex = &#123;0.0f,1.0f,0.0f&#125;; M3DVector3f vFrontLeft = &#123;-1.0f,-1.0f,1.0f&#125;; M3DVector3f vFrontRight = &#123;1.0f,-1.0f,1.0f&#125;; M3DVector3f vBackLeft = &#123;-1.0f,-1.0f,-1.0f&#125;; M3DVector3f vBackRight = &#123;1.0f,-1.0f,-1.0f&#125;; //目的:为了临时存储法线向量 M3DVector3f n; //金字塔的前面 //三角形:(Apex,vFrontLeft,vFrontRight) //找法线 //m3dFindNormal(M3DVector3f result, const M3DVector3f point1, const M3DVector3f point2,const M3DVector3f point3); //参数1:结果 //参数2-4:3个顶点 m3dFindNormal(n, vApex, vFrontLeft, vFrontRight); //vApex pyramidBatch.Normal3fv(n); pyramidBatch.MultiTexCoord2f(0, 0.5, 1.0f); pyramidBatch.Vertex3fv(vApex); //vFrontLeft pyramidBatch.Normal3fv(n); pyramidBatch.MultiTexCoord2f(0, 0.0f, 0.0f); pyramidBatch.Vertex3fv(vFrontLeft); //vFrongRight pyramidBatch.Normal3fv(n); pyramidBatch.MultiTexCoord2f(0, 1.0f, 0.0f); pyramidBatch.Vertex3fv(vFrontRight); //金字塔的左边 //三角形:(Apex,vBackLeft,vFrontLeft) m3dFindNormal(n, vApex, vBackLeft, vFrontLeft); //vApex pyramidBatch.Normal3fv(n); pyramidBatch.MultiTexCoord2f(0, 0.5f, 1.0f); pyramidBatch.Vertex3fv(vApex); //vBackLeft pyramidBatch.Normal3fv(n); pyramidBatch.MultiTexCoord2f(0, 1.0f, 0.0f); pyramidBatch.Vertex3fv(vBackLeft); //vFrontLeft pyramidBatch.Normal3fv(n); pyramidBatch.MultiTexCoord2f(0, 0.0f, 0.0f); pyramidBatch.Vertex3fv(vFrontLeft); //金字塔右边 //三角形：（vApex, vFrontRight, vBackRight） m3dFindNormal(n, vApex, vFrontRight, vBackRight); pyramidBatch.Normal3fv(n); pyramidBatch.MultiTexCoord2f(0, 0.5f, 1.0f); pyramidBatch.Vertex3fv(vApex); pyramidBatch.Normal3fv(n); pyramidBatch.MultiTexCoord2f(0, 1.0f, 0.0f); pyramidBatch.Vertex3fv(vFrontRight); pyramidBatch.Normal3fv(n); pyramidBatch.MultiTexCoord2f(0, 0.0f, 0.0f); pyramidBatch.Vertex3fv(vBackRight); //金字塔后边 //三角形：（vApex, vBackRight, vBackLeft） m3dFindNormal(n, vApex, vBackRight, vBackLeft); pyramidBatch.Normal3fv(n); pyramidBatch.MultiTexCoord2f(0, 0.5f, 1.0f); pyramidBatch.Vertex3fv(vApex); pyramidBatch.Normal3fv(n); pyramidBatch.MultiTexCoord2f(0, 0.0f, 0.0f); pyramidBatch.Vertex3fv(vBackRight); pyramidBatch.Normal3fv(n); pyramidBatch.MultiTexCoord2f(0, 1.0f, 0.0f); pyramidBatch.Vertex3fv(vBackLeft); //结束批次设置 pyramidBatch.End(); 2.加载2D纹理1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980// 将TGA文件加载为2D纹理。//参数1:纹理文件名称//参数2:缩小时过滤器使用的哪一种//参数3:放大小时过滤器使用的哪一种//参数4:纹理坐标环绕方式bool LoadTGATexture(const char *szFileName, GLenum minFilter, GLenum magFilter, GLenum wrapMode)&#123; GLbyte *pBits; int nWidth,nHeight,nComponents; GLenum eFormat; //1.读取纹理的像素 //参数1:纹理文件的名称 //参数2:文件的宽度地址 //参数3:文件的高度地址 //参数4:文件的组件地址 //参数5:文件格式地址 //返回值:pBits ,指向图像数据的指针 pBits = gltReadTGABits(szFileName, &amp;nWidth, &amp;nHeight, &amp;nComponents, &amp;eFormat); if (pBits == NULL) &#123; printf(\"读取纹理像素失败\\n\"); return false; &#125; //2.设置纹理参数 //设置s,t的环绕方式 //glTexParameteri (GLenum target, GLenum pname, GLint param); //参数1:纹理维度 //参数2:为S/T坐标设置环绕模式 //参数3:wrapMode,环绕模式 glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, wrapMode); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, wrapMode); //设置放大\\缩小的过滤方式 glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, minFilter); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, magFilter); //3.精密包装像素数据 //glPixelStorei (GLenum pname, GLint param); //参数1:GL_UNPACK_ALIGNMENT ,OpenGL 如何从数据缓存区中解包图像数据 //参数2:设置GL_UNPACK_ALIGNMENT的值 glPixelStorei(GL_UNPACK_ALIGNMENT, 1); //4.载入纹理 //glTexImage2D (GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels); //参数1:纹理的维度 //参数2:mip贴图层次 //参数3:加载纹理颜色成分(从读取像素图获取的) //参数4:加载纹理的宽 //参数5:加载纹理的高 //参数6:纹理的边框 //参数7:像素数据的类型 //参数8:指向纹理数据的指针 //详细可参考PPT glTexImage2D(GL_TEXTURE_2D, 0, nComponents, nWidth, nHeight, 0, eFormat, GL_UNSIGNED_BYTE, pBits); //使用完释放 free(pBits); //只有minFilter 等于以下四种模式，才可以生成Mip贴图 //GL_NEAREST_MIPMAP_NEAREST具有非常好的性能，并且闪烁现象非常弱 //GL_LINEAR_MIPMAP_NEAREST常常用于对游戏进行加速，它使用了高质量的线性过滤器 //GL_LINEAR_MIPMAP_LINEAR 和GL_NEAREST_MIPMAP_LINEAR 过滤器在Mip层之间执行了一些额外的插值，以消除他们之间的过滤痕迹。 //GL_LINEAR_MIPMAP_LINEAR 三线性Mip贴图。纹理过滤的黄金准则，具有最高的精度。 if(minFilter == GL_LINEAR_MIPMAP_LINEAR || minFilter == GL_LINEAR_MIPMAP_NEAREST || minFilter == GL_NEAREST_MIPMAP_LINEAR || minFilter == GL_NEAREST_MIPMAP_NEAREST) //加载Mip,纹理生成所有的Mip层 //参数：GL_TEXTURE_1D、GL_TEXTURE_2D、GL_TEXTURE_3D glGenerateMipmap(GL_TEXTURE_2D); return true;&#125; 3.SetUp12345678910111213141516171819202122232425262728293031323334353637void SetupRC()&#123; glClearColor(0.7f, 0.7f,0.7f, 1.0f); shaderManager.InitializeStockShaders(); //开启深度测试 glEnable(GL_DEPTH_TEST); //纹理对象的处理 //1.分配纹理对象 // glGenTextures (GLsizei n, GLuint *textures); //参数1:纹理对象的个数 //参数2:纹理对象的指针 glGenTextures(1, &amp;textureID); //2.绑定纹理状态 //glBindTexture (GLenum target, GLuint texture); //参数1:纹理的状态,GL_TEXTURE_1D\\GL_TEXTURE_2D\\GL_TEXTURE_3D glBindTexture(GL_TEXTURE_2D, textureID); //3.将TGA文件加载成2D纹理 //函数是开发者自己设计的 //参数1:纹理文件名称 //参数2:缩小时过滤器使用的哪一种 //参数3:放大小时过滤器使用的哪一种 //参数4:纹理坐标环绕方式 LoadTGATexture(\"brick.tga\", GL_LINEAR, GL_LINEAR, GL_CLAMP_TO_EDGE); //4.设置渲染图像的顶点--金字塔 MakePyramid(pyramidBatch); cameraFrame.MoveForward(-10.0); &#125; 4.渲染1234567891011121314151617181920212223242526272829303132333435363738394041424344454647void RenderScene(void)&#123; //光照位置 static GLfloat vLightPos[] = &#123;1.0f,1.0f,0.0f&#125;; //关照颜色 static GLfloat vWhite[] = &#123;1.0f,0.0f,0.0f,1.0f&#125;; //glClear(GL_COLOR_BUFFER_BIT| GL_DEPTH_BUFFER|GL_STENCIL_BUFFER_BIT); glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT); modelViewMatrix.PushMatrix(); //观察者 M3DMatrix44f mCamera; cameraFrame.GetCameraMatrix(mCamera); modelViewMatrix.MultMatrix(mCamera); // M3DMatrix44f mObjectFrame; objectFrame.GetMatrix(mObjectFrame); modelViewMatrix.MultMatrix(mObjectFrame); //错误地方!!! //glBindTexture(GL_TEXTURE_2D, 0); glBindTexture(GL_TEXTURE_2D, textureID); //点光源着色器 //参数1:GLT_SHADER_TEXTURE_POINT_LIGHT_DIFF //参数2:模型视图矩阵 //参数3:投影矩阵 //参数4:光源的位置 //参数5:光的颜色 //参数6:图形颜色(如使用了纹理,则设置为0) shaderManager.UseStockShader(GLT_SHADER_TEXTURE_POINT_LIGHT_DIFF,transformPipeline.GetModelViewMatrix(),transformPipeline.GetProjectionMatrix(),vLightPos,vWhite,0); pyramidBatch.Draw(); modelViewMatrix.PopMatrix(); glutSwapBuffers(); &#125; 效果图","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/categories/学习笔记/"}],"tags":[{"name":"opengl","slug":"opengl","permalink":"http://yoursite.com/tags/opengl/"}]},{"title":"OpenGL(六)-坐标系统","slug":"OpenGL(六)-坐标系统","date":"2019-02-19T16:38:41.000Z","updated":"2019-02-21T10:03:59.914Z","comments":true,"path":"2019/02/20/OpenGL(六)-坐标系统/","link":"","permalink":"http://yoursite.com/2019/02/20/OpenGL(六)-坐标系统/","excerpt":"在OpenGL 中有5种坐标系。1.局部坐标系(物体空间)2.世界空间3.观察空间(视觉空间)4.裁剪空间5.屏幕空间 下图是一个顶点最终转化到片段之前需要经历的所有不同的状态变化: 局部空间： 指的是物体所在的坐标空间，即是建立一个建模软件创建一个模型立方体。创建的立方体的原点可能是[0,0,0]。但它在你的程序里可能处于不同的位置。所以你的模型文件的顶点都以[0,0,0]这个为初始位置。但是他们最终显示在世界坐标系的那个位置不由局部坐标系决定。 你的模型文件所有的顶点都处于局部空间中。 比如我创建一个立体箱子,它的范围和原点都是针对局部坐标的。","text":"在OpenGL 中有5种坐标系。1.局部坐标系(物体空间)2.世界空间3.观察空间(视觉空间)4.裁剪空间5.屏幕空间 下图是一个顶点最终转化到片段之前需要经历的所有不同的状态变化: 局部空间： 指的是物体所在的坐标空间，即是建立一个建模软件创建一个模型立方体。创建的立方体的原点可能是[0,0,0]。但它在你的程序里可能处于不同的位置。所以你的模型文件的顶点都以[0,0,0]这个为初始位置。但是他们最终显示在世界坐标系的那个位置不由局部坐标系决定。 你的模型文件所有的顶点都处于局部空间中。 比如我创建一个立体箱子,它的范围和原点都是针对局部坐标的。 世界空间： 如果我们将我们所有的物体导入到程序当中，它们有可能会全挤在世界的原点(0, 0, 0)上，这并不是我们想要的结果。我们想为每一个物体定义一个位置，从而能在更大的世界当中放置它们。世界空间中的坐标正如其名：是指顶点相对于（游戏）世界的坐标。如果你希望将物体分散在世界上摆放（特别是非常真实的那样），这就是你希望物体变换到的空间。物体的坐标将会从局部变换到世界空间；该变换是由模型矩阵(Model Matrix)实现的 模型矩阵是一种变换矩阵，它能通过对物体进行位移、缩放、旋转来将它置于它本应该在的位置或朝向。你可以将它想像为变换一个房子，你需要先将它缩小（它在局部空间中太大了），并将其位移至郊区的一个小镇，然后在y轴上往左旋转一点以搭配附近的房子。你也可以把上一节将箱子到处摆放在场景中用的那个矩阵大致看作一个模型矩阵；我们将箱子的局部坐标变换到场景/世界中的不同位置。 观察空间： 观察空间经常被人们称之OpenGL的摄像机(Camera)（所以有时也称为摄像机空间(Camera Space)或视觉空间(Eye Space)）。观察空间是将世界空间坐标转化为用户视野前方的坐标而产生的结果。因此观察空间就是从摄像机的视角所观察到的空间。而这通常是由一系列的位移和旋转的组合来完成，平移/旋转场景从而使得特定的对象被变换到摄像机的前方。这些组合在一起的变换通常存储在一个观察矩阵(View Matrix)里，它被用来将世界坐标变换到观察空间 裁剪空间： 在一个顶点着色器运行的最后，OpenGL期望所有的坐标都能落在一个特定的范围内，且任何在这个范围之外的点都应该被裁剪掉(Clipped)。被裁剪掉的坐标就会被忽略，所以剩下的坐标就将变为屏幕上可见的片段。这也就是裁剪空间(Clip Space)名字的由来。 因为将所有可见的坐标都指定在-1.0到1.0的范围内不是很直观，所以我们会指定自己的坐标集(Coordinate Set)并将它变换回标准化设备坐标系，就像OpenGL期望的那样。 为了将顶点坐标从观察变换到裁剪空间，我们需要定义一个投影矩阵(Projection Matrix)，它指定了一个范围的坐标，比如在每个维度上的-1000到1000。投影矩阵接着会将在这个指定的范围内的坐标变换为标准化设备坐标的范围(-1.0, 1.0)。所有在范围外的坐标不会被映射到在-1.0到1.0的范围之间，所以会被裁剪掉。在上面这个投影矩阵所指定的范围内，坐标(1250, 500, 750)将是不可见的，这是由于它的x坐标超出了范围，它被转化为一个大于1.0的标准化设备坐标，所以被裁剪掉了。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/categories/学习笔记/"}],"tags":[{"name":"opengl","slug":"opengl","permalink":"http://yoursite.com/tags/opengl/"}]},{"title":"OpenGL(五)-矩阵变换","slug":"OpenGL(五)-矩阵变换","date":"2019-02-19T16:38:40.000Z","updated":"2019-02-21T10:03:52.070Z","comments":true,"path":"2019/02/20/OpenGL(五)-矩阵变换/","link":"","permalink":"http://yoursite.com/2019/02/20/OpenGL(五)-矩阵变换/","excerpt":"关键函数讲解平移123456789101112//创建单元矩阵 M3DMatrix44f m3;m3dLoadIdentity44(m3);/* m3dTranslationMatrix44(M3DMatrix44f m, float x, float y, float z) 参数1:结果矩阵,平移之后的结果矩阵 参数2:沿着X轴移动多少,正数\\负数 参数3:沿着Y轴移动多少,正数\\负数 参数4:沿着Z轴移动多少,正数\\负数 */m3dTranslationMatrix44(m3, 0.0f, 10.0f, 0.0f);","text":"关键函数讲解平移123456789101112//创建单元矩阵 M3DMatrix44f m3;m3dLoadIdentity44(m3);/* m3dTranslationMatrix44(M3DMatrix44f m, float x, float y, float z) 参数1:结果矩阵,平移之后的结果矩阵 参数2:沿着X轴移动多少,正数\\负数 参数3:沿着Y轴移动多少,正数\\负数 参数4:沿着Z轴移动多少,正数\\负数 */m3dTranslationMatrix44(m3, 0.0f, 10.0f, 0.0f); 旋转1234567891011121314151617181920 /* m3dRotationMatrix44(M3DMatrix44f m, float angle, float x, float y, float z); 参数1:结果矩阵,旋转之后的结果矩阵 参数2:旋转多少弧度 参数3:是否围绕X轴旋转,是(1),不是(0) 参数4:是否围绕Y轴旋转,是(1),不是(0) 参数5:是否围绕Z轴旋转,是(1),不是(0) */ m3dRotationMatrix44(m3, m3dDegToRad(45.0f), 1.0f, 0.0f, 0.0f);``` ### 缩放```objc /* void m3dScaleMatrix44(M3DMatrix44f m, float xScale, float yScale, float zScale) 参数1:结果矩阵 参数2:围绕X轴放大\\缩小;放大x&gt;1,缩小:0.5f 参数3:围绕Y轴放大\\缩小;放大x&gt;1,缩小:0.5f 参数4:围绕Z轴放大\\缩小;放大x&gt;1,缩小:0.5f */ m3dScaleMatrix44(m3, 1.0f, 10.0f, 1.0f); 案例1 : 利用矩阵的平移、旋转、综合变化等, 实现矩阵的移动.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119GLBatch squareBatch;GLfloat blockSize = 0.1f;GLfloat vVerts[] = &#123; -blockSize, -blockSize, 0.0f, blockSize, -blockSize, 0.0f, blockSize, blockSize, 0.0f, -blockSize, blockSize, 0.0f&#125;;GLfloat xPos = 0.0f;GLfloat yPos = 0.0f;void SetupRC()&#123; //背景颜色 glClearColor(0.0f, 0.0f, 1.0f, 1.0f ); shaderManager.InitializeStockShaders(); // 加载矩形 squareBatch.Begin(GL_TRIANGLE_FAN, 4); squareBatch.CopyVertexData3f(vVerts); squareBatch.End();&#125;//移动（移动只是计算了X,Y移动的距离，以及碰撞检测）void SpecialKeys(int key, int x, int y)&#123; GLfloat stepSize = 0.025f; if(key == GLUT_KEY_UP) yPos += stepSize; if(key == GLUT_KEY_DOWN) yPos -= stepSize; if(key == GLUT_KEY_LEFT) xPos -= stepSize; if(key == GLUT_KEY_RIGHT) xPos += stepSize; // 碰撞检测 if(xPos &lt; (-1.0f + blockSize)) xPos = -1.0f + blockSize; if(xPos &gt; (1.0f - blockSize)) xPos = 1.0f - blockSize; if(yPos &lt; (-1.0f + blockSize)) yPos = -1.0f + blockSize; if(yPos &gt; (1.0f - blockSize)) yPos = 1.0f - blockSize; // 每次操作方向键之后, 重新调用RenderScene进行新的场景渲染 glutPostRedisplay();&#125;void RenderScene(void)&#123; glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT); GLfloat vRed[] = &#123; 1.0f, 0.0f, 0.0f, 1.0f &#125;; //!!!矩阵变化 - 关键代码!!! M3DMatrix44f mFinalTransform, mTranslationMatrix, mRotationMatrix; //平移 xPos,yPos m3dTranslationMatrix44(mTranslationMatrix, xPos, yPos, 0.0f); // 每次重绘时，旋转5度 static float yRot = 0.0f; yRot += 5.0f; m3dRotationMatrix44(mRotationMatrix, m3dDegToRad(yRot), 0.0f, 0.0f, 1.0f); //将旋转和移动的结果合并到mFinalTransform 中 m3dMatrixMultiply44(mFinalTransform, mTranslationMatrix, mRotationMatrix); //将矩阵结果提交到固定着色器（平面着色器）中。 shaderManager.UseStockShader(GLT_SHADER_FLAT, mFinalTransform, vRed); //!!!矩形重新绘制, 即会出现一个既平移了方向又旋转了角度的新矩形 squareBatch.Draw(); // 执行缓冲区交换 glutSwapBuffers();&#125;void ChangeSize(int w, int h)&#123; glViewport(0, 0, w, h);&#125;int main(int argc, char* argv[])&#123; gltSetWorkingDirectory(argv[0]); glutInit(&amp;argc, argv); glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGBA | GLUT_DEPTH); glutInitWindowSize(600, 600); glutCreateWindow(\"Move Block with Arrow Keys\"); GLenum err = glewInit(); if (GLEW_OK != err) &#123; fprintf(stderr, \"Error: %s\\n\", glewGetErrorString(err)); return 1; &#125; glutReshapeFunc(ChangeSize);//设置视口大小 glutDisplayFunc(RenderScene);//渲染场景 glutSpecialFunc(SpecialKeys);//键盘方向键操作 SetupRC(); glutMainLoop(); return 0;&#125; 效果图:注: 本例是键盘的上下左右方向键来控制矩形的旋转平移, 具体代码参见上面 案例2 : 利用模型视图矩阵和投影矩阵让一个球体旋转绘制球体123gltMakeSphere(torusBatch, 0.4f, 10, 20);glPolygonMode(GL_FRONT_AND_BACK, GL_LINE); 设置模型视图矩阵 和 投影矩阵12345678910111213141516171819202122232425262728293031323334//建立一个基于时间变化的动画static CStopWatch rotTimer;//当前时间 * 60sfloat yRot = rotTimer.GetElapsedSeconds() * 60.0f;glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);//矩阵变量M3DMatrix44f mTranlate,mRotate,mModelView,mModelViewProjection;//将圆球像Z轴负方向移动2.5个单位长度m3dTranslationMatrix44(mTranlate, 0.0f , 0.0f,-2.5f);//旋转m3dRotationMatrix44(mRotate, m3dDegToRad(yRot), 0.0f, 1.0f, 0.0f);//将平移和旋转的矩阵进行叉乘,产生一个新的矩阵mModelViewm3dMatrixMultiply44(mModelView, mTranlate, mRotate);//模型视图矩阵 和 投影矩阵//将投影矩阵 与 模型视图矩阵进行叉乘 ,将变化最终结果通过矩阵叉乘的方式应用到mModelViewProjection中来m3dMatrixMultiply44(mModelViewProjection, viewFrustum.GetProjectionMatrix(), mModelView);GLfloat vBlack[] = &#123;0.0f,0.0f,0.0f,1.0f&#125;;//平面着色器来渲染图像shaderManager.UseStockShader(GLT_SHADER_FLAT,mModelViewProjection,vBlack);//开始绘图torusBatch.Draw();glutSwapBuffers();glutPostRedisplay(); 效果图","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/categories/学习笔记/"}],"tags":[{"name":"opengl","slug":"opengl","permalink":"http://yoursite.com/tags/opengl/"}]},{"title":"OpenGL(四)-两种方式实现抗锯齿效果","slug":"OpenGL(四)-两种方式实现抗锯齿效果","date":"2019-02-19T16:38:39.000Z","updated":"2019-02-21T10:03:43.262Z","comments":true,"path":"2019/02/20/OpenGL(四)-两种方式实现抗锯齿效果/","link":"","permalink":"http://yoursite.com/2019/02/20/OpenGL(四)-两种方式实现抗锯齿效果/","excerpt":"方式一 : 利用混合(GLBlend)实现抗锯齿","text":"方式一 : 利用混合(GLBlend)实现抗锯齿 核心代码如下:12345678910111213141516171819202122232425262728293031323334// 选择菜单void ProcessMenu(int value)&#123; switch (value) &#123; case 1: //打开抗锯齿功能 //1.开启混合功能 glEnable(GL_BLEND); //2.指定混合因子 //注意:如果你修改了混合方程式,当你使用混合抗锯齿功能时,请一定要改为默认混合方程式 glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); //3.开启对点\\线\\多边形的抗锯齿功能 glEnable(GL_POINT_SMOOTH); glEnable(GL_LINE_SMOOTH); glEnable(GL_POLYGON_SMOOTH); break; case 2: //关闭抗锯齿功能 glDisable(GL_BLEND); glDisable(GL_LINE_SMOOTH); glDisable(GL_POINT_SMOOTH); glDisable(GL_POLYGON_SMOOTH); break; default: break; &#125; glutPostRedisplay();&#125; 方式二 : 利用多重采样实现抗锯齿12345678//用多重采样来解决锯齿问题.可选 glEnable(GLUT_MULTISAMPLE); //绘制 moonBatch.Draw(); //绘制完成,则关闭 glDisable(GLUT_MULTISAMPLE); 效果图: 关闭抗锯齿: 打开抗锯齿:","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/categories/学习笔记/"}],"tags":[{"name":"opengl","slug":"opengl","permalink":"http://yoursite.com/tags/opengl/"}]},{"title":"OpenGL(三)-深度测试","slug":"OpenGL(三)-深度测试","date":"2019-02-19T16:38:38.000Z","updated":"2019-02-21T10:03:36.278Z","comments":true,"path":"2019/02/20/OpenGL(三)-深度测试/","link":"","permalink":"http://yoursite.com/2019/02/20/OpenGL(三)-深度测试/","excerpt":"什么叫深度?所谓深度,就是在坐标系中,像素Z坐标距离观察者的距离.观察者可以在任何位置.OpenGL会有专门一块缓存区来存放Z值, 即深度缓冲区. 深度缓冲区作用?一般情况下,我们绘制图形时,后面绘制的会覆盖前面的图形.这样就会产生一个性能问题:就是遮盖部分,先绘制的会被覆盖,那么这块区域就是无意义的绘制.深度测试就是用来解决这个问题的.它是如何处理的呢?有了深度缓冲区之后,绘制的时候会检查Z值,靠近观察者的不覆盖, 远离观察者的被覆盖,而不是靠绘制顺序来决定.","text":"什么叫深度?所谓深度,就是在坐标系中,像素Z坐标距离观察者的距离.观察者可以在任何位置.OpenGL会有专门一块缓存区来存放Z值, 即深度缓冲区. 深度缓冲区作用?一般情况下,我们绘制图形时,后面绘制的会覆盖前面的图形.这样就会产生一个性能问题:就是遮盖部分,先绘制的会被覆盖,那么这块区域就是无意义的绘制.深度测试就是用来解决这个问题的.它是如何处理的呢?有了深度缓冲区之后,绘制的时候会检查Z值,靠近观察者的不覆盖, 远离观察者的被覆盖,而不是靠绘制顺序来决定. 如何使用深度缓冲区测试?glEnable(GLDEPTHTEST);开启之后,就会先测试深度值再绘制默认情况下, Z值小的会被覆盖 如果观察者,在Z轴的正方向,Z值大则靠近观察者如果观察者,在Z轴的负方向,Z值小则靠近观察者 如何解决深度值相同,造成的冲突问题? 第一种方法:在第二次绘制时, 稍微偏移一点点解决这个问题.注意:必须非常小心确保Z值的间隙.(比如贴在飞机上的五角星会悬浮起来的风险) 第二种方法:采用glPolygonOffset函数,使得可以调节片段的深度值.使深度值偏移而不产生悬浮.","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/categories/学习笔记/"}],"tags":[{"name":"opengl","slug":"opengl","permalink":"http://yoursite.com/tags/opengl/"}]},{"title":"OpenGL(二)-基本图元绘制","slug":"OpenGL(二)-基本图元绘制","date":"2019-02-19T16:38:37.000Z","updated":"2019-02-21T10:03:28.606Z","comments":true,"path":"2019/02/20/OpenGL(二)-基本图元绘制/","link":"","permalink":"http://yoursite.com/2019/02/20/OpenGL(二)-基本图元绘制/","excerpt":"OpenGL与着色器在OpenGL 3.0之前，OpenGL包含一个固定功能的管线，它可以在不使用着色器的情况下处理几何与像素数据。从3.1版本开始，固定管线从核心模式去掉。因此现在需要使用着色器来完成工作.我们会使用GLSL,(OpenGL Shading Language，它是在OpenGL 2.0版本发布的)。 语法与“C、C++”类似。","text":"OpenGL与着色器在OpenGL 3.0之前，OpenGL包含一个固定功能的管线，它可以在不使用着色器的情况下处理几何与像素数据。从3.1版本开始，固定管线从核心模式去掉。因此现在需要使用着色器来完成工作.我们会使用GLSL,(OpenGL Shading Language，它是在OpenGL 2.0版本发布的)。 语法与“C、C++”类似。 基础图形管线OpenGL中的图元只不过是顶点的集合以预定义的方式结合在一起。管线分为:2个部分，上半部分是 客户机端，下半部分是服务器端。服务器 和 客户端 在功能和运行上都是异步的。它们是各自独立的软件块或硬件块。 三种向OpenGL 着色器传递渲染数据的方法: 属性: 就是对一个顶点都要作改变的数据元素。实际上，顶点位置本身就是一个属性。属性可以是浮点类型、整型、布尔类型. Uniform: 通过设置Uniform 变量发送一个图元批次命令。Uniform 变量实际上可以无限次限制地使用，比如设置一个应用于整个表面的单个颜色值。还可以设置一个时间值 纹理 基本图元类型 注意着重区分以下三种绘制方式的区别 存储着色器的使用着色器有以下分类：• 单位着色器• 平面着色器• 上色着色器• 默认光源着色器• 点光源着色器• 纹理替换矩阵• 纹理调整着色器• 纹理光源着色器123456//定义着色器GLShaderMananger shaderManager;//初始化着色器 shaderManager.InitalizeStockShaders()//使用shaderManager userStockManager(参数列表) 单位着色器 GLShaderManager::UserStockShader(GLT_ATTRIBUTE_VERTEX,GLfloat vColor[4]); 平面着色器 GLShaderManager::UserStockShader(GLT_SHADER_FLAT,GLfloat mvp[16],GLfloat vColor[4]); 上色着色器 GLShaderManager::UserStockShader(GLT_SHADER_SHADED,GLfloat mvp[16]); 默认光源着色器 GLShaderManager::UserStockShader(GLT_SHADER_DEFAULT_LIGHT,GLfloat mvMatrix[16],GLfloat pMatrix[16],GLfloat vColor[4]); 点光源着色器 GLShaderManager::UserStockShader(GLT_SHADER_DEFAULT_LIGHT_DIEF,GLfloat mvMatrix[16],GLfloat pMatrix[16],GLfloat vLightPos[3],GLfloat vColor[4]); 纹理替换矩阵着色器 GLShaderManager::UserStockShader(GLT_SHADER_TEXTURE_REPLACE,GLfloat mvMatrix[16],GLint nTextureUnit); 纹理调整着色器 GLShaderManager::UserStockShader(GLT_SHADER_TEXTURE_MODULATE,GLfloat mvMatrix[16],GLfloat vColor[4],GLint nTextureUnit); 纹理光源着色器 GLShaderManager::UserStockShader(GLT_SHADER_TEXTURE_POINT_LIGHT_DIEF,GLfloat mvMatrix[16],GLfloat pMatrix[16],GLfloat vLightPos[3],GLfloat vBaseColor[4],GLint nTextureUnit); 绘制不同类型的图元123456789101112131415161718192021// 各种需要的类GLShaderManager shaderManager;GLMatrixStack modelViewMatrix;GLMatrixStack projectionMatrix;GLFrame cameraFrame;GLFrame objectFrame;//投影矩阵GLFrustum viewFrustum;//容器类（7种不同的图元对应7种容器对象）GLBatch pointBatch;GLBatch lineBatch;GLBatch lineStripBatch;GLBatch lineLoopBatch;GLBatch triangleBatch;GLBatch triangleStripBatch;GLBatch triangleFanBatch;//几何变换的管道GLGeometryTransform transformPipeline;M3DMatrix44f shadowMatrix; 点/线/线段/线环绘制12345678910111213141516171819202122232425262728293031323334// 准备一些随机点数据 GLfloat vCoast[24][3] = &#123; &#123;2.80, 1.20, 0.0 &#125;, &#123;2.0, 1.20, 0.0 &#125;, &#123;2.0, 1.08, 0.0 &#125;, &#123;2.0, 1.08, 0.0 &#125;, &#123;0.0, 0.80, 0.0 &#125;, &#123;-.32, 0.40, 0.0 &#125;, &#123;-.48, 0.2, 0.0 &#125;, &#123;-.40, 0.0, 0.0 &#125;, &#123;-.60, -.40, 0.0 &#125;, &#123;-.80, -.80, 0.0 &#125;, &#123;-.80, -1.4, 0.0 &#125;, &#123;-.40, -1.60, 0.0 &#125;, &#123;0.0, -1.20, 0.0 &#125;, &#123; .2, -.80, 0.0 &#125;, &#123;.48, -.40, 0.0 &#125;, &#123;.52, -.20, 0.0 &#125;, &#123;.48, .20, 0.0 &#125;, &#123;.80, .40, 0.0 &#125;, &#123;1.20, .80, 0.0 &#125;, &#123;1.60, .60, 0.0 &#125;, &#123;2.0, .60, 0.0 &#125;, &#123;2.2, .80, 0.0 &#125;, &#123;2.40, 1.0, 0.0 &#125;, &#123;2.80, 1.0, 0.0 &#125;&#125;; //用点的形式绘制(GL_POINTS) pointBatch.Begin(GL_POINTS, 24); pointBatch.CopyVertexData3f(vCoast); pointBatch.End(); //通过线的形式绘制(GL_LINES) lineBatch.Begin(GL_LINES, 24); lineBatch.CopyVertexData3f(vCoast); lineBatch.End(); //通过线段的形式绘制(GL_LINE_STRIP) lineStripBatch.Begin(GL_LINE_STRIP, 24); lineStripBatch.CopyVertexData3f(vCoast); lineStripBatch.End(); //通过线环的形式绘制(GL_LINE_LOOP) lineLoopBatch.Begin(GL_LINE_LOOP, 24); lineLoopBatch.CopyVertexData3f(vCoast); lineLoopBatch.End(); 效果如下: 三角形绘制方式 - GL_TRIANGLES123456789101112131415161718192021222324252627 //通过三角形绘制(GL_TRIANGLES) -- 生成一个金字塔的形状 GLfloat vPyramid[12][3] = &#123; -2.0f, 0.0f, -2.0f, 2.0f, 0.0f, -2.0f, 0.0f, 4.0f, 0.0f, 2.0f, 0.0f, -2.0f, 2.0f, 0.0f, 2.0f, 0.0f, 4.0f, 0.0f, 2.0f, 0.0f, 2.0f, -2.0f, 0.0f, 2.0f, 0.0f, 4.0f, 0.0f, -2.0f, 0.0f, 2.0f, -2.0f, 0.0f, -2.0f, 0.0f, 4.0f, 0.0f&#125;; //GL_TRIANGLES 每3个顶点定义一个新的三角形 triangleBatch.Begin(GL_TRIANGLES, 12); triangleBatch.CopyVertexData3f(vPyramid); triangleBatch.End();``` * 效果图:![GL_TRIANGLES.png](http://upload-images.jianshu.io/upload_images/1352344-a577c287b2f55072.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)###### 三角形扇绘制方式 - GL_TRIANGLE_FAN // 三角形扇绘制(GL_TRIANGLE_FAN) -- 生成一个六边形 GLfloat vPoints[100][3]; //超过我们需要的数组 int nVerts = 0; //半径 GLfloat r = 3.0f; //原点(x,y,z) = (0,0,0); vPoints[nVerts][0] = 0.0f; vPoints[nVerts][1] = 0.0f; vPoints[nVerts][2] = 0.0f; //M3D_2PI 就是2Pi 的意思，就一个圆的意思。 绘制圆形 for(GLfloat angle = 0; angle &lt; M3D_2PI; angle += M3D_2PI / 6.0f) { //数组下标自增（每自增1次就表示一个顶点） nVerts++; /* 弧长=半径*角度,这里的角度是弧度制,不是平时的角度制 既然知道了cos值,那么角度=arccos,求一个反三角函数就行了 */ //x点坐标 cos(angle) * 半径 vPoints[nVerts][0] = float(cos(angle)) * r; //y点坐标 sin(angle) * 半径 vPoints[nVerts][1] = float(sin(angle)) * r; //z点的坐标 vPoints[nVerts][2] = -0.5f; } // 结束扇形 : 前面一共绘制7个顶点（包括圆心） printf(&quot;三角形扇形顶点数:%d\\n&quot;,nVerts); //添加闭合的终点, 若不添加, 则三角形扇形是无法闭合的。 nVerts++; vPoints[nVerts][0] = r; vPoints[nVerts][1] = 0; vPoints[nVerts][2] = 0.0f; //GL_TRIANGLE_FAN 以一个圆心为中心呈扇形排列，共用相邻顶点的一组三角形 triangleFanBatch.Begin(GL_TRIANGLE_FAN, 8); triangleFanBatch.CopyVertexData3f(vPoints); triangleFanBatch.End(); 1234* 效果图:![GL_TRIANGLE_FAN.png](http://upload-images.jianshu.io/upload_images/1352344-ec20836c62236f9b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)###### 三角形条带绘制方式 - GL_TRIANGLE_STRIP //三角形条带绘制(GL_TRIANGLE_STRIP) -- 生成一个小环或圆柱段 //顶点下标 int iCounter = 0; //半径 GLfloat radius = 3.0f; //从0度~360度，以0.3弧度为步长 for(GLfloat angle = 0.0f; angle &lt;= (2.0f*M3D_PI); angle += 0.3f) { //或许圆形的顶点的X,Y GLfloat x = radius * sin(angle); GLfloat y = radius * cos(angle); //绘制2个三角形（他们的x,y顶点一样，只是z点不一样） vPoints[iCounter][0] = x; vPoints[iCounter][1] = y; vPoints[iCounter][2] = -0.5; iCounter++; vPoints[iCounter][0] = x; vPoints[iCounter][1] = y; vPoints[iCounter][2] = 0.5; iCounter++; } // 关闭循环 printf(&quot;三角形带的顶点数：%d\\n&quot;,iCounter); //结束循环，在循环位置生成2个三角形 vPoints[iCounter][0] = vPoints[0][0]; vPoints[iCounter][1] = vPoints[0][1]; vPoints[iCounter][2] = -0.5; iCounter++; vPoints[iCounter][0] = vPoints[1][0]; vPoints[iCounter][1] = vPoints[1][1]; vPoints[iCounter][2] = 0.5; iCounter++; // GL_TRIANGLE_STRIP 共用一个条带（strip）上的顶点的一组三角形 triangleStripBatch.Begin(GL_TRIANGLE_STRIP, iCounter); triangleStripBatch.CopyVertexData3f(vPoints); triangleStripBatch.End(); ` 效果图:","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/categories/学习笔记/"}],"tags":[{"name":"opengl","slug":"opengl","permalink":"http://yoursite.com/tags/opengl/"}]},{"title":"OpenGL(一)-初识OpenGL及其在Mac上的环境搭建","slug":"OpenGL(一)-初识OpenGL及其在Mac上的环境搭建","date":"2019-02-19T16:38:36.000Z","updated":"2019-02-21T09:59:43.161Z","comments":true,"path":"2019/02/20/OpenGL(一)-初识OpenGL及其在Mac上的环境搭建/","link":"","permalink":"http://yoursite.com/2019/02/20/OpenGL(一)-初识OpenGL及其在Mac上的环境搭建/","excerpt":"OpenGL是一种用于创建实时3D图像的编程接口。 走向3D三维(3D)表示一个正在描述或显示的物体具有三个维度：宽度，高度，深度。几个世纪以来，艺术家们已经知道如何让一幅画有立体感并具有真实感的深度，通过颜料在二维画布上创作的作品，它其实本质上画的是一个二维物体。类似，计算机3D图像实质上也是平面的，它只是在计算机屏幕上所显示的二维图像，但它可以提供深度的错觉。实际上如果我们需要一个物体的二维画面从不同角度上感知三维空间，我们可以通过透视、隐藏直线消除、颜色、着色和其他技巧来创建深度幻觉。 2D + 透视 = 3D 3D图形术语 变化&amp;投影 光栅化：实际绘制或填充每个顶点之间的像素形成过程 着色：沿着顶点之间改变颜色值。着色器则是图形硬件上执行的单独程序，用来处理顶点和光栅化任务。 纹理贴图：初学可以简单理解为贴到图形上的图片（但纹理并不是图片， 二者不等价）。在GPU上，纹理是快捷有效的。 混合：混合是将不同的颜色混合在一起。","text":"OpenGL是一种用于创建实时3D图像的编程接口。 走向3D三维(3D)表示一个正在描述或显示的物体具有三个维度：宽度，高度，深度。几个世纪以来，艺术家们已经知道如何让一幅画有立体感并具有真实感的深度，通过颜料在二维画布上创作的作品，它其实本质上画的是一个二维物体。类似，计算机3D图像实质上也是平面的，它只是在计算机屏幕上所显示的二维图像，但它可以提供深度的错觉。实际上如果我们需要一个物体的二维画面从不同角度上感知三维空间，我们可以通过透视、隐藏直线消除、颜色、着色和其他技巧来创建深度幻觉。 2D + 透视 = 3D 3D图形术语 变化&amp;投影 光栅化：实际绘制或填充每个顶点之间的像素形成过程 着色：沿着顶点之间改变颜色值。着色器则是图形硬件上执行的单独程序，用来处理顶点和光栅化任务。 纹理贴图：初学可以简单理解为贴到图形上的图片（但纹理并不是图片， 二者不等价）。在GPU上，纹理是快捷有效的。 混合：混合是将不同的颜色混合在一起。 3D图形的常见用途实时3D图形的应用范围包括交互式游戏和模拟数据的可视化显示（供科学、医学或商业应用）；在计算机领域，3D图形的应用几乎没有止境。目前最常见的用途，游戏、AR、VR，都是基于openGL的。3D图形在科学视觉和工程应用中非常流行，物美价廉的3D硬件大量涌现使得这些应用技术空前的流行火爆。Mac OS X以及iOS都是使用openGL对所有窗口和控件进行渲染，从而创建了功能强大，引人入胜的可视化界面。例如设计使用的3D Max， 游戏制作的Unity 3D， Cocos2D底层都是使用了openGL。医学上的影像渲染也是依托于openGL。着色器在实时计算机图形中，最前沿的技术是可编程着色器（Programmable Shading）。图形卡不再是低能的渲染芯片。而是功能强大的高度可编程的渲染计算机。类似CPU的术语GPU应运而生。它代表图形处理单元，特指当今图形卡上的可编程芯片。它们是高度并行，并且具有非常快的速度。同样重要的是， 程序员可以进行重新配置图形卡的工作方式，几乎可以实现任何想要得到的特殊效果。3D编程的基本原则 并发工具包openGL基于一种底层渲染API，我们不能告诉它“在什么地方绘制”， 而是我们需要自己动手，通过载入三角形，应用必要的变化和正确的纹理、着色器并在必要应用混合模式来组合一个模型。这使得我们能够进行大量的底层控制，与使用高层工具包相比，使用openGL这样的底层API动人之处在于，我们不能仅仅是重现许多标准3D渲染，我们可以创造自己的算法，甚至可以取发现一些新的捷径、性能技巧和艺术视觉技术。 坐标系统在openGL或几乎所有的3D API中创建一个用于绘图窗口时， 必须制定希望使用的坐标系统以及指定的坐标如何映射到实际的屏幕像素。OpenGL在Mac上的环境搭建准备资源 CLTools glew libGLTools.a这些资源都可以从网上下载到配置Xcode的openGL环境 打开Xcode -&gt; macOS -&gt; Cocoa Application 添加OpenGL.framework 和 GLUT.framework 两个系统库 libGLTools.a直接拖到工程的Frameworks文件里面，另外删除文件：AppDelegate.h、AppDelegate.m、main.m、ViewController.h、ViewController.m；创建main.cpp文件 在main.cpp中复制以下代码， 来测试环境是否配置成功： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include &lt;stdio.h&gt;#include \"GLTools.h\"#include &lt;GLUT/GLUT.h&gt;GLBatch triangleBatch;GLShaderManager shaderManager;//窗口大小改变时接受新的宽度和高度，其中0,0代表窗口中视口的左下角坐标，w，h代表像素void ChangeSize(int w,int h)&#123; glViewport(0,0, w, h); &#125;//为程序作一次性的设置void SetupRC()&#123; //设置背影颜色 glClearColor(0.0f,0.0f,1.0f,1.0f); //初始化着色管理器 shaderManager.InitializeStockShaders(); //设置三角形，其中数组vVert包含所有3个顶点的x,y,笛卡尔坐标对。 GLfloat vVerts[] = &#123; -0.5f,0.0f,0.0f, 0.5f,0.0f,0.0f, 0.0f,0.5f,0.0f, &#125;; //批次处理 triangleBatch.Begin(GL_TRIANGLES,3); triangleBatch.CopyVertexData3f(vVerts); triangleBatch.End(); &#125;//开始渲染void RenderScene(void)&#123; //清除一个或一组特定的缓冲区 glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT|GL_STENCIL_BUFFER_BIT); //设置一组浮点数来表示红色 GLfloat vRed[] = &#123;1.0f,0.0f,0.0f,1.0f&#125;; //传递到存储着色器，即GLT_SHADER_IDENTITY着色器，这个着色器只是使用指定颜色以默认笛卡尔坐标第在屏幕上渲染几何图形 shaderManager.UseStockShader(GLT_SHADER_IDENTITY,vRed); //提交着色器 triangleBatch.Draw(); //将在后台缓冲区进行渲染，然后在结束时交换到前台 glutSwapBuffers(); &#125;int main(int argc,char* argv[])&#123; //设置当前工作目录，针对MAC OS X gltSetWorkingDirectory(argv[0]); //初始化GLUT库 glutInit(&amp;argc, argv); /*初始化双缓冲窗口，其中标志GLUT_DOUBLE、GLUT_RGBA、GLUT_DEPTH、GLUT_STENCIL分别指 双缓冲窗口、RGBA颜色模式、深度测试、模板缓冲区*/ glutInitDisplayMode(GLUT_DOUBLE|GLUT_RGBA|GLUT_DEPTH|GLUT_STENCIL); //GLUT窗口大小，标题窗口 glutInitWindowSize(800,600); glutCreateWindow(\"Triangle\"); //注册回调函数 glutReshapeFunc(ChangeSize); glutDisplayFunc(RenderScene); //驱动程序的初始化中没有出现任何问题。 GLenum err = glewInit(); if(GLEW_OK != err) &#123; fprintf(stderr,\"glew error:%s\\n\",glewGetErrorString(err)); return 1; &#125; //调用SetupRC SetupRC(); glutMainLoop(); return 0; &#125; 编译， 将报错的地方文件&lt;&gt;系统引入， 改为“”普通引入 效果图 那么环境搭建到此就成功了。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/categories/学习笔记/"}],"tags":[{"name":"opengl","slug":"opengl","permalink":"http://yoursite.com/tags/opengl/"}]}]}