{"meta":{"title":"Sober's Notes","subtitle":null,"description":"GET SOBER. STAY SOBER.","author":"Sober","url":"http://yoursite.com"},"pages":[{"title":"404-找不到页面","date":"2016-09-03T09:17:18.000Z","updated":"2019-02-25T09:15:26.133Z","comments":false,"path":"404.html","permalink":"http://yoursite.com/404.html","excerpt":"","text":"404 Not Found对不起，您所访问的页面不存在或者已删除你可以点击此处返回首页.你可以去我的微博看看：https://weibo.com/2938187707我的Github：https://github.com/soober我的CSDN：https://blog.csdn.net/sinat_22545219 Stay Sober, Get Sober."},{"title":"离线页面","date":"2017-06-28T13:46:18.000Z","updated":"2019-02-25T09:10:57.513Z","comments":false,"path":"offline.html","permalink":"http://yoursite.com/offline.html","excerpt":"","text":"404 Not Found对不起，没有检测到网络连接你可以点击此处返回首页."},{"title":"关于","date":"2019-02-21T03:07:53.000Z","updated":"2019-02-26T09:35:07.023Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"一只iOS小菜鸟, 有问题欢迎骚扰. QQ: 2272117761Email: 2272117761@qq.com"},{"title":"文章分类","date":"2019-02-20T10:16:44.000Z","updated":"2019-02-26T09:35:16.924Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-02-20T10:25:04.000Z","updated":"2019-02-26T09:35:36.184Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"OpenGL ES - 地球月亮渲染案例","slug":"OpenGL ES-地球月亮渲染案例","date":"2019-03-25T10:38:37.000Z","updated":"2019-10-14T11:19:31.631Z","comments":true,"path":"2019/03/25/OpenGL ES-地球月亮渲染案例/","link":"","permalink":"http://yoursite.com/2019/03/25/OpenGL ES-地球月亮渲染案例/","excerpt":"思维导图","text":"思维导图 处理ArrayBuffer封装创建顶点缓存数组12345678910111213141516171819202122232425262728293031323334// 此方法在当前的OpenGL ES上下文中创建一个顶点属性数组缓冲区，用于调用此方法的线程.- (id)initWithAttribStride:(GLsizeiptr)aStride numberOfVertices:(GLsizei)count bytes:(const GLvoid *)dataPtr usage:(GLenum)usage;&#123; NSParameterAssert(0 &lt; aStride); NSAssert((0 &lt; count &amp;&amp; NULL != dataPtr) || (0 == count &amp;&amp; NULL == dataPtr), @&quot;data must not be NULL or count &gt; 0&quot;); if(nil != (self = [super init])) &#123; stride = aStride; bufferSizeBytes = stride * count; // 第一步 glGenBuffers(1, &amp;name); // 第二步 glBindBuffer(GL_ARRAY_BUFFER, self.name); // 第三步 glBufferData( GL_ARRAY_BUFFER, // 初始化缓存区的内容 bufferSizeBytes, // 要复制的字节数 dataPtr, // 要复制的字节地址 usage); //GPU内存中的缓存 NSAssert(0 != name, @&quot;Failed to generate name&quot;); &#125; return self;&#125; 分配顶点数据,准备绘制123456789101112131415161718192021222324252627282930313233343536// 当应用程序希望使用缓冲区呈现任何几何图形时，必须准备一个顶点属性数组缓冲区。当你的应用程序准备一个缓冲区时，一些OpenGL ES状态被改变，允许绑定缓冲区和配置指针。- (void)prepareToDrawWithAttrib:(GLuint)index numberOfCoordinates:(GLint)count attribOffset:(GLsizeiptr)offset shouldEnable:(BOOL)shouldEnable&#123; NSParameterAssert((0 &lt; count) &amp;&amp; (count &lt; 4)); NSParameterAssert(offset &lt; self.stride); NSAssert(0 != name, @&quot;Invalid name&quot;); glBindBuffer(GL_ARRAY_BUFFER, self.name); if(shouldEnable) &#123; glEnableVertexAttribArray(index); &#125; glVertexAttribPointer( index, count, GL_FLOAT, GL_FALSE, self.stride, NULL + offset); #ifdef DEBUG &#123; GLenum error = glGetError(); if(GL_NO_ERROR != error) &#123; NSLog(@&quot;GL Error: 0x%x&quot;, error); &#125; &#125;#endif&#125; 绘制1234567// 提交由模式标识的绘图命令，并指示OpenGL ES从准备好的缓冲区中的顶点开始，从先前准备好的缓冲区中使用计数顶点。+ (void)drawPreparedArraysWithMode:(GLenum)mode startVertexIndex:(GLint)first numberOfVertices:(GLsizei)count;&#123; glDrawArrays(mode, first, count);&#125; 重新缓存顶点数组1234567891011121314151617181920212223// 此方法加载由接收器存储的数据- (void)reinitWithAttribStride:(GLsizeiptr)aStride numberOfVertices:(GLsizei)count bytes:(const GLvoid *)dataPtr;&#123; NSParameterAssert(0 &lt; aStride); NSParameterAssert(0 &lt; count); NSParameterAssert(NULL != dataPtr); NSAssert(0 != name, @&quot;Invalid name&quot;); self.stride = aStride; self.bufferSizeBytes = aStride * count; // 第二步 glBindBuffer(GL_ARRAY_BUFFER, self.name); // 第三步 glBufferData( GL_ARRAY_BUFFER, bufferSizeBytes, dataPtr, GL_DYNAMIC_DRAW); &#125; ViewDidLoad新建opengles上下文及GLKView配置12345678910//1.新建OpenGL ES 上下文 self.mContext = [[EAGLContext alloc]initWithAPI:kEAGLRenderingAPIOpenGLES2]; //2.获取GLKView GLKView *view = (GLKView *)self.view; view.context = self.mContext; view.drawableColorFormat = GLKViewDrawableColorFormatRGBA8888; view.drawableDepthFormat = GLKViewDrawableDepthFormat24; [EAGLContext setCurrentContext:self.mContext]; 配置baseEffect光照信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//创建GLKBaseEffect 只能有3个光照、2个纹理self.baseEffect = [[GLKBaseEffect alloc]init];-(void)configureLight&#123; //1.是否开启light0光照 self.baseEffect.light0.enabled = GL_TRUE; /* union _GLKVector4 &#123; struct &#123; float x, y, z, w; &#125;; struct &#123; float r, g, b, a; &#125;; struct &#123; float s, t, p, q; &#125;; float v[4]; &#125; __attribute__((aligned(16))); typedef union _GLKVector4 GLKVector4; union共用体 有3个结构体， 比如表示顶点坐标的x,y,z,w 比如表示颜色的，RGBA; 表示纹理的stpq */ //2.设置漫射光颜色 self.baseEffect.light0.diffuseColor = GLKVector4Make( 1.0f,//Red 1.0f,//Green 1.0f,//Blue 1.0f);//Alpha /* The position of the light in world coordinates. 世界坐标中的光的位置。 If the w component of the position is 0.0, the light is calculated using the directional light formula. The x, y, and z components of the vector specify the direction the light shines. The light is assumed to be infinitely far away; attenuation and spotlight properties are ignored. 如果位置的w分量为0，则使用定向光公式计算光。向量的x、y和z分量指定光的方向。光被认为是无限远的，衰减和聚光灯属性被忽略。 If the w component of the position is a non-zero value, the coordinates specify the position of the light in homogenous coordinates, and the light is either calculated as a point light or a spotlight, depending on the value of the spotCutoff property. 如果该位置的W组件是一个非零的值，指定的坐标的光在齐次坐标的位置，和光是一个点光源和聚光灯计算，根据不同的spotcutoff属性的值 The default value is [0.0, 0.0, 1.0, 0.0]. 默认值[0.0f,0.0f,1.0f,0.0f]; */ self.baseEffect.light0.position = GLKVector4Make( 1.0f, //x 0.0f, //y 0.8f, //z 0.0f);//w //光的环境部分 self.baseEffect.light0.ambientColor = GLKVector4Make( 0.2f,//Red 0.2f,//Green 0.2f,//Blue 1.0f);//Alpha &#125; 设置模型矩阵,投影矩阵12345678//获取屏幕纵横比 GLfloat aspectRatio = self.view.bounds.size.width / self.view.bounds.size.height; //4.创建投影矩阵 -&gt; 透视投影 self.baseEffect.transform.projectionMatrix = GLKMatrix4MakeOrtho(-1.0 * aspectRatio, 1.0 * aspectRatio, -1.0, 1.0, 1.0, 120.0f); //5.设置模型矩阵 -5.0f表示往屏幕内移动-5.0f距离 self.baseEffect.transform.modelviewMatrix = GLKMatrix4MakeTranslation(0.0f, 0.0f, -5.0f); 处理顶点数据1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253-(void)bufferData&#123; //1、GLKMatrixStackCreate()创建一个新的空矩阵 self.modelViewMatrixStack = GLKMatrixStackCreate(kCFAllocatorDefault); //2、为将要缓存区数据开辟空间 //sphereVerts 在sphere.h文件中存在 /* 参数1：数据大小 3个GLFloat类型，x,y,z 参数2：有多少个数据，count 参数3：数据大小 参数4：用途 GL_STATIC_DRAW， */ //顶点数据缓存，顶点数据从sphere.h文件的sphereVerts数组中获取顶点数据x,y,z self.vertexPositionBuffer = [[AGLKVertexAttribArrayBuffer alloc]initWithAttribStride:(3 * sizeof(GLfloat)) numberOfVertices:sizeof(sphereVerts)/(3 * sizeof(GLfloat)) bytes:sphereVerts usage:GL_STATIC_DRAW]; //法线，光照坐标 sphereNormals数组 x,y,z self.vertexNormalBuffer = [[AGLKVertexAttribArrayBuffer alloc]initWithAttribStride:(3 * sizeof(GLfloat)) numberOfVertices:sizeof(sphereNormals)/(3 * sizeof(GLfloat)) bytes:sphereNormals usage:GL_STATIC_DRAW]; //纹理坐标 sphereTexCoords数组 x,y self.vertextTextureCoordBuffer = [[AGLKVertexAttribArrayBuffer alloc]initWithAttribStride:(2 * sizeof(GLfloat)) numberOfVertices:sizeof(sphereTexCoords)/ (2 * sizeof(GLfloat)) bytes:sphereTexCoords usage:GL_STATIC_DRAW]; //3.获取地球纹理 CGImageRef earthImageRef = [UIImage imageNamed:@&quot;Earth512x256.jpg&quot;].CGImage; //控制图像加载方式的选项 NSDictionary *earthOptions = [NSDictionary dictionaryWithObjectsAndKeys:[NSNumber numberWithBool:YES],GLKTextureLoaderOriginBottomLeft, nil]; //将纹理图片加载到纹理数据对象earchTextureInfo中 /* 参数1:加载的纹理图片 参数2:控制图像加载的方式的选项-字典 参数3:错误信息 */ self.earchTextureInfo = [GLKTextureLoader textureWithCGImage:earthImageRef options:earthOptions error:NULL]; //4.获取月亮纹理 CGImageRef moonImageRef = [UIImage imageNamed:@&quot;Moon256x128&quot;].CGImage; NSDictionary *moonOptions = [NSDictionary dictionaryWithObjectsAndKeys:[NSNumber numberWithBool:YES],GLKTextureLoaderOriginBottomLeft, nil]; self.moomTextureInfo = [GLKTextureLoader textureWithCGImage:moonImageRef options:moonOptions error:NULL]; //矩阵堆 //用所提供的矩阵替换最顶层矩阵,将self.baseEffect.transform.modelviewMatrix,替换self.modelViewMatrixStack GLKMatrixStackLoadMatrix4(self.modelViewMatrixStack, self.baseEffect.transform.modelviewMatrix); //初始化在轨道上月球位置 self.moonRotationAngleDegress = -20.0f; &#125; 渲染场景123456789101112131415161718192021222324252627282930313233343536373839#pragma mark - drawRect//渲染场景-(void)glkView:(GLKView *)view drawInRect:(CGRect)rect&#123; //设置清屏颜色 glClearColor(0.3f, 0.3f, 0.3f, 1.0f); //清空颜色缓存区和深度缓存区 glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); //地球旋转角度 _earthRotationAngleDegress += 360.0f/60.0f; //月球旋转角度 _moonRotationAngleDegress += (360.0f/60.0f)/SceneDaysPerMoonOrbit; //2、准备绘制 /* 其实就是把数据传递过去，然后指定读取方式 参数1：数据是做什么用的 参数2：数据读取个数 参数3：数据读取索引 参数4：是否调用glEnableVertexAttribArray 着色器能否读取到数据，由是否启用了对应的属性决定，这就是glEnableVertexAttribArray的功能，允许顶点着色器读取GPU（服务器端）数据。 默认情况下，出于性能考虑，所有顶点着色器的属性（Attribute）变量都是关闭的，意味着数据在着色器端是不可见的，哪怕数据已经上传到GPU，由glEnableVertexAttribArray启用指定属性，才可在顶点着色器中访问逐顶点的属性数据。glVertexAttribPointer或VBO只是建立CPU和GPU之间的逻辑连接，从而实现了CPU数据上传至GPU。但是，数据在GPU端是否可见，即，着色器能否读取到数据，由是否启用了对应的属性决定，这就是glEnableVertexAttribArray的功能，允许顶点着色器读取GPU（服务器端）数据。 那么，glEnableVertexAttribArray应该在glVertexAttribPointer之前还是之后调用？答案是都可以，只要在绘图调用（glDraw*系列函数）前调用即可。 */ [self.vertexPositionBuffer prepareToDrawWithAttrib:GLKVertexAttribPosition numberOfCoordinates:3 attribOffset:0 shouldEnable:YES]; [self.vertexNormalBuffer prepareToDrawWithAttrib:GLKVertexAttribNormal numberOfCoordinates:3 attribOffset:0 shouldEnable:YES]; [self.vertextTextureCoordBuffer prepareToDrawWithAttrib:GLKVertexAttribTexCoord0 numberOfCoordinates:2 attribOffset:0 shouldEnable:YES]; //3.开始绘制 [self drawEarth]; [self drawMoon]; &#125; 绘制地球123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869-(void)drawEarth&#123; //获取纹理的name、target self.baseEffect.texture2d0.name = self.earchTextureInfo.name; self.baseEffect.texture2d0.target = self.earchTextureInfo.target; /* current matrix: 1.000000 0.000000 0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000 -5.000000 1.000000 为什么？因为你在viewDidLoad中设置的 //5.设置模型矩形 -5.0f表示往屏幕内移动-5.0f距离 self.baseEffect.transform.modelviewMatrix = GLKMatrix4MakeTranslation(0.0f, 0.0f, -5.0f); */ //将当前的modelViewMatrixStack 压栈 GLKMatrixStackPush(self.modelViewMatrixStack); //在指定的轴上旋转最上面的矩阵。 GLKMatrixStackRotate(self.modelViewMatrixStack, GLKMathDegreesToRadians(SceneEarthAxialTiltDeg), 1.0f, 0.0f, 0.0f); /* current matrix: 1.000000 0.000000 0.000000 0.000000 0.000000 0.917060 0.398749 0.000000 0.000000 -0.398749 0.917060 0.000000 0.000000 0.000000 -5.000000 1.000000 为什么？ 将矩阵与围绕X旋转的旋转矩阵相乘，即可得上述结果 */ self.baseEffect.transform.modelviewMatrix = GLKMatrixStackGetMatrix4(self.modelViewMatrixStack); //准备绘制 [self.baseEffect prepareToDraw]; //调用AGLKVertexAttribArrayBuffer，绘制图形 /* 参数1：绘制的方式，三角形 参数2：绘制数据读取的索引 参数3：绘制数据的大小 */ [AGLKVertexAttribArrayBuffer drawPreparedArraysWithMode:GL_TRIANGLES startVertexIndex:0 numberOfVertices:sphereNumVerts]; //绘制完毕，则出栈 /* current matrix: 0.994522 0.041681 -0.095859 0.000000 0.000000 0.917060 0.398749 0.000000 0.104528 -0.396565 0.912036 0.000000 0.000000 0.000000 -5.000000 1.000000 */ GLKMatrixStackPop(self.modelViewMatrixStack); /* current matrix: 1.000000 0.000000 0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000 -5.000000 1.000000 */ self.baseEffect.transform.modelviewMatrix = GLKMatrixStackGetMatrix4(self.modelViewMatrixStack); &#125; 绘制月球12345678910111213141516171819202122232425262728293031-(void)drawMoon&#123; //获取纹理的name、target self.baseEffect.texture2d0.name = self.moomTextureInfo.name; self.baseEffect.texture2d0.target = self.moomTextureInfo.target; //压栈 GLKMatrixStackPush(self.modelViewMatrixStack); //围绕Y轴旋转moonRotationAngleDegress角度 //自转 GLKMatrixStackRotate(self.modelViewMatrixStack, GLKMathDegreesToRadians(self.moonRotationAngleDegress), 0.0f, 1.0f, 0.0f); //平移 -月球距离地球的距离 GLKMatrixStackTranslate(self.modelViewMatrixStack, 0.0f, 0.0f, SceneMoonDistanceFromEarth); //缩放，把月球缩放 GLKMatrixStackScale(self.modelViewMatrixStack, SceneMoonRadiusFractionOfEarth, SceneMoonRadiusFractionOfEarth, SceneMoonRadiusFractionOfEarth); //旋转 围绕Y轴旋转 GLKMatrixStackRotate(self.modelViewMatrixStack, GLKMathDegreesToRadians(self.moonRotationAngleDegress), 0.0f, 1.0f, 0.0f); self.baseEffect.transform.modelviewMatrix = GLKMatrixStackGetMatrix4(self.modelViewMatrixStack); [self.baseEffect prepareToDraw]; [AGLKVertexAttribArrayBuffer drawPreparedArraysWithMode:GL_TRIANGLES startVertexIndex:0 numberOfVertices:sphereNumVerts]; GLKMatrixStackPop(self.modelViewMatrixStack); self.baseEffect.transform.modelviewMatrix = GLKMatrixStackGetMatrix4(self.modelViewMatrixStack);&#125; 切换投影方法123456789101112131415161718#pragma mark -Switch Click//切换正投影效果或透视投影效果- (IBAction)switchClick:(UISwitch *)sender &#123; GLfloat aspect = self.view.bounds.size.width / self.view.bounds.size.height; if ([sender isOn]) &#123; //正投影 self.baseEffect.transform.projectionMatrix = GLKMatrix4MakeFrustum(-1.0 * aspect, 1.0 * aspect, -1.0, 1.0, 2.0, 120.0); &#125;else &#123; //透视投影 self.baseEffect.transform.projectionMatrix = GLKMatrix4MakeOrtho(-1.0 * aspect, 1.0 * aspect, -1.0, 1.0, 2.0, 120.0); &#125; &#125; 效果图","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/categories/学习笔记/"}],"tags":[{"name":"opengles","slug":"opengles","permalink":"http://yoursite.com/tags/opengles/"}]},{"title":"OpenGL ES - 画板案例实现","slug":"OpenGL ES-画板案例实现","date":"2019-03-18T10:38:37.000Z","updated":"2019-10-14T11:35:35.624Z","comments":true,"path":"2019/03/18/OpenGL ES-画板案例实现/","link":"","permalink":"http://yoursite.com/2019/03/18/OpenGL ES-画板案例实现/","excerpt":"思维导图","text":"思维导图 初始化View1234567891011121314151617181920212223242526272829303132333435363738394041-(id)initWithCoder:(NSCoder *)aDecoder&#123; if ((self = [super initWithCoder:aDecoder])) &#123; //初始化CAEAGLLayer CAEAGLLayer *eaglLayer = (CAEAGLLayer *)self.layer; //设置透明度 eaglLayer.opaque = YES; //设置eaglLayer描述属性 /* 1.kEAGLDrawablePropertyRetainedBacking 表示绘图表面显示后，是否保留其内容，通过一个NSNumber 包装一个bool值。如果是NO,表示 显示内容后，不能依赖于相同的内容；如果是YES，表示显示内容后不变，一般只有在需要内容保存不变的情况下才使用YES，设置为YES,会导致性能降低，内存使用量降低。一般设置为NO。 2.kEAGLDrawablePropertyColorFormat 表示绘制表面的内部颜色缓存区格式 */ eaglLayer.drawableProperties = [NSDictionary dictionaryWithObjectsAndKeys: [NSNumber numberWithBool:YES], kEAGLDrawablePropertyRetainedBacking, kEAGLColorFormatRGBA8, kEAGLDrawablePropertyColorFormat, nil]; //初始化上下文 context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES2]; //判断是否开辟成功以及设置到当前的Context if (!context || ![EAGLContext setCurrentContext:context]) &#123; return nil; &#125; //设置视图的比例因子 /* 比例因子决定视图中的内容如何从逻辑坐标空间（以点测量）映射到设备坐标空间（以像素为单位）。此值通常为1或2。更高比例的因素表明视图中的每一个点由底层的多个像素表示。例如，如果缩放因子为2，并且视图框大小为50×50点，则用于显示内容的位图的大小为100×100像素。 */ self.contentScaleFactor = [[UIScreen mainScreen] scale]; //是否需要清屏，默认等于YES needsErase = YES; &#125; return self;&#125; layoutSubviews12345678910111213141516171819202122-(void)layoutSubviews&#123; [EAGLContext setCurrentContext:context]; //判断是否初始化 if (!initialized) &#123; //如果没有初始化则对OpenGL初始化 initialized = [self initGL]; &#125; else &#123; //如果已经初始化则调整layer [self resizeFromLayer:(CAEAGLLayer*)self.layer]; &#125; // 清除帧第一次分配 if (needsErase) &#123; [self erase]; needsErase = NO; &#125; &#125; 若没有进行过初始化initialized 绘制”加油!” initGL1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980-(BOOL)initGL&#123; //生成标识一个帧缓存对象和颜色渲染 glGenFramebuffers(1, &amp;viewFrameBuffer); glGenRenderbuffers(1, &amp;viewRenderBuffer); //绑定viewFrameBuffer 和 viewRenderBuffer glBindFramebuffer(GL_FRAMEBUFFER, viewFrameBuffer); glBindRenderbuffer(GL_RENDERBUFFER, viewRenderBuffer); //绑定一个Drawable对象存储到一个OpenGL ES渲染缓存对象。 /* 创建一个渲染，可以呈现到屏幕上，你将渲染然后分配共享存储通过调用此方法。这个方法的调用替换通常给glrenderbufferstorage。缓存的存储分配了这个方法以后可以显示一个回调presentrenderbuffer： 为绘制缓冲区分配存储区，此处将CAEAGLLayer的绘制存储区作为绘制缓冲区的存储区 参数1：OpenGL ES的结合点为当前绑定的渲染。这个参数的值必须gl_renderbuffer（或gl_renderbuffer_oes在OpenGL ES 1.1语境） 参数2：对象管理数据存储区中的渲染。在iOS中，这个参数的值必须是一个CAEAGLLayer对象 */ [context renderbufferStorage:GL_RENDERBUFFER fromDrawable:(id&lt;EAGLDrawable&gt;)self.layer]; //将viewRenderBuffer 绑定到GL_COLOR_ATTACHMENT0 glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_RENDERBUFFER, viewRenderBuffer); //获取绘制缓存区的像素宽度 --将绘制缓存区像素宽度存储在backingWidth glGetRenderbufferParameteriv(GL_RENDERBUFFER, GL_RENDERBUFFER_WIDTH, &amp;backingWidth); //获取绘制缓存区的像素高度--将绘制缓存区像素高度存储在backingHeight glGetRenderbufferParameteriv(GL_RENDERBUFFER, GL_RENDERBUFFER_HEIGHT, &amp;backingHeight); //检查GL_FRAMEBUFFER缓存区状态 if (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE) &#123; NSLog(@&quot;Make complete framebuffer Object failed! %x&quot;,glCheckFramebufferStatus(GL_FRAMEBUFFER)); return NO; &#125; //设置视口 glViewport(0, 0, backingWidth, backingHeight); //创建顶点缓冲对象来保存我们的数据 glGenBuffers(1, &amp;vboId); //加载画笔纹理 brushTexture = [self textureFromName:@&quot;Particle.png&quot;]; //加载shade [self setupShaders]; //点模糊效果通过开启混合模式，并设置混合函数 glEnable(GL_BLEND); glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA); //回放录制的路径，这是“加油！” NSString *path = [[NSBundle mainBundle]pathForResource:@&quot;abc&quot; ofType:@&quot;string&quot;]; //将path 使用NSUTF8StringEncoding 编码 NSString *str = [NSString stringWithContentsOfFile:path encoding:NSUTF8StringEncoding error:nil]; //开辟数组空间-可变的 CCArr = [NSMutableArray array]; //根据abc.string文件，将绘制点的数据，json解析到数组 NSArray *jsonArr = [NSJSONSerialization JSONObjectWithData:[str dataUsingEncoding:NSUTF8StringEncoding] options:NSJSONReadingAllowFragments error:nil]; //遍历jsonArr数组，将数据转为CCPoint类型数据 for (NSDictionary *dict in jsonArr) &#123; CCPoint *point = [CCPoint new]; point.mX = [dict objectForKey:@&quot;mX&quot;]; point.mY = [dict objectForKey:@&quot;mY&quot;]; //将CCPoint 对象添加到CCArr数组 [CCArr addObject:point]; &#125; //调用绘制方法：绘制abc.string 绘制的加油字样，延时5秒绘制！ [self performSelector:@selector(paint) withObject:nil afterDelay:0.5]; return YES; &#125; 手写着色程序 vsh&amp;fsh vsh : 顶点着色器 123456789101112131415161718192021222324252627//顶点attribute vec4 inVertex;//矩阵uniform mat4 MVP;//点的大小uniform float pointSize;//点的颜色uniform lowp vec4 vertexColor;//输出颜色varying lowp vec4 color;void main()&#123; //顶点计算 = 矩阵 * 顶点 gl_Position = MVP * inVertex; //修改顶点大小 gl_PointSize = pointSize; // 1 * 3.0; //将通过uniform 传递进来的颜色,从顶点着色器程序传递到片元着色器 color = vertexColor;&#125; fsh : 片元着色器 12345678910111213141516//获取纹理uniform sampler2D texture;/* sampler2D,中的2D,表示这是一个2D纹理。我们也可以使用1D\\3D或者其他类型的采样器。我们总是 把这个值设置为0。来指示纹理单元0. *///获取从顶点程序传递过来的颜色//lowp,精度varying lowp vec4 color;void main()&#123; //将颜色和纹理组合 是相乘！！！！ gl_FragColor = color * texture2D(texture, gl_PointCoord);&#125; 加载shader即加载vsh和fsh123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147- (void)setupShaders&#123; for (int i = 0; i &lt; NUM_PROGRAMS; i++) &#123; //读取顶点着色程序 char *vsrc = readFile(pathForResource(program[i].vert)); char *fsrc = readFile(pathForResource(program[i].frag)); //将char-&gt;NSString 对象 NSString *vsrcStr = [[NSString alloc]initWithBytes:vsrc length:strlen(vsrc)-1 encoding:NSUTF8StringEncoding]; NSString *fsrcStr = [[NSString alloc]initWithBytes:fsrc length:strlen(fsrc)-1 encoding:NSUTF8StringEncoding]; //打印着色程序中的代码 NSLog(@\"vsrc:%@\",vsrcStr); NSLog(@\"fsrc:%@\",fsrcStr); //attribute GLsizei attribCt = 0; //创建字符串数组【1】 GLchar *attribUsed[NUM_ATTRIBS]; // GLint attrib[NUM_ATTRIBS]; //attribute 变量名称-inVertex(point.vsh） GLchar *attribName[NUM_ATTRIBS] = &#123; \"inVertex\", &#125;; //uniform变量名称 \"MVP\", \"pointSize\", \"vertexColor\", \"texture\", const GLchar *uniformName[NUM_UNIFORMS] = &#123; \"MVP\", \"pointSize\", \"vertexColor\", \"texture\", &#125;; //遍历attribute for (int j = 0; j &lt; NUM_ATTRIBS; j++) &#123; //strstr(str1,str2) 函数用于判断字符串str2是否是str1的子串。如果是，则该函数返回str2在str1中首次出现的地址；否则，返回NULL。 //判断，attribute 变量，是否存在顶点着色器程序中。point.vsh if (strstr(vsrc, attribName[j])) &#123; //attribute个数 attrib[attribCt] = j; //使用的attribute的名称 attribUsed[attribCt++] = attribName[j]; &#125; &#125; //利用shaderUtil.c封装好的方法对programe 进行创建、链接、生成Programe /* 参数1：vsrc,顶点着色器程序 参数2：fsrc,片元着色器程序 参数3：attribute变量个数 参数4：attribute变量名称 参数5：当前attribute位置 参数6：uniform名字 参数7：program的uniform地址 参数8：program程序地址 */ glueCreateProgram(vsrc, fsrc, attribCt, (const GLchar **)&amp;attribUsed[0], attrib, NUM_UNIFORMS, &amp;uniformName[0], program[i].uniform, &amp;program[i].id); //释放vsrc,fsrc指针 free(vsrc); free(fsrc); // 设置常数、初始化Uniform //当前的i == 0 if (i == PROGRAM_POINT) &#123; //使用proram program[0].id 等价，以往课程例子中的GLuint program; glUseProgram(program[PROGRAM_POINT].id); //为当前程序对象指定uniform变量值 /* 为当前程序对象指定uniform变量MVP赋值 void glUniform1f(GLint location, GLfloat v0); 参数1:location，指明要更改的uniform变量的位置 MVP 参数2：v0,指明在指定的uniform变量中要使用的新值 program[0].uniform[3] = 0 等价于，vsh顶点着色器程序中的uniform变量，MVP = 0; 其实简单理解就是做了一次初始化，清空这个mat4矩阵 */ glUniform1i(program[PROGRAM_POINT].uniform[UNIFORM_TEXTURE], 0); // 投影矩阵 /* 投影分为正射投影和透视投影，我们可以通过它来设置投影矩阵来设置视域，在OpenGL中，默认的投影矩阵是一个立方体，即x y z 分别是-1.0~1.0的距离，如果超出该区域，将不会被显示 正射投影(orthographic projection)：GLKMatrix4MakeOrtho(float left, float righ, float bottom, float top, float nearZ, float farZ)，该函数返回一个正射投影的矩阵，它定义了一个由 left、right、bottom、top、near、far 所界定的一个矩形视域。此时，视点与每个位置之间的距离对于投影将毫无影响。 透视投影(perspective projection)：GLKMatrix4MakeFrustum(float left, float right,float bottom, float top, float nearZ, float farZ)，该函数返回一个透视投影的矩阵，它定义了一个由 left、right、bottom、top、near、far 所界定的一个平截头体(椎体切去顶端之后的形状)视域。此时，视点与每个位置之间的距离越远，对象越小。 在平面上绘制，只需要使正投影就可以了！！ */ GLKMatrix4 projectionMatrix = GLKMatrix4MakeOrtho(0, backingWidth, 0, backingHeight, -1, 1); //模型矩阵，比如你要平移、旋转、缩放，就可以设置在模型矩阵上 //这里不需要这些变换，则使用单元矩阵即可，相当于1 * ？ = ？ GLKMatrix4 modelViewMatrix = GLKMatrix4Identity; //矩阵相乘，就2个矩阵的结果交给MVPMatrix GLKMatrix4 MVPMatrix = GLKMatrix4Multiply(projectionMatrix, modelViewMatrix); /* void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value); 功能：为当前程序对象指定uniform变量值 参数1：location 指明要更改的uniform变量的位置 MVP 参数2：count 指定将要被修改的矩阵的数量 参数3：transpose 矩阵的值被载入变量时，是否要对矩阵进行变换，比如转置！ 参数4：value ，指向将要用于更新uniform变量MVP的数组指针 */ glUniformMatrix4fv(program[PROGRAM_POINT].uniform[UNIFORM_MVP], 1, GL_FALSE, MVPMatrix.m); //点的大小 pointSize /* 为当前程序对象指定uniform变量pointSize赋值 program[0].uniform[pointSize] = 纹理宽度/画笔比例 */ glUniform1f(program[PROGRAM_POINT].uniform[UNIFORM_POINT_SIZE], brushTexture.width / kBrushScale); //笔刷颜色 /* 为当前程序对象指定uniform变量vertexColor赋值 program[0].uniform[vertexColor] = 画笔颜色 void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value); 功能：为当前程序对象指定uniform变量值 参数1：location 指明要更改的uniform变量的位置 vertexColor 参数2：count 指定将要被修改的4分量的数量 参数3：value ，指向将要用于更新uniform变量vertexColor的值 */ glUniform4fv(program[PROGRAM_POINT].uniform[UNIFORM_VERTEX_COLOR], 1, brushColor); &#125; &#125; glError(); &#125; 加载画笔纹理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102// 创建一个纹理图片- (textureInfo_t)textureFromName:(NSString *)name&#123; CGImageRef brushImage; CGContextRef brushContext; GLubyte *brushData; size_t width,height; GLuint texId; textureInfo_t texture; //首先建立在图像文件的数据一个UIImage对象，然后提取核心图形图像 brushImage = [UIImage imageNamed:name].CGImage; //获取图片的宽和高 width = CGImageGetWidth(brushImage); height = CGImageGetHeight(brushImage); //分配位图上下文所需的内存 brushData = (GLubyte *)calloc(width * height * 4, sizeof(GLubyte)); //使用Core Graphics框架提供的bitmatp创造功能。 /* CGContextRef CGBitmapContextCreate( void * data, size_t width, size_t height, size_t bitsPerComponent, size_t bytesPerRow, CGColorSpaceRef cg_nullable space, uint32_t bitmapInfo); Quartz创建一个位图绘制环境，也就是位图上下文。 参数1：data,要渲染的绘制内容的地址 参数2：位图的宽 参数3：位图的高 参数4：内存中像素的每个组件的位数，比如32位像素格式和RGB颜色空间。一般设置为8 参数5：位图每一行占有比特数 参数5：颜色空间，通过CGImageGetColorSpace(图片）获取颜色空间 参数6：颜色通道，RGBA = kCGImageAlphaPremultipliedLast */ brushContext = CGBitmapContextCreate(brushData, width, height, 8, width * 4, CGImageGetColorSpace(brushImage), kCGImageAlphaPremultipliedLast); //创建完context之后，可以在context上绘制图片 /* void CGContextDrawImage(CGContextRef c, CGRect rect, CGImageRef image); 参数1：位图上下文 参数2：绘制的frame 参数3：绘制的图片 */ CGContextDrawImage(brushContext, CGRectMake(0.0, 0.0f, (CGFloat)width, (CGFloat)height), brushImage); //接下来将不需要上下文，因此需要释放它以避免内存泄漏 CGContextRelease(brushContext); //使用OpenGL ES生成纹理 /* 生成纹理的函数 glGenTextures (GLsizei n, GLuint* textures) 参数1：n,生成纹理个数 参数2：存储纹理索引的第一个元素指针 */ glGenTextures(1, &amp;texId); //绑定纹理名称 允许建立一个绑定到目标纹理的有名称的纹理。 glBindTexture(GL_TEXTURE_2D, texId); //设置纹理参数使用缩小滤波器和线性滤波器（加权平均）--设置纹理属性 glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); //指定2D纹理图像，为内存中的图像数据提供一个指针。 /* 功能：生成2D纹理 glTexImage2D (GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid* pixels)； 参数1：target,纹理目标，因为你使用的是glTexImage2D函数，所以必须设置为GL_TEXTURE_2D 参数2：level,0，基本图像级别 参数3：internalformat，颜色组件；GL_RGBA，GL_ALPHA，GL_RGBA 参数4：width,纹理图像的宽度 参数5：height,纹理图像的高度 参数6：border,纹理边框的宽度,必须为0 参数7：format,像素数据的颜色格式，可不与internalformat一致，可参考internalformat的值 参数8：type,像素数据类型，GL_UNSIGNED_BYTE 参数9：pixels，内存中指向图像数据的指针 */ glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, (int)width, (int)height, 0, GL_RGBA, GL_UNSIGNED_BYTE, brushData); //生成纹理之后，即可释放brushData数据 free(brushData); //补充自己定义的texture结构体中的内容 //纹理 texture.id = texId; //纹理宽度 texture.width = (int)width; //纹理高度 texture.height = (int)height; //返回纹理对象数据 return texture;&#125; 绘制已存储顶点数据的”加油”1234567891011121314151617181920212223242526272829-(void)paint&#123; //从0开始遍历顶点，步长为2 /* 为什么步长等于2? p1,p2,开始点，结束点！ */ for (int i = 0; i &lt; CCArr.count - 1; i+= 2) &#123; //从CCArr数组中读取顶点 cp1,cp2 CCPoint *cp1 = CCArr[i]; CCPoint *cp2 = CCArr[i + 1]; //将CCPoint对象 -&gt; CGPoint对象 CGPoint p1,p2; p1.x = cp1.mX.floatValue; p2.x = cp2.mX.floatValue; p1.y = cp1.mY.floatValue; p2.y = cp2.mY.floatValue; //在用户触摸的地方绘制屏幕上的线条 [self renderLineFromPoint:p1 toPoint:p2]; &#125; &#125; 在两点之间绘制线条123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115//在用户触摸的地方绘制屏幕上的线条-(void)renderLineFromPoint:(CGPoint)start toPoint:(CGPoint)end&#123; //顶点缓存区 static GLfloat *vertexBuffer = NULL; //顶点Max(暂时) static NSUInteger vertexMax = 64; //顶点个数 NSUInteger vertexCount = 0,count; //从点到像素转换 //视图的比例因子 CGFloat scale = self.contentScaleFactor; //将每个顶点与scale 因子相乘 start.x *= scale; start.y *= scale; end.x *= scale; end.y *= scale; //开辟数组缓存区 if (vertexBuffer == NULL) &#123; //开辟顶点地址空间 vertexBuffer = malloc(vertexMax * 2 * sizeof(GLfloat)); &#125; /* 通过把起点到终点的轨迹分解成若干个点，分别来绘制每个点，从而达到线的效果 ceilf（）向上取整。不是四舍五入，而是判断后面有小数，去掉小数部分，整数部分加1. 如：123.456 =&gt; 124 123.001 =&gt; 124 */ //向缓冲区添加点，所以每个像素都有绘图点 //求得start 和 end 2点间的距离 float seq = sqrtf((end.x - start.x) * (end.x - start.x) + (end.y - start.y) * (end.y - start.y)); /* 向上取整，求得距离要产生多少个点？ kBrushPixelStep,画笔像素步长 修改kBrushPixelStep 的值，越大，笔触越细；越小，笔触越粗！ */ NSInteger pointCount = ceilf(seq / kBrushPixelStep); //比较pointCount 是不是大于1，如果小于1,则count = 1,否则count = pointCount; count = MAX(pointCount, 1); //NSLog(@\"Count = %ld\",count); for (int i = 0; i &lt; count; i++) &#123; //判断如果顶点数 &gt; 设置顶点Max if (vertexCount == vertexMax) &#123; //修改vertexMax 2倍增长 vertexMax = 2 *vertexMax; //增加空间开辟 vertexBuffer = realloc(vertexBuffer, vertexMax * 2 *sizeof(GLfloat)); &#125; //修改vertexBuffer数组的值 //将start 和 end 距离之间，计算出count个点，并存储在vertexBuffer数组中 //x = start.x + (end.x - start.x) * (i/count); //y = start.y + (end.y - start.y) * (i/count); //vertexBuffer[0]-&gt;x vertexBuffer[2 * vertexCount + 0] = start.x + (end.x - start.x) * ((GLfloat)i/(GLfloat)count); //vertextBuffer[1]-&gt;y vertexBuffer[2 * vertexCount + 1] = start.y + (end.y - start.y) * ((GLfloat)i/(GLfloat)count); /* NSLog(@\"X:%f\",vertexBuffer[2 * vertexCount]); NSLog(@\"Y:%f\",vertexBuffer[2 * vertexCount + 1]); */ //vertexCount 自增1 vertexCount += 1; &#125; //加载数据到vertex Buffer对象中 glBindBuffer(GL_ARRAY_BUFFER, vboId); //将cpu存储的顶点数据-&gt;GPU中 复制顶点数组到缓冲中提供给OpenGL使用 glBufferData(GL_ARRAY_BUFFER, vertexCount * 2 * sizeof(GLfloat), vertexBuffer, GL_DYNAMIC_DRAW); /* 链接顶点属性 glEnableVertexAttribArray启用指定属性，才可在顶点着色器中访问逐顶点的属性数据 参考课件：二、链接顶点属性 */ glEnableVertexAttribArray(ATTRIB_VERTEX); glVertexAttribPointer(ATTRIB_VERTEX, 2, GL_FLOAT, GL_FALSE, 2*sizeof(GLfloat), 0); //绘制 //使用刚刚创建的program[0].id的program glUseProgram(program[PROGRAM_POINT].id); /* 根据顶点绘制图形， 参数1：绘制模型 连接线段，参考视觉班第一节课的课件 参数2：起始点，0 参数3：顶点个数 */ glDrawArrays(GL_POINTS, 0, (int)vertexCount); //显示buffer glBindRenderbuffer(GL_RENDERBUFFER, viewRenderBuffer); [context presentRenderbuffer:GL_RENDERBUFFER]; &#125; 已经进行过初始化调整图层123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//调整图层- (BOOL)resizeFromLayer:(CAEAGLLayer *)layer&#123; //根据当前图层大小分配颜色缓冲区 glBindRenderbuffer(GL_RENDERBUFFER, viewRenderBuffer); //绑定一个Drawable对象存储到一个OpenGL ES渲染缓存对象。 /* 创建一个渲染，可以呈现到屏幕上，你将渲染然后分配共享存储通过调用此方法。这个方法的调用替换通常给glrenderbufferstorage。缓存的存储分配了这个方法以后可以显示一个回调presentrenderbuffer： - (BOOL)renderbufferStorage:(NSUInteger)target fromDrawable:(id&lt;EAGLDrawable&gt;)drawable; 为绘制缓冲区分配存储区，此处将CAEAGLLayer的绘制存储区作为绘制缓冲区的存储区 参数1：OpenGL ES的结合点为当前绑定的渲染。这个参数的值必须gl_renderbuffer（或gl_renderbuffer_oes在OpenGL ES 1.1语境） 参数2：对象管理数据存储区中的渲染。在iOS中，这个参数的值必须是一个CAEAGLLayer对象 */ [context renderbufferStorage:GL_RENDERBUFFER fromDrawable:layer]; ////获取绘制缓存区的像素宽度 --将绘制缓存区像素宽度存储在backingWidth glGetRenderbufferParameteriv(GL_RENDERBUFFER,GL_RENDERBUFFER_WIDTH, &amp;backingWidth); ////获取绘制缓存区的像素高度--将绘制缓存区像素高度存储在backingHeight glGetRenderbufferParameteriv(GL_RENDERBUFFER, GL_RENDERBUFFER_HEIGHT, &amp;backingHeight); //检查GL_FRAMEBUFFER缓存区状态 if (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE) &#123; NSLog(@\"Make compelete framebuffer object failed!%x\",glCheckFramebufferStatus(GL_FRAMEBUFFER)); return NO; &#125; //更新投影矩阵、模型视图矩阵 // 投影矩阵 /* 投影分为正射投影和透视投影，我们可以通过它来设置投影矩阵来设置视域，在OpenGL中，默认的投影矩阵是一个立方体，即x y z 分别是-1.0~1.0的距离，如果超出该区域，将不会被显示 正射投影(orthographic projection)：GLKMatrix4MakeOrtho(float left, float righ, float bottom, float top, float nearZ, float farZ)，该函数返回一个正射投影的矩阵，它定义了一个由 left、right、bottom、top、near、far 所界定的一个矩形视域。此时，视点与每个位置之间的距离对于投影将毫无影响。 透视投影(perspective projection)：GLKMatrix4MakeFrustum(float left, float right,float bottom, float top, float nearZ, float farZ)，该函数返回一个透视投影的矩阵，它定义了一个由 left、right、bottom、top、near、far 所界定的一个平截头体(椎体切去顶端之后的形状)视域。此时，视点与每个位置之间的距离越远，对象越小。 在平面上绘制，只需要使正投影就可以了！！ */ GLKMatrix4 projectionMatrix = GLKMatrix4MakeOrtho(0, backingWidth, 0, backingHeight, -1, 1); // //模型矩阵，比如你要平移、旋转、缩放，就可以设置在模型矩阵上 //这里不需要这些变换，则使用单元矩阵即可，相当于1 * ？ = ？ GLKMatrix4 modelViewMatrix = GLKMatrix4Identity; //矩阵相乘，就2个矩阵的结果交给MVPMatrix GLKMatrix4 MVPMatrix = GLKMatrix4Multiply(projectionMatrix, modelViewMatrix); /* void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value); 功能：为当前程序对象指定uniform变量值 参数1：location 指明要更改的uniform变量的位置 MVP 参数2：count 指定将要被修改的矩阵的数量 参数3：transpose 矩阵的值被载入变量时，是否要对矩阵进行变换，比如转置！ 参数4：value ，指向将要用于更新uniform变量MVP的数组指针 */ glUniformMatrix4fv(program[PROGRAM_POINT].uniform[UNIFORM_MVP], 1, GL_FALSE, MVPMatrix.m); //更新视口 glViewport(0, 0, backingWidth, backingHeight); return YES; &#125; 修改画笔颜色1234567891011121314151617181920212223- (void)setBrushColorWithRed:(CGFloat)red green:(CGFloat)green blue:(CGFloat)blue&#123; //更新画笔颜色 颜色 * 透明度 brushColor[0] = red * kBrushOpacity; brushColor[1] = green * kBrushOpacity; brushColor[2] = green * kBrushOpacity; brushColor[3] = kBrushOpacity; NSLog(@\"%f,%f,%f,%f\",brushColor[0],brushColor[1],brushColor[2],brushColor[3]); NSLog(@\"%f,%f,%f\",red,green,blue); //释放初始化 if (initialized) &#123; //使用program[0].id glUseProgram(program[PROGRAM_POINT].id); //将颜色值brushColor 传递到 vertexColor中 glUniform4fv(program[PROGRAM_POINT].uniform[UNIFORM_VERTEX_COLOR], 1, brushColor); &#125; &#125; 清理屏幕1234567891011121314//清空屏幕-(void)erase&#123; //clear frameBuffer glBindFramebuffer(GL_FRAMEBUFFER, viewFrameBuffer); glClearColor(0.0f, 0.0f, 0.0f, 1.0f); glClear(GL_COLOR_BUFFER_BIT); //显示缓存区 glBindRenderbuffer(GL_RENDERBUFFER, viewRenderBuffer); [context presentRenderbuffer:GL_RENDERBUFFER]; &#125; 开始绘制绘制任意图形,线条123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#pragma mark -- Touch Click//点击屏幕开始-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; //获取绘制的bounds CGRect bounds = [self bounds]; //获取当前的点击touch UITouch* touch = [[event touchesForView:self] anyObject]; //设置为firstTouch -&gt; yes firstTouch = YES; //获取当前点击的位置信息，x,y _location = [touch locationInView:self]; //y = height - y _location.y = bounds.size.height - _location.y; &#125;-(void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; CGRect bounds = [self bounds]; UITouch *touch = [[event touchesForView:self]anyObject]; //第一次点击 if (firstTouch) &#123; //将firstTouch状态改为NO firstTouch = NO; //_previousLocation = 获取上一个顶点 _previousLocation = [touch previousLocationInView:self]; _previousLocation.y = bounds.size.height - _previousLocation.y; &#125;else &#123; _location = [touch locationInView:self]; _location.y = bounds.size.height - _location.y; _previousLocation = [touch previousLocationInView:self]; _previousLocation.y = bounds.size.height - _previousLocation.y; &#125; //获取_previousLocation 和 _location 2个顶点，绘制成线条 [self renderLineFromPoint:_previousLocation toPoint:_location];&#125;-(void)touchesEnded:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; CGRect bounds = [self bounds]; UITouch *touch = [[event touchesForView:self]anyObject]; //判断是否为第一次触碰 if (firstTouch) &#123; firstTouch = NO; _previousLocation = [touch previousLocationInView:self]; _previousLocation.y = bounds.size.height - _previousLocation.y; [self renderLineFromPoint:_previousLocation toPoint:_location]; &#125; &#125;-(void)touchesCancelled:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; NSLog(@\"Touch Cancelled\"); &#125;-(BOOL)canBecomeFirstResponder&#123; return YES;&#125; 效果初始化","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/categories/学习笔记/"}],"tags":[{"name":"opengles","slug":"opengles","permalink":"http://yoursite.com/tags/opengles/"},{"name":"glsl","slug":"glsl","permalink":"http://yoursite.com/tags/glsl/"}]},{"title":"GLSL语言基础","slug":"GLSL语言基础","date":"2019-03-11T02:38:37.000Z","updated":"2019-03-11T03:11:27.658Z","comments":true,"path":"2019/03/11/GLSL语言基础/","link":"","permalink":"http://yoursite.com/2019/03/11/GLSL语言基础/","excerpt":"","text":"基本数据类型 存储修饰符 精度修饰符","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/categories/学习笔记/"}],"tags":[{"name":"opengl","slug":"opengl","permalink":"http://yoursite.com/tags/opengl/"},{"name":"opengles","slug":"opengles","permalink":"http://yoursite.com/tags/opengles/"},{"name":"glsl","slug":"glsl","permalink":"http://yoursite.com/tags/glsl/"}]},{"title":"OpenGL ES 渲染立体图像(GLKit)","slug":"OpenGL ES 渲染立体图像(GLKit)","date":"2019-03-08T04:38:37.000Z","updated":"2019-03-08T04:14:57.887Z","comments":true,"path":"2019/03/08/OpenGL ES 渲染立体图像(GLKit)/","link":"","permalink":"http://yoursite.com/2019/03/08/OpenGL ES 渲染立体图像(GLKit)/","excerpt":"使用苹果封装的OpenGLES类GLKit, 可以省下不少代码, 以实现图像的矩阵变换(平移/旋转/缩放)","text":"使用苹果封装的OpenGLES类GLKit, 可以省下不少代码, 以实现图像的矩阵变换(平移/旋转/缩放) 1234567891011- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view. //1.新建图层 [self setupContext]; //2.渲染图形 [self render]; &#125; 新建图层1234567891011121314151617-(void)setupContext&#123; //1.新建OpenGL ES 上下文 self.mContext = [[EAGLContext alloc]initWithAPI:kEAGLRenderingAPIOpenGLES2]; //2.GLKView GLKView *view = (GLKView *)self.view; view.context = self.mContext; view.drawableColorFormat = GLKViewDrawableColorFormatRGBA8888; view.drawableDepthFormat = GLKViewDrawableDepthFormat24; [EAGLContext setCurrentContext:self.mContext]; glEnable(GL_DEPTH_TEST); &#125; 渲染图像123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146-(void)render&#123; //1.顶点数据 //1.顶点数据 //前3个元素，是顶点数据xyz；中间3个元素，是顶点颜色值rgb，最后2个是纹理坐标st GLfloat attrArr[] = &#123; -0.5f, 0.5f, 0.0f, 0.0f, 0.0f, 0.5f, 0.0f, 1.0f,//左上 0.5f, 0.5f, 0.0f, 0.0f, 0.5f, 0.0f, 1.0f, 1.0f,//右上 -0.5f, -0.5f, 0.0f, 0.5f, 0.0f, 1.0f, 0.0f, 0.0f,//左下 0.5f, -0.5f, 0.0f, 0.0f, 0.0f, 0.5f, 1.0f, 0.0f,//右下 0.0f, 0.0f, 1.0f, 1.0f, 1.0f, 1.0f, 0.5f, 0.5f,//顶点 &#125;; //2.绘图索引 GLuint indices[] = &#123; 0, 3, 2, 0, 1, 3, 0, 2, 4, 0, 4, 1, 2, 3, 4, 1, 4, 3, &#125;; //3.顶点的个数 self.count = sizeof(indices)/sizeof(GLuint); //4.将顶点数组放入缓存区内--?GL_ARRAY_BUFFER GLuint buffer; glGenBuffers(1, &amp;buffer); glBindBuffer(GL_ARRAY_BUFFER, buffer); glBufferData(GL_ARRAY_BUFFER, sizeof(attrArr), attrArr, GL_STATIC_DRAW); //5.将索引数组放入缓存区 GLuint index; glGenBuffers(1, &amp;index); glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, index); glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW); //6.使用顶点数据 glEnableVertexAttribArray(GLKVertexAttribPosition); glVertexAttribPointer(GLKVertexAttribPosition, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(GLfloat), NULL); //7.颜色数据 glEnableVertexAttribArray(GLKVertexAttribColor); glVertexAttribPointer(GLKVertexAttribColor, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(GLfloat),(GLfloat *)NULL + 3); //8.纹理数据 glEnableVertexAttribArray(GLKVertexAttribTexCoord0); glVertexAttribPointer(GLKVertexAttribTexCoord0, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(GLfloat),(GLfloat *)NULL + 6); //9.获取纹理数据 //思维导图 //存储路径 NSString *filePath = [[NSBundle mainBundle]pathForResource:@\"cTest\" ofType:@\"jpg\"]; //设置纹理的读取参数 NSDictionary *options = [NSDictionary dictionaryWithObjectsAndKeys:@\"1\",GLKTextureLoaderOriginBottomLeft, nil]; //通过GLKTextureInfo 加载纹理 GLKTextureInfo *textureInfo = [GLKTextureLoader textureWithContentsOfFile:filePath options:options error:nil]; //10 效果 self.mEffect = [[GLKBaseEffect alloc]init]; self.mEffect.texture2d0.enabled = GL_TRUE; self.mEffect.texture2d0.name = textureInfo.name; //11.设置透视投影 CGSize size = self.view.bounds.size; //纵横比 float aspect = fabs(size.width / size.height); GLKMatrix4 projectionMatrix = GLKMatrix4MakePerspective(GLKMathDegreesToRadians(90.0), aspect, 0.1f, 10.0f); projectionMatrix = GLKMatrix4Scale(projectionMatrix, 1.0f, 1.0f, 1.0f); self.mEffect.transform.projectionMatrix = projectionMatrix; //12.模型视图变换 //往屏幕深度上移动了-2.0个距离 GLKMatrix4 modelViewMatrix = GLKMatrix4Translate(GLKMatrix4Identity, 0.0f, 0.0f, -2.0f); self.mEffect.transform.modelviewMatrix = modelViewMatrix; //13.定时器 //GCD开启 double seconds = 0.1; timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_main_queue()); dispatch_source_set_timer(timer, DISPATCH_TIME_NOW, seconds * NSEC_PER_SEC, 0.0f); dispatch_source_set_event_handler(timer, ^&#123; self.xDegree += 0.1f * self.XB; self.yDegree += 0.1f * self.YB; self.zDegree += 0.1f * self.ZB; &#125;); dispatch_resume(timer); &#125;#pragma mark - GLKView Delegate-(void)update&#123; //更新 GLKMatrix4 modelViewMatrix = GLKMatrix4Translate(GLKMatrix4Identity, 0.0f, 0.0f, -2.0f); modelViewMatrix = GLKMatrix4RotateX(modelViewMatrix, _xDegree); modelViewMatrix = GLKMatrix4RotateY(modelViewMatrix, _yDegree); modelViewMatrix = GLKMatrix4RotateZ(modelViewMatrix, _zDegree); self.mEffect.transform.modelviewMatrix = modelViewMatrix; &#125;-(void)glkView:(GLKView *)view drawInRect:(CGRect)rect&#123; glClearColor(0.3f, 0.3f, 0.3f, 1.0f); glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); //准备绘制 [self.mEffect prepareToDraw]; //索引绘制 glDrawElements(GL_TRIANGLES, self.count, GL_UNSIGNED_INT, 0); &#125;#pragma mark --Button Click- (IBAction)XClick:(id)sender &#123; _XB = !_XB; &#125;- (IBAction)YClick:(id)sender &#123; _YB = !_YB;&#125;- (IBAction)ZClick:(id)sender &#123; _ZB = !_ZB;&#125; 效果","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/categories/学习笔记/"}],"tags":[{"name":"opengles","slug":"opengles","permalink":"http://yoursite.com/tags/opengles/"},{"name":"GLKit","slug":"GLKit","permalink":"http://yoursite.com/tags/GLKit/"}]},{"title":"OpenGL ES 渲染立体图像(GLSL)","slug":"OpenGL ES 渲染立体图像(GLSL)","date":"2019-03-08T03:38:37.000Z","updated":"2019-03-08T04:20:44.576Z","comments":true,"path":"2019/03/08/OpenGL ES 渲染立体图像(GLSL)/","link":"","permalink":"http://yoursite.com/2019/03/08/OpenGL ES 渲染立体图像(GLSL)/","excerpt":"几何处理阶段几何阶段主要负责大部分多边形操作和顶点操作，包括顶点着色、坐标变换、生成图元、投影、裁剪、屏幕映射等过程，其中顶点着色、坐标变换由顶点着色器完成","text":"几何处理阶段几何阶段主要负责大部分多边形操作和顶点操作，包括顶点着色、坐标变换、生成图元、投影、裁剪、屏幕映射等过程，其中顶点着色、坐标变换由顶点着色器完成 顶点着色器 生成图元 投影 裁切 屏幕映射 顶点着色器完成顶点着色、坐标变换 生成图元 索引数组:{1,2,3}{3,2,4}{4,2,7}{7,2,5}等等… 投影 裁剪仅保留视景体内部的图元进行渲染 屏幕映射这个阶段是不可配置也不可编程的。主要用来实现图元的坐标转换到屏幕坐标 三维坐标转变为二维屏幕坐标的过程 MC : 建模坐标系 WC : 世界坐标系 VC : 观察坐标系 PC : 投影坐标系 NPC : 规格化投影坐标系 DC : 设备坐标系 坐标系详细概念世界坐标系 : 坐标系统主要⽤用于计算机图形场景中的所有图形对象的空间定位和定义局部坐标系 : 独立于世界坐标系来定义物体几何特性观察坐标系 : 观察坐标系通常是以视点的位置为原点，通过用户指定的一个向上的观察向量来定义整个坐标系统，观察坐标系主要⽤于从观察者的角度对整个世界坐标系内的对象进行重新定位和描述，从而简化几何物体在投影面的成像的数学推导和计算投影坐标系 : 物体从世界坐标描述转换到观察坐标后，可将三维物体投影到二维表⾯上，即投影到虚拟摄像机的胶片上，这个过程就是投影变换。以胶片中心为参考原点的空间坐标系称为投影坐标系，物体在投影坐标系中的坐标称为投影坐标。设备坐标系 : 是图形设备上采用的与具体设备相关的坐标系。设备坐标系⼀般采⽤整数坐标，其坐标范围由具体设备的分辨率决定。设备坐标系上的一个点一般对应图形设备上的一个像素。由于具体设备的限制，设备坐标系的坐标范围一般是有限的规格化投影坐标系 : 是为了避免设备相关性⽽定义的⼀种虚拟的设备坐标系。规格化坐标系的坐标范围一般从0到1，也有的是从-1到+1。采⽤规格化设备坐标系的好处是屏蔽了具体设备的分辨率，使得图形处理能够尽量避开对具体设备坐标的考虑。实际图形处理时，先将世界坐标转换成对应的规格化设备坐标，然后再将规格化设备坐标映射到具体的设备坐标上去屏幕坐标系统 : 也称设备坐标系统，它主要用于某一特殊的计算机图形显示设备(如光栅显示器)的表面的点的定义，在多数情况下，对于每⼀个具体的显示设备，都有一个单独的坐标系统，在定义了成像窗口的情况下，可进一步在屏幕坐标系统中定义称为视图区(view port)的有界区域，视图区中的成像即为实际所观察到的。 平移变换 缩放变换 索引绘图 关键代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216-(void)render&#123; //清屏颜色 glClearColor(0, 0.0, 0, 1.0); glClear(GL_COLOR_BUFFER_BIT); CGFloat scale = [[UIScreen mainScreen] scale]; //设置视口 glViewport(self.frame.origin.x * scale, self.frame.origin.y * scale, self.frame.size.width * scale, self.frame.size.height * scale); //获取顶点着色程序、片元着色器程序文件位置 NSString* vertFile = [[NSBundle mainBundle] pathForResource:@\"shaderv\" ofType:@\"glsl\"]; NSString* fragFile = [[NSBundle mainBundle] pathForResource:@\"shaderf\" ofType:@\"glsl\"]; //判断self.myProgram是否存在，存在则清空其文件 if (self.myProgram) &#123; glDeleteProgram(self.myProgram); self.myProgram = 0; &#125; //加载程序到myProgram中来。 self.myProgram = [self loadShader:vertFile frag:fragFile]; //4.链接 glLinkProgram(self.myProgram); GLint linkSuccess; //获取链接状态 glGetProgramiv(self.myProgram, GL_LINK_STATUS, &amp;linkSuccess); if (linkSuccess == GL_FALSE) &#123; GLchar messages[256]; glGetProgramInfoLog(self.myProgram, sizeof(messages), 0, &amp;messages[0]); NSString *messageString = [NSString stringWithUTF8String:messages]; NSLog(@\"error%@\", messageString); return ; &#125;else &#123; glUseProgram(self.myProgram); &#125; //创建绘制索引数组 GLuint indices[] = &#123; 0, 3, 2, 0, 1, 3, 0, 2, 4, 0, 4, 1, 2, 3, 4, 1, 4, 3, &#125;; //判断顶点缓存区是否为空，如果为空则申请一个缓存区标识符 if (self.myVertices == 0) &#123; glGenBuffers(1, &amp;_myVertices); &#125; //顶点数组 //前3顶点值（x,y,z），后3位颜色值(RGB) GLfloat attrArr[] = &#123; -0.5f, 0.5f, 0.0f, 1.0f, 0.0f, 1.0f, //左上 0.5f, 0.5f, 0.0f, 1.0f, 0.0f, 1.0f, //右上 -0.5f, -0.5f, 0.0f, 1.0f, 1.0f, 1.0f, //左下 0.5f, -0.5f, 0.0f, 1.0f, 1.0f, 1.0f, //右下 0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, //顶点 &#125;; //-----处理顶点数据------- //将_myVertices绑定到GL_ARRAY_BUFFER标识符上 glBindBuffer(GL_ARRAY_BUFFER, _myVertices); //把顶点数据从CPU内存复制到GPU上 glBufferData(GL_ARRAY_BUFFER, sizeof(attrArr), attrArr, GL_DYNAMIC_DRAW); //将顶点数据通过myPrograme中的传递到顶点着色程序的position //1.glGetAttribLocation,用来获取vertex attribute的入口的.2.告诉OpenGL ES,通过glEnableVertexAttribArray，3.最后数据是通过glVertexAttribPointer传递过去的。 //注意：第二参数字符串必须和shaderv.vsh中的输入变量：position保持一致 GLuint position = glGetAttribLocation(self.myProgram, \"position\"); //3.设置读取方式 //参数1：index,顶点数据的索引 //参数2：size,每个顶点属性的组件数量，1，2，3，或者4.默认初始值是4. //参数3：type,数据中的每个组件的类型，常用的有GL_FLOAT,GL_BYTE,GL_SHORT。默认初始值为GL_FLOAT //参数4：normalized,固定点数据值是否应该归一化，或者直接转换为固定值。（GL_FALSE） //参数5：stride,连续顶点属性之间的偏移量，默认为0； //参数6：指定一个指针，指向数组中的第一个顶点属性的第一个组件。默认为0 glVertexAttribPointer(position, 3, GL_FLOAT, GL_FALSE, sizeof(GLfloat) * 6, NULL); //2.设置合适的格式从buffer里面读取数据 glEnableVertexAttribArray(position); //--------处理顶点颜色值------- ////1.glGetAttribLocation,用来获取vertex attribute的入口的. //注意：第二参数字符串必须和shaderv.glsl中的输入变量：positionColor保持一致 GLuint positionColor = glGetAttribLocation(self.myProgram, \"positionColor\"); //3.设置读取方式 //参数1：index,顶点数据的索引 //参数2：size,每个顶点属性的组件数量，1，2，3，或者4.默认初始值是4. //参数3：type,数据中的每个组件的类型，常用的有GL_FLOAT,GL_BYTE,GL_SHORT。默认初始值为GL_FLOAT //参数4：normalized,固定点数据值是否应该归一化，或者直接转换为固定值。（GL_FALSE） //参数5：stride,连续顶点属性之间的偏移量，默认为0； //参数6：指定一个指针，指向数组中的第一个顶点属性的第一个组件。默认为0 glVertexAttribPointer(positionColor, 3, GL_FLOAT, GL_FALSE, sizeof(GLfloat) * 6, (float *)NULL + 3); //2.设置合适的格式从buffer里面读取数据 glEnableVertexAttribArray(positionColor); //注意，想要获取shader里面的变量，这里记得要在glLinkProgram后面，后面，后面！ /* 一个一致变量在一个图元的绘制过程中是不会改变的，所以其值不能在glBegin/glEnd中设置。一致变量适合描述在一个图元中、一帧中甚至一个场景中都不变的值。一致变量在顶点shader和片断shader中都是只读的。首先你需要获得变量在内存中的位置，这个信息只有在连接程序之后才可获得 */ //找到myProgram中的projectionMatrix、modelViewMatrix 2个矩阵的地址。如果找到则返回地址，否则返回-1，表示没有找到2个对象。 GLuint projectionMatrixSlot = glGetUniformLocation(self.myProgram, \"projectionMatrix\"); GLuint modelViewMatrixSlot = glGetUniformLocation(self.myProgram, \"modelViewMatrix\"); float width = self.frame.size.width; float height = self.frame.size.height; //创建4 * 4矩阵 KSMatrix4 _projectionMatrix; //获取单元矩阵 ksMatrixLoadIdentity(&amp;_projectionMatrix); //计算纵横比例 = 长/宽 float aspect = width / height; //长宽比 //获取透视矩阵 /* 参数1：矩阵 参数2：视角，度数为单位 参数3：纵横比 参数4：近平面距离 参数5：远平面距离 参考PPT */ ksPerspective(&amp;_projectionMatrix, 30.0, aspect, 5.0f, 20.0f); //透视变换，视角30° //设置glsl里面的投影矩阵 /* void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); 参数列表： location:指要更改的uniform变量的位置 count:更改矩阵的个数 transpose:是否要转置矩阵，并将它作为uniform变量的值。必须为GL_FALSE value:执行count个元素的指针，用来更新指定uniform变量 */ glUniformMatrix4fv(projectionMatrixSlot, 1, GL_FALSE, (GLfloat*)&amp;_projectionMatrix.m[0][0]); //开启剔除操作效果 glEnable(GL_CULL_FACE); //创建一个4 * 4 矩阵，模型视图 KSMatrix4 _modelViewMatrix; //获取单元矩阵 ksMatrixLoadIdentity(&amp;_modelViewMatrix); //平移，z轴平移-10 ksTranslate(&amp;_modelViewMatrix, 0.0, 0.0, -10.0); //创建一个4 * 4 矩阵，旋转矩阵 KSMatrix4 _rotationMatrix; //初始化为单元矩阵 ksMatrixLoadIdentity(&amp;_rotationMatrix); //旋转 ksRotate(&amp;_rotationMatrix, xDegree, 1.0, 0.0, 0.0); //绕X轴 ksRotate(&amp;_rotationMatrix, yDegree, 0.0, 1.0, 0.0); //绕Y轴 ksRotate(&amp;_rotationMatrix, zDegree, 0.0, 0.0, 1.0);//绕Z轴 //把变换矩阵相乘，注意先后顺序 ，将平移矩阵与旋转矩阵相乘，结合到模型视图 ksMatrixMultiply(&amp;_modelViewMatrix, &amp;_rotationMatrix, &amp;_modelViewMatrix); // ksMatrixMultiply(&amp;_modelViewMatrix, &amp;_modelViewMatrix, &amp;_rotationMatrix); // 加载模型视图矩阵 modelViewMatrixSlot //设置glsl里面的投影矩阵 /* void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value); 参数列表： location:指要更改的uniform变量的位置 count:更改矩阵的个数 transpose:是否要转置矩阵，并将它作为uniform变量的值。必须为GL_FALSE value:执行count个元素的指针，用来更新指定uniform变量 */ glUniformMatrix4fv(modelViewMatrixSlot, 1, GL_FALSE, (GLfloat*)&amp;_modelViewMatrix.m[0][0]); //使用索引绘图 /* void glDrawElements(GLenum mode,GLsizei count,GLenum type,const GLvoid * indices); 参数列表： mode:要呈现的画图的模型 GL_POINTS GL_LINES GL_LINE_LOOP GL_LINE_STRIP GL_TRIANGLES GL_TRIANGLE_STRIP GL_TRIANGLE_FAN count:绘图个数 type:类型 GL_BYTE GL_UNSIGNED_BYTE GL_SHORT GL_UNSIGNED_SHORT GL_INT GL_UNSIGNED_INT indices：绘制索引数组 */ glDrawElements(GL_TRIANGLES, sizeof(indices) / sizeof(indices[0]), GL_UNSIGNED_INT, indices); //要求本地窗口系统显示OpenGL ES渲染&lt;目标&gt; [self.myContext presentRenderbuffer:GL_RENDERBUFFER];&#125; 其中关于矩阵变换的操作(旋转/平移/缩放), 需要依赖一个GLES的数学类GLESMath.c导入进工程; 当然也可以用苹果封装好的GLKit中的对应方法代替(下篇文章会讲解) 实现围绕X/Y/Z轴旋转三角体:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&#123; float xDegree; float yDegree; float zDegree; BOOL bX; BOOL bY; BOOL bZ; NSTimer* myTimer; &#125;#pragma mark- XYZClick- (IBAction)XClick:(id)sender &#123; //开启定时器 if (!myTimer) &#123; myTimer = [NSTimer scheduledTimerWithTimeInterval:0.05 target:self selector:@selector(reDegree) userInfo:nil repeats:YES]; &#125; //更新的是X还是Y bX = !bX;&#125;- (IBAction)YClick:(id)sender &#123; //开启定时器 if (!myTimer) &#123; myTimer = [NSTimer scheduledTimerWithTimeInterval:0.05 target:self selector:@selector(reDegree) userInfo:nil repeats:YES]; &#125; //更新的是X还是Y bY = !bY;&#125;- (IBAction)ZClick:(id)sender &#123; //开启定时器 if (!myTimer) &#123; myTimer = [NSTimer scheduledTimerWithTimeInterval:0.05 target:self selector:@selector(reDegree) userInfo:nil repeats:YES]; &#125; //更新的是X还是Y bZ = !bZ;&#125;-(void)reDegree&#123; //如果停止X轴旋转，X = 0则度数就停留在暂停前的度数. //更新度数 xDegree += bX * 5; yDegree += bY * 5; zDegree += bZ * 5; //重新渲染 [self render]; &#125; 效果图","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/categories/学习笔记/"}],"tags":[{"name":"opengles","slug":"opengles","permalink":"http://yoursite.com/tags/opengles/"},{"name":"glsl","slug":"glsl","permalink":"http://yoursite.com/tags/glsl/"}]},{"title":"利用OpenGL ES渲染图片(下)","slug":"利用OpenGL ES渲染图片(下)","date":"2019-02-28T11:38:37.000Z","updated":"2019-03-01T03:20:05.779Z","comments":true,"path":"2019/02/28/利用OpenGL ES渲染图片(下)/","link":"","permalink":"http://yoursite.com/2019/02/28/利用OpenGL ES渲染图片(下)/","excerpt":"思路：不采用GLKBaseEffect，使用编译链接自定义的着色器（shader）。用简单的glsl语言来实现顶点、片元着色器，并对图形进行简单的变换。1.创建图层2.创建上下文3.清空缓存区4.设置RenderBuffer5.设置FrameBuffer6.开始绘制","text":"思路：不采用GLKBaseEffect，使用编译链接自定义的着色器（shader）。用简单的glsl语言来实现顶点、片元着色器，并对图形进行简单的变换。1.创建图层2.创建上下文3.清空缓存区4.设置RenderBuffer5.设置FrameBuffer6.开始绘制 代码实现12345678910111213141516171819202122-(void)layoutSubviews&#123; //1.设置图层 [self setupLayer]; //2.设置图形上下文 [self setupContext]; //3.清空缓存区 [self deleteRenderAndFrameBuffer]; //4.设置RenderBuffer [self setupRenderBuffer]; //5.设置FrameBuffer [self setupFrameBuffer]; //6.开始绘制 [self renderLayer]; &#125; 设置图层头文件引入:1#import &lt;OpenGLES/ES2/gl.h&gt; 属性创建:123456789//在iOS和tvOS上绘制OpenGL ES内容的图层，继承与CALayer@property(nonatomic,strong)CAEAGLLayer *myEagLayer;@property(nonatomic,strong)EAGLContext *myContext;@property(nonatomic,assign)GLuint myColorRenderBuffer;@property(nonatomic,assign)GLuint myColorFrameBuffer;@property(nonatomic,assign)GLuint myPrograme; 设置图层:12345678910111213141516171819202122232425262728293031323334353637//1.设置图层-(void)setupLayer&#123; //给图层开辟空间 /* 重写layerClass，将CCView返回的图层从CALayer替换成CAEAGLLayer */ self.myEagLayer = (CAEAGLLayer *)self.layer; //设置放大倍数 [self setContentScaleFactor:[[UIScreen mainScreen]scale]]; //CALayer 默认是透明的，必须将它设为不透明才能将其可见。 self.myEagLayer.opaque = YES; //设置描述属性，这里设置不维持渲染内容以及颜色格式为RGBA8 /* kEAGLDrawablePropertyRetainedBacking 表示绘图表面显示后，是否保留其内容。这个key的值，是一个通过NSNumber包装的bool值。如果是false，则显示内容后不能依赖于相同的内容，ture表示显示后内容不变。一般只有在需要内容保存不变的情况下，才建议设置使用,因为会导致性能降低、内存使用量增减。一般设置为flase. kEAGLDrawablePropertyColorFormat 可绘制表面的内部颜色缓存区格式，这个key对应的值是一个NSString指定特定颜色缓存区对象。默认是kEAGLColorFormatRGBA8； kEAGLColorFormatRGBA8：32位RGBA的颜色，4*8=32位 kEAGLColorFormatRGB565：16位RGB的颜色， kEAGLColorFormatSRGBA8：sRGB代表了标准的红、绿、蓝，即CRT显示器、LCD显示器、投影机、打印机以及其他设备中色彩再现所使用的三个基本色素。sRGB的色彩空间基于独立的色彩坐标，可以使色彩在不同的设备使用传输中对应于同一个色彩坐标体系，而不受这些设备各自具有的不同色彩坐标的影响。 */ self.myEagLayer.drawableProperties = [NSDictionary dictionaryWithObjectsAndKeys:[NSNumber numberWithBool:false],kEAGLDrawablePropertyRetainedBacking,kEAGLColorFormatRGBA8,kEAGLDrawablePropertyColorFormat,nil]; &#125;+(Class)layerClass&#123; return [CAEAGLLayer class];&#125; 设置上下文1234567891011121314151617181920212223//2.设置上下文-(void)setupContext&#123; //1.指定OpenGL ES 渲染API版本，我们使用2.0 EAGLRenderingAPI api = kEAGLRenderingAPIOpenGLES2; //2.创建图形上下文 EAGLContext *context = [[EAGLContext alloc]initWithAPI:api]; //3.判断是否创建成功 if (!context) &#123; NSLog(@\"Create context failed!\"); return; &#125; //4.设置图形上下文 if (![EAGLContext setCurrentContext:context]) &#123; NSLog(@\"setCurrentContext failed!\"); return; &#125; //5.将局部context，变成全局的 self.myContext = context; &#125; 清空缓存区12345678910111213141516171819202122232425262728293031//3.清空缓存区-(void)deleteRenderAndFrameBuffer&#123; //1.导入框架#import &lt;OpenGLES/ES2/gl.h&gt; /* 2.创建2个帧缓存区，渲染缓存区，帧缓存区 @property (nonatomic , assign) GLuint myColorRenderBuffer; @property (nonatomic , assign) GLuint myColorFrameBuffer; A.离屏渲染，详细解释见课件 B.buffer的分类,详细见课件 buffer分为frame buffer 和 render buffer2个大类。其中frame buffer 相当于render buffer的管理者。frame buffer object即称FBO，常用于离屏渲染缓存等。render buffer则又可分为3类。colorBuffer、depthBuffer、stencilBuffer。 //绑定buffer标识符 glGenRenderbuffers(&lt;#GLsizei n#&gt;, &lt;#GLuint *renderbuffers#&gt;) glGenFramebuffers(&lt;#GLsizei n#&gt;, &lt;#GLuint *framebuffers#&gt;) //绑定空间 glBindRenderbuffer(&lt;#GLenum target#&gt;, &lt;#GLuint renderbuffer#&gt;) glBindFramebuffer(&lt;#GLenum target#&gt;, &lt;#GLuint framebuffer#&gt;) */ glDeleteBuffers(1, &amp;_myColorRenderBuffer); self.myColorRenderBuffer = 0; glDeleteBuffers(1, &amp;_myColorFrameBuffer); self.myColorFrameBuffer = 0; &#125; 设置RenderBuffer12345678910111213141516171819202122//4.设置RenderBuffer-(void)setupRenderBuffer&#123; //1.定义一个缓存区 GLuint buffer; //2.申请一个缓存区标志 glGenRenderbuffers(1, &amp;buffer); //3. self.myColorRenderBuffer = buffer; //4.将标识符绑定到GL_RENDERBUFFER glBindRenderbuffer(GL_RENDERBUFFER, self.myColorRenderBuffer); //frame buffer仅仅是管理者，不需要分配空间；render buffer的存储空间的分配，对于不同的render buffer，使用不同的API进行分配，而只有分配空间的时候，render buffer句柄才确定其类型 //myColorRenderBuffer渲染缓存区分配存储空间 [self.myContext renderbufferStorage:GL_RENDERBUFFER fromDrawable:self.myEagLayer]; &#125; 设置FrameBuffer1234567891011121314151617181920212223//5.设置FrameBuffer-(void)setupFrameBuffer&#123; //1.定义一个缓存区 GLuint buffer; //2.申请一个缓存区标志 glGenRenderbuffers(1, &amp;buffer); //3. self.myColorFrameBuffer = buffer; //4. glBindFramebuffer(GL_FRAMEBUFFER, self.myColorFrameBuffer); //生成空间之后，则需要将renderbuffer跟framebuffer进行绑定，调用glFramebufferRenderbuffer函数进行绑定，后面的绘制才能起作用 //5.将_myColorRenderBuffer 通过glFramebufferRenderbuffer函数绑定到GL_COLOR_ATTACHMENT0上。 glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_RENDERBUFFER, self.myColorRenderBuffer); //接下来，可以调用OpenGL ES进行绘制处理，最后则需要在EGALContext的OC方法进行最终的渲染绘制。这里渲染的color buffer,这个方法会将buffer渲染到CALayer上。- (BOOL)presentRenderbuffer:(NSUInteger)target; &#125; 开始绘制123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146//6.开始绘制-(void)renderLayer&#123; //设置清屏颜色 glClearColor(0.0f, 1.0f, 0.0f, 1.0f); //清除屏幕 glClear(GL_COLOR_BUFFER_BIT); //1.设置视口大小 CGFloat scale = [[UIScreen mainScreen]scale]; glViewport(self.frame.origin.x * scale, self.frame.origin.y * scale, self.frame.size.width * scale, self.frame.size.height * scale); //2.读取顶点着色程序、片元着色程序 NSString *vertFile = [[NSBundle mainBundle]pathForResource:@\"shaderv\" ofType:@\"vsh\"]; NSString *fragFile = [[NSBundle mainBundle]pathForResource:@\"shaderf\" ofType:@\"fsh\"]; NSLog(@\"vertFile:%@\",vertFile); NSLog(@\"fragFile:%@\",fragFile); //3.加载shader self.myPrograme = [self loadShaders:vertFile Withfrag:fragFile]; //4.链接 glLinkProgram(self.myPrograme); GLint linkStatus; //获取链接状态 glGetProgramiv(self.myPrograme, GL_LINK_STATUS, &amp;linkStatus); if (linkStatus == GL_FALSE) &#123; GLchar message[512]; glGetProgramInfoLog(self.myPrograme, sizeof(message), 0, &amp;message[0]); NSString *messageString = [NSString stringWithUTF8String:message]; NSLog(@\"Program Link Error:%@\",messageString); return; &#125; NSLog(@\"Program Link Success!\"); //5.使用program glUseProgram(self.myPrograme); //6.设置顶点、纹理坐标 //前3个是顶点坐标，后2个是纹理坐标 GLfloat attrArr[] = &#123; 0.5f, -0.5f, -1.0f, 1.0f, 0.0f, -0.5f, 0.5f, -1.0f, 0.0f, 1.0f, -0.5f, -0.5f, -1.0f, 0.0f, 0.0f, 0.5f, 0.5f, -1.0f, 1.0f, 1.0f, -0.5f, 0.5f, -1.0f, 0.0f, 1.0f, 0.5f, -0.5f, -1.0f, 1.0f, 0.0f, &#125;; /* 1.解决渲染图片倒置问题： GLfloat attrArr[] = &#123; 0.5f, -0.5f, 0.0f, 1.0f, 1.0f, //右下 -0.5f, 0.5f, 0.0f, 0.0f, 0.0f, // 左上 -0.5f, -0.5f, 0.0f, 0.0f, 1.0f, // 左下 0.5f, 0.5f, 0.0f, 1.0f, 0.0f, // 右上 -0.5f, 0.5f, 0.0f, 0.0f, 0.0f, // 左上 0.5f, -0.5f, 0.0f, 1.0f, 1.0f, // 右下 &#125;; */ //-----处理顶点数据-------- //顶点缓存区 GLuint attrBuffer; //申请一个缓存区标识符 glGenBuffers(1, &amp;attrBuffer); //将attrBuffer绑定到GL_ARRAY_BUFFER标识符上 glBindBuffer(GL_ARRAY_BUFFER, attrBuffer); //把顶点数据从CPU内存复制到GPU上 glBufferData(GL_ARRAY_BUFFER, sizeof(attrArr), attrArr, GL_DYNAMIC_DRAW); //将顶点数据通过myPrograme中的传递到顶点着色程序的position //1.glGetAttribLocation,用来获取vertex attribute的入口的.2.告诉OpenGL ES,通过glEnableVertexAttribArray，3.最后数据是通过glVertexAttribPointer传递过去的。 //注意：第二参数字符串必须和shaderv.vsh中的输入变量：position保持一致 GLuint position = glGetAttribLocation(self.myPrograme, \"position\"); //2.设置合适的格式从buffer里面读取数据 glEnableVertexAttribArray(position); //3.设置读取方式 //参数1：index,顶点数据的索引 //参数2：size,每个顶点属性的组件数量，1，2，3，或者4.默认初始值是4. //参数3：type,数据中的每个组件的类型，常用的有GL_FLOAT,GL_BYTE,GL_SHORT。默认初始值为GL_FLOAT //参数4：normalized,固定点数据值是否应该归一化，或者直接转换为固定值。（GL_FALSE） //参数5：stride,连续顶点属性之间的偏移量，默认为0； //参数6：指定一个指针，指向数组中的第一个顶点属性的第一个组件。默认为0 glVertexAttribPointer(position, 3, GL_FLOAT, GL_FALSE, sizeof(GLfloat) * 5, NULL); //----处理纹理数据------- //1.glGetAttribLocation,用来获取vertex attribute的入口的. //注意：第二参数字符串必须和shaderv.vsh中的输入变量：textCoordinate保持一致 GLuint textCoor = glGetAttribLocation(self.myPrograme, \"textCoordinate\"); //2.设置合适的格式从buffer里面读取数据 glEnableVertexAttribArray(textCoor); //3.设置读取方式 //参数1：index,顶点数据的索引 //参数2：size,每个顶点属性的组件数量，1，2，3，或者4.默认初始值是4. //参数3：type,数据中的每个组件的类型，常用的有GL_FLOAT,GL_BYTE,GL_SHORT。默认初始值为GL_FLOAT //参数4：normalized,固定点数据值是否应该归一化，或者直接转换为固定值。（GL_FALSE） //参数5：stride,连续顶点属性之间的偏移量，默认为0； //参数6：指定一个指针，指向数组中的第一个顶点属性的第一个组件。默认为0 glVertexAttribPointer(textCoor, 2, GL_FLOAT, GL_FALSE, sizeof(GLfloat)*5, (float *)NULL + 3); //加载纹理 [self setupTexture:@\"timg-3\"]; //注意，想要获取shader里面的变量，这里记得要在glLinkProgram后面，后面，后面！ /* 一个一致变量在一个图元的绘制过程中是不会改变的，所以其值不能在glBegin/glEnd中设置。一致变量适合描述在一个图元中、一帧中甚至一个场景中都不变的值。一致变量在顶点shader和片断shader中都是只读的。首先你需要获得变量在内存中的位置，这个信息只有在连接程序之后才可获得 */ //rotate等于shaderv.vsh中的uniform属性，rotateMatrix GLuint rotate = glGetUniformLocation(self.myPrograme, \"rotateMatrix\"); //获取渲染的弧度 float radians = 10 * 3.14159f / 180.0f; //求得弧度对于的sin\\cos值 float s = sin(radians); float c = cos(radians); //z轴旋转矩阵 参考3D数学围绕z轴渲染矩阵公式 //为什么和公式不一样？因为在3D中用的是横向量，在OpenGL ES用的是列向量 GLfloat zRotation[16] = &#123; c, -s, 0, 0, s, c, 0, 0, 0, 0, 1.0, 0, 0.0, 0, 0, 1.0 &#125;; //设置旋转矩阵 glUniformMatrix4fv(rotate, 1, GL_FALSE, (GLfloat *)&amp;zRotation[0]); glDrawArrays(GL_TRIANGLES, 0, 6); [self.myContext presentRenderbuffer:GL_RENDERBUFFER]; &#125; 加载shader 与 链接shader12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#pragma mark --shader//加载shader-(GLuint)loadShaders:(NSString *)vert Withfrag:(NSString *)frag&#123; //定义2个零时着色器对象 GLuint verShader, fragShader; //创建program GLint program = glCreateProgram(); //编译顶点着色程序、片元着色器程序 //参数1：编译完存储的底层地址 //参数2：编译的类型，GL_VERTEX_SHADER（顶点）、GL_FRAGMENT_SHADER(片元) //参数3：文件路径 [self compileShader:&amp;verShader type:GL_VERTEX_SHADER file:vert]; [self compileShader:&amp;fragShader type:GL_FRAGMENT_SHADER file:frag]; //创建最终的程序 glAttachShader(program, verShader); glAttachShader(program, fragShader); //释放不需要的shader glDeleteShader(verShader); glDeleteShader(fragShader); return program;&#125;//链接shader- (void)compileShader:(GLuint *)shader type:(GLenum)type file:(NSString *)file&#123; //读取文件路径字符串 NSString* content = [NSString stringWithContentsOfFile:file encoding:NSUTF8StringEncoding error:nil]; const GLchar* source = (GLchar *)[content UTF8String]; //创建一个shader（根据type类型） *shader = glCreateShader(type); //将顶点着色器源码附加到着色器对象上。 //参数1：shader,要编译的着色器对象 *shader //参数2：numOfStrings,传递的源码字符串数量 1个 //参数3：strings,着色器程序的源码（真正的着色器程序源码） //参数4：lenOfStrings,长度，具有每个字符串长度的数组，或NULL，这意味着字符串是NULL终止的 glShaderSource(*shader, 1, &amp;source,NULL); //把着色器源代码编译成目标代码 glCompileShader(*shader); &#125; 设置纹理1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495//设置纹理- (GLuint)setupTexture:(NSString *)fileName &#123; //1、获取图片的CGImageRef CGImageRef spriteImage = [UIImage imageNamed:fileName].CGImage; //判断图片是否获取成功 if (!spriteImage) &#123; NSLog(@\"Failed to load image %@\", fileName); exit(1); &#125; //2、读取图片的大小，宽和高 size_t width = CGImageGetWidth(spriteImage); size_t height = CGImageGetHeight(spriteImage); //3.获取图片字节数 宽*高*4（RGBA） GLubyte * spriteData = (GLubyte *) calloc(width * height * 4, sizeof(GLubyte)); //4.创建上下文 /* 参数1：data,指向要渲染的绘制图像的内存地址 参数2：width,bitmap的宽度，单位为像素 参数3：height,bitmap的高度，单位为像素 参数4：bitPerComponent,内存中像素的每个组件的位数，比如32位RGBA，就设置为8 参数5：bytesPerRow,bitmap的没一行的内存所占的比特数 参数6：colorSpace,bitmap上使用的颜色空间 kCGImageAlphaPremultipliedLast：RGBA */ CGContextRef spriteContext = CGBitmapContextCreate(spriteData, width, height, 8, width*4,CGImageGetColorSpace(spriteImage), kCGImageAlphaPremultipliedLast); //5、在CGContextRef上绘图 /* CGContextDrawImage 使用的是Core Graphics框架，坐标系与UIKit 不一样。UIKit框架的原点在屏幕的左上角，Core Graphics框架的原点在屏幕的左下角。 CGContextDrawImage 参数1：绘图上下文 参数2：rect坐标 参数3：绘制的图片 */ CGRect rect = CGRectMake(0, 0, width, height); //使用默认方式绘制，发现图片是倒的。 CGContextDrawImage(spriteContext, CGRectMake(0, 0, width, height), spriteImage); /* 解决图片倒置的方法(2): CGContextTranslateCTM(spriteContext, rect.origin.x, rect.origin.y); CGContextTranslateCTM(spriteContext, 0, rect.size.height); CGContextScaleCTM(spriteContext, 1.0, -1.0); CGContextTranslateCTM(spriteContext, -rect.origin.x, -rect.origin.y); CGContextDrawImage(spriteContext, rect, spriteImage); */ //6、画图完毕就释放上下文 CGContextRelease(spriteContext); //5、绑定纹理到默认的纹理ID（这里只有一张图片，故而相当于默认于片元着色器里面的colorMap，如果有多张图不可以这么做） glBindTexture(GL_TEXTURE_2D, 0); //设置纹理属性 /* 参数1：纹理维度 参数2：线性过滤、为s,t坐标设置模式 参数3：wrapMode,环绕模式 */ glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR ); glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR ); glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE); glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE); float fw = width, fh = height; //载入纹理2D数据 /* 参数1：纹理模式，GL_TEXTURE_1D、GL_TEXTURE_2D、GL_TEXTURE_3D 参数2：加载的层次，一般设置为0 参数3：纹理的颜色值GL_RGBA 参数4：宽 参数5：高 参数6：border，边界宽度 参数7：format 参数8：type 参数9：纹理数据 */ glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, fw, fh, 0, GL_RGBA, GL_UNSIGNED_BYTE, spriteData); //绑定纹理 /* 参数1：纹理维度 参数2：纹理ID,因为只有一个纹理，给0就可以了。 */ glBindTexture(GL_TEXTURE_2D, 0); //释放spriteData free(spriteData); return 0;&#125; GLSL程序编写OpenGL ES的可编程管线中的顶点着色器和片元着色器需要开发者自行编写, 对应的语言为GLSL(OpenGL Shading Language), 其中顶点着色器处理传入的顶点坐标, 片元着色器将顶点坐标进行光栅化处理, 显示出图形 顶点着色器程序: shaderVertex.fsh12345678910111213141516attribute vec4 position;// 处理顶点数据attribute vec2 textCoordinate;// 处理纹理uniform mat4 rotateMatrix;//处理图形旋转varying lowp vec2 varyTextCoord;void main()&#123; varyTextCoord = textCoordinate; vec4 vPos = position; vPos = vPos * rotateMatrix;//每个顶点坐标进行旋转角度处理 gl_Position = vPos;//内建变量gl_Position,必须赋值&#125; 片元着色器程序: shaderFrgment.fsh123456789varying lowp vec2 varyTextCoord;uniform sampler2D colorMap;void main()&#123; gl_FragColor = texture2D(colorMap, varyTextCoord);//内建变量gl_FragColor,必须赋值&#125; 顶点着色器调用次数与顶点数量相关, 片元着色器调用与像素多少相关, 所以片元着色器的调用次数比较多 运行结果 可以看到图形是反的, 这是因为纹理本身是倒置的, 下面将讲解解决图形倒置的三种方法 解决图形倒置的方法1. 设置图形旋转角度可以看到上面的图形除了倒置之外, 还有一些倾斜, 是因为我们在代码中设置了图形的旋转角度为10度, 那么我们将这个参数调整为180度, 即可将图形倒置回来 另外, 若不想让图形旋转, 则需要注释掉这部分代码, 并注释顶点着色器中关于rotateMatrix的部分 2. 调整纹理坐标纹理的坐标是倒置的, 那么我们调整纹理坐标, 也可以将图形倒置回来 3. 利用CGContext 效果","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/categories/学习笔记/"}],"tags":[{"name":"opengles","slug":"opengles","permalink":"http://yoursite.com/tags/opengles/"}]},{"title":"利用OpenGL ES渲染图片(上)","slug":"利用OpenGL ES渲染图片(上)","date":"2019-02-28T10:38:37.000Z","updated":"2019-03-01T07:23:33.077Z","comments":true,"path":"2019/02/28/利用OpenGL ES渲染图片(上)/","link":"","permalink":"http://yoursite.com/2019/02/28/利用OpenGL ES渲染图片(上)/","excerpt":"OpenGL与OpenGL ES发展历史图形编程接⼝ 2D图形编程接⼝口: GDI , Skiz, OpenVG 3D图形编程接⼝口: DirectX , OpenGL/OpenGL ES , Embedded Systems OpenGL的特点 跨操作系统平台运⾏ 隐藏底层硬件信息 专⽤渲染接⼝","text":"OpenGL与OpenGL ES发展历史图形编程接⼝ 2D图形编程接⼝口: GDI , Skiz, OpenVG 3D图形编程接⼝口: DirectX , OpenGL/OpenGL ES , Embedded Systems OpenGL的特点 跨操作系统平台运⾏ 隐藏底层硬件信息 专⽤渲染接⼝ OpenGL历史变更 1992年年7⽉月SGI发布OpenGL1.0版本 (硅图)SGI Window NT版本的OpenGL 1995年年OpenGL1.1版本发布 2003年年7⽉月SGI与ARB发OpenGL 1.5 2004年年8⽉月OpenGL2.0版本发布 OpenGL Shading Language(GLSL) shader OpenGL ES的版本 OpenGL ES 1.X :针对固定功能流水管线硬件 OpenGL ES 2.X :针对可编程流水管线硬件 OpenGL ES 3.X :OpenGL ES 2.0的扩展 着⾊色器器渲染过程在渲染过程中，必须存储2种着⾊器，分别是顶点着⾊器、⽚元着⾊器。顶点着⾊器是第⼀个着⾊器、⽚元着色器是最后一个。顶点着⾊器中处理顶点、⽚元着⾊器处理像素点颜色。 屏幕渲染方式 On-Screen Rendering(当前屏幕渲染) : 指的是GPU的渲染操作是在当前用于显示的屏幕缓存区中进行的。 Off-Screen Rendering(离幕渲染) : 指的是GPU在当前屏幕缓存区以外新开辟一个缓存区进⾏渲染操作 ⼀般情况下，OpenGL ES会将应用提供到渲染服务的动画直接渲染显示(使用基本的渲染流程) 但对于一些复杂的图像动画的渲染，并不能够直接渲染叠加显示出来。⽽是需要根据Command Buffer分通道进行渲染再组合。这个组合过程中，就有些渲染通道是不会直接显示出来的。标记此次渲染需要更多的渲染通道和合并步骤，⽽这些没有直接渲染显示在屏幕上的通道就是离屏渲染通道。 离屏渲染需要更多的渲染通道，⽽不同的渲染通道间切换需要消耗一定的时间，所以离屏渲染可能会发生卡顿。 相⽐于当前屏幕渲染，离屏渲染的代价相对⽽言较高。主要有以下2个原因:1.创建新的缓存区2.上下⽂切换 哪些情况会使用离屏渲染(off-Screen Render)? drawRect layer.shouldRasterize = true; 有mask或者阴影(layer.makesToBounds)shouldRasterize(光栅化)、masks(遮罩)、shadows(阴影) edge antialiasing(抗锯⻮齿)、group opacity(不不透明) Text(UILabel,CATextLayer,CoreText) 为什么要用FrameBuffer和 RenderBuffer?它们是什么关系? A renderbuffer object is a 2D image buffer allocated by the application. The renderbuffer can be used to allocate and store color, depth, or stencil values and can be used as a color, depth, or stencil attachment in a framebuffer object. A renderbuffer is similar to an off-screen window system provided drawable surface, such as a pbuffer. A renderbuffer, however, cannot be directly used as a GL texture. ⼀个renderbuffer对象是应⽤分配的一个2D图像缓存区。renderbuffer能够被用来分配和存储颜色、深度或者模板值。也能够在一个framebuffer中被用作颜色、深度、模板的附件。⼀个renderbuffer是一个类似于屏幕窗口系统提供可绘制的表面。⽐如pBuffer。⼀个renderbuffer, 并不能直接被当做⼀个GL纹理使用。 A framebuffer object (often referred to as an FBO) is a collection of color, depth, and stencil buffer attachment points; state that describes properties such as the size and format of the color, depth, and stencil buffers attached to the FBO; and the names of the texture and renderbuffer objects attached to the FBO. Various 2D images can be attached to the color attachment point in the framebuffer object. These include a renderbuffer object that stores color values, a mip-level of a 2D texture or a cube map face, or even a mip-level of a 2D slice in a 3D texture. Similarly, various 2D images contain-ing depth values can be attached to the depth attachment point of an FBO. These can include a renderbuffer, a mip-level of a 2D texture or a cubemap face that stores depth values. The only 2D image that can be attached to the stencil attachment point of an FBO is a renderbuffer object that stores stencil values. ⼀个frameBuffer对象(通常被称为⼀个FBO)。是一个颜色、深度和模板缓存区附着点的集合。描述属性的状态，例如颜⾊、深度和模板缓存区的⼤⼩和格式，都关联到FBO(Frame Buffer Object)。并且纹理的名字和renderBuffer对象也都是关联于FBO。各种各样的2D图形能够被附着framebuffer对象的颜色附着点。它们包含了renderbuffer对象存储的颜色值、一个2D纹理或⽴⽅体贴图。或者一个mip-level的⼆维切面在3D纹理。同样，各种各样的2D图形包含了当时的深度值可以附加到⼀个FBO的深度附着点钟去。唯一的二维图像，能够附着在FBO的模板附着点，是一个renderbuffer对象存储模板值。 好吧, 这很晦涩难懂…还是看图揣摩吧, 大致意思是RenderBuffer需要附着于FrameBuffer, FrameBuffer管理RenderBuffer, 需要先设置RenderBuffer, 然后和FramBuffer进行绑定操作, 后面的绘制才能起到作用 基本图形硬件流⽔线设计 应⽤用程序层 -&gt; 硬件抽象层 -&gt; 硬件层应⽤用层: 游戏和应⽤用层软件开发⼈人员为主体，通过调⽤用API进行上层开发，不需要考虑移植性问题。硬件抽象层: 抽象出硬件的加速功能，进行有利于应用层开发的封装,并向应用层提供开发API硬件层: 将硬件驱动提供给抽象层，以实现抽象层加速功能的有效性。 shader着色器。着⾊器其实就是一段在GPU运行的程序。我们平时的程序，是在CPU运行。由于GPU的硬件设计结构与CPU有着很⼤的不同，所以GPU需要一些新的编程语⾔. 渲染流水线分为两种，其中一种为可编程渲染流⽔线。另外一种为固定渲染流水线。(也称可编程管线或固定管线，管线就是流⽔线的意思)。渲染流水线可否编程，取决于程序猿能否在顶点着⾊器以及片段着色器上进行编码。⽽现在的渲染流水线，基本都是可编程的，当然，它们也支持固定渲染流⽔线的功能 渲染流⽔线的具体流程1、应⽤层 :在这⼀层，我们⽬前使⽤的是DirectX与OpenGL。对于这一部分，主要是一些API的调⽤2、硬件抽象层 :应⽤程序层主要与内存，CPU打交道，诸如碰撞检测，场景图监理，视锥裁剪等经典算法在此阶段执行。在阶段的末端，几何体的数据(顶点坐标，法向量，纹理坐标，纹理)等通过数据总线传送到图形硬件3、硬件层 :硬件层在渲染流水线中最为复杂，也最为重要。可编程渲染流⽔线与固定渲染流水线的区别在于是否对着⾊器进⾏编程。 ⾸先我们先了解固定渲染流水线, 它主要分为以下⼏个阶段:顶点变换 -&gt; 图元转配与光栅化 -&gt; ⽚段纹理映射和着色 -&gt; 光栅化操作 硬件层—固定渲染管线流程图 : 光栅化(Rasterization):将顶点数据转换为片元的过程, ⽚元中每个一个元素对于帧缓存区的一个像素;光栅化其实是一个将⼏何图元变成一个二维图像的过程, 光栅化的过程就是为了产出⽚元 硬件层—可编程渲染流⽔水线流程图: GPU图形渲染管线应用程序阶段 :主要是⾼级编程语言开发,如C,OC,C++输出: 通过数据总线,把⼏何体的数据(顶点坐标\\法线\\纹理坐标\\纹理)等传送到GPU上几何阶段 :输⼊: 应⽤程序末端的内容负责任务: 顶点坐标变换,光照,裁剪,投影,屏幕映射输出: 经过变换和投影之后的屏幕坐标,颜色,纹理坐标光栅化阶段 :参考前面的解释 为什么需要对三维空间的顶点进行坐标空间转换?输⼊到计算机当中的是一系列三维坐标的点,但是我们看到的屏幕是⼆维坐标点. 所以需要一系列的坐标转换:ObjectSpace(物体空间/模型空间)-&gt; WorldSpace(世界空间)-&gt;EyeSpace(观察空间)-&gt;ClicpAndProjectSpace(屏幕空间) CPU与GPU之间的关系GPU具有⾼并行的结构，所以在处理图形数据和复杂算法时比CPU更加有效率 CPU在执行任务的时候，一个时刻只会处理一个数据，不存在真正意义上的并行，⽽GPU则有多个处理器核，在一个时刻可以并⾏处理多个数据","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/categories/学习笔记/"}],"tags":[{"name":"opengles","slug":"opengles","permalink":"http://yoursite.com/tags/opengles/"}]},{"title":"Hexo搭建Github-Pages博客记录","slug":"Hexo搭建Github-Pages博客记录","date":"2019-02-22T07:00:37.000Z","updated":"2019-03-01T06:38:59.235Z","comments":true,"path":"2019/02/22/Hexo搭建Github-Pages博客记录/","link":"","permalink":"http://yoursite.com/2019/02/22/Hexo搭建Github-Pages博客记录/","excerpt":"一直都很想搭一个自己的博客, 但一直很忙(其实是懒)没弄, 最近终于搭建好了, 过程中也遇到了一些问题, 写个流水账记录下.","text":"一直都很想搭一个自己的博客, 但一直很忙(其实是懒)没弄, 最近终于搭建好了, 过程中也遇到了一些问题, 写个流水账记录下. 准备工作 一个github账号 安装了node.js, npm, git (mac用户的安装xcode就已经装好git了) 搭建github博客创建仓库新建一个用户名.github.io的仓库, 用户名必须为你的github用户名. 比如我的用户名为soober, 那么需要创建soober.github.io的仓库. 配置SSH key提交代码需要拥有你的github权限, 使用ssh key来解决本地和服务器的连接问题 用git bash(mac用户, 用终端即可)执行如下命令：1cd ~/. ssh 1ssh-keygen -t rsa -C &quot;邮件地址&quot; 一路回车(密码可以不用输入,直接回车)最终会生成一个文件在用户目录下，找到.ssh\\id_rsa.pub文件，复制里面的内容，打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key, 将复制的内容粘贴到key那里，title自己写一个，保存。 测试SSH配置是否成功1$ ssh -T git@github.com 如果看到以下信息,说明配置成功 Hexo框架搭建Hexo是一个简单、快速、强大的基于 Github Pages 的博客发布工具，支持Markdown格式，有众多优秀插件和主题。由于github pages存放的都是静态文件，博客存放的不只是文章内容，还有文章列表、分类、标签、翻页等动态内容，假如每次写完一篇文章都要手动更新博文目录和相关链接信息，相信谁都会疯掉，所以hexo所做的就是将这些md文件都放在本地，每次写完文章后调用写好的命令来批量完成相关页面的生成，然后再将有改动的页面提交到github。[官网] (http://hexo.io)[github] (https://github.com/hexojs/hexo) 安装1$ npm install -g hexo 初始化选择博客存储位置, 创建hexo文件夹,然后初始化12$ cd hexo$ hexo init hexo会自动下载一些文件到这个目录，包括node_modules，目录结构如下图：其中, _config.yml这里面都是一些全局配置，每个参数的意思都比较简单明了，就不作详细介绍了。需要特别注意的地方是，冒号后面必须有一个空格，否则可能会出问题。 接着生成和启动hexo服务12$ hexo g # 生成$ hexo s # 启动服务 执行以上命令之后，hexo就会在public文件夹生成相关html文件，这些文件将来都是要提交到github去的： hexo s是开启本地预览服务，打开浏览器访问 http://localhost:4000 即可看到博客预览内容(使用ctrl+c结束本地预览) 主题设置一个好看的主题可以让你的博客看上去赏心悦目, 我选择用了Next主题, 你可以再这里选择你喜欢的主题样式 首先下载这个主题：12$ cd your-hexo-site$ git clone https://github.com/iissnan/hexo-theme-next themes/next 下载后的主题都在hexo/themes下存放 接着修改hexo根目录_config.yml中的theme: landscape改为theme: next，如下:123456# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/# theme: landscape# theme: yiliatheme: next 然后重新执行hexo g来重新生成。如果出现一些莫名其妙的问题，可以先执行hexo clean来清理一下public的内容，然后再重新生成。 初始化本地git仓库如果你的本地仓库还没有进行远程仓库关联, 需要进行以下步骤设置Git的user name和email：12$ git config --global user.name // 你的github用户名，非昵称$ git config --global user.email // 填写你的github注册邮箱 在本地的hexo init生成的文件夹中初始化git仓库：1$ git init 将本地仓库和远程仓库连接(这一步貌似可以不做):1$ git remote add origin git@github.com:your_github_user_name/your_github_user_name.github.io.git(远程仓库ssh地址) 做完以上这些步骤，说明你的仓库可以使用ssh方式来上传下载代码，而不需要输入用户名和密码了 网站部署首先, 配置hexo根目录_config.yml中有关deploy的部分：123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: git@github.com:soober/soober.github.io.git branch: master 接着, 安装插件1npm install hexo-deployer-git --save 然后执行发布命令123$ hexo clean //清除缓存文件db.json和已生成的静态文件public$ hexo g //生成网站静态文件到默认设置的public文件夹$ hexo d //部署网站到设定的仓库 执行这个命令可能会碰到一些问题, 终端里会直接给出修改建议, 我是按照给出的参考命令执行的, 具体问题忘记截图了=-= 此时你的博客就部署到了page上了, 打开你的用户名.github.io, 即可看到你发布到github的博客了, hexo默认会帮你创建好一篇helloworld文章 常用hexo命令常见命令1234567hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）hexo deploy #部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本 缩写1234hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy 组合命令12hexo s -g #生成并本地预览hexo d -g #生成并上传 或者: hexo g --d 绑定域名 不想绑定域名的可以跳过这一步骤. 想绑定域名还没有域名的, 可以去阿里或者腾讯注册一个域名, 我是在腾讯买的一个.com域名. 传送门-腾讯云 有个域名之后, 进行域名解析.域名解析配置最常见有2种方式，CNAME和A记录，其中CNAME填写域名，A记录填写IP. 获取ip需要你去ping一下你的用户名.github.io (腾讯的需要进行个人身份认证之后才能正常访问域名) 设置CNAME 在 hexo 项目下，source 文件夹下面创建 CNAME 文件（没有后缀名的），在里面写上购买的域名然后在 github 上面，打开 username.github.io 项目的（Settings）设置，然后在 GitHub Pages的 Custom domain设置里填上购买的域名。比如：好了,新域名配置完成，可以访问了 一些报错处理 ERROR Plugin load failed: hexo-server原因：Besides, utilities are separated into a standalone module. hexo.util is not reachable anymore.解决方法，执行命令： 1sudo npm install hexo-server 有关-ejs, -stylus, -marked的一些错误提示解决办法, 执行命令: 1234567npm install hexo-renderer-ejs --savenpm install hexo-renderer-stylus --savenpm install hexo-renderer-marked --save//这个时候再重新生成静态文件，命令：hexo generate （或hexo g）//启动本地服务器：hexo server （或hexo s） 参考http://blog.haoji.me","categories":[{"name":"利器","slug":"利器","permalink":"http://yoursite.com/categories/利器/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"next","slug":"next","permalink":"http://yoursite.com/tags/next/"}]},{"title":"Next主题配置遇到的一些问题","slug":"Next主题配置遇到的一些问题","date":"2019-02-22T07:00:37.000Z","updated":"2019-02-25T08:56:45.216Z","comments":true,"path":"2019/02/22/Next主题配置遇到的一些问题/","link":"","permalink":"http://yoursite.com/2019/02/22/Next主题配置遇到的一些问题/","excerpt":"问题一: 归档/分类/标签页面或子页面显示错误 Cannot GET XXXHexo在生成静态页的时候，需要使用对应的插件： * hexo-generator-index #生成首页 * hexo-generator-archive #生成归档页 * hexo-generator-tag #生成标签页 * hex0-generator-category #生成分类页","text":"问题一: 归档/分类/标签页面或子页面显示错误 Cannot GET XXXHexo在生成静态页的时候，需要使用对应的插件： * hexo-generator-index #生成首页 * hexo-generator-archive #生成归档页 * hexo-generator-tag #生成标签页 * hex0-generator-category #生成分类页 对应安装命令:1234$ npm install hexo-generator-index --save$ npm install hexo-generator-archive --save$ npm install hexo-generator-tag --save$ npm install hexo-generator-category --save 注意, 其中tag/category都需要有对应的本地文件, 即在 /source/ 目录下新建 categories 目录和 tags 目录(也可以用hexo new page xxx对应生成)，里面的要有 index.md 文件，文件格式如下, 注意type不能写错: tags index.md 12345---title: 标签date: 2019-02-20 18:25:04type: &quot;tags&quot;--- categories index.md 12345---title: 文章分类date: 2019-02-20 18:16:44type: &quot;categories&quot;--- 然后每次写的新文章顶部写入categories/tags的value值, hexo即可自动帮你进行分类或标签管理, 示例如下:1234567---title: Git基本操作date: 2019-02-21 20:38:37categories: 学习笔记tags: [Git]top: 90--- 当然, next的主题配置文件里也要打开对应的注释, 如下12345678910111213menu: home: / || home about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat# Enable/Disable menu icons.menu_icons: enable: true 问题二: 配置博客单篇文章阅读次数, 阅读次数不能正常显示采用的是leanCloud配置方法, 具体配置教程请参考这里 若按照如上教程配置之后, 阅读次数仍无法显示, 可以参考我的解决办法:即打开leanCloud中关于Counter的权限, 我将add_fields和create两个选项的权限改为所有用户后, 博客文章的阅读次数就正常显示了=-=, 如下图: *另外Valine的介绍页上显示可以直接进行自动配置文章阅读次数了, 但是我试验失败, 估计是和之前npm install hexo-leancloud-counter-security --save有了什么冲突. 参考主题个性化设置theme-next.iissnan.comnext个性化主题配置 配置评论功能Valine - 一款快速、简洁且高效的无后端评论系统 文章阅读次数配置Hexo Next leancloud文章阅读次数配置以及插件无效问题解决 问题搜索参考hexo博客归档不分页显示设置方法Counter not initialized解决办法","categories":[{"name":"利器","slug":"利器","permalink":"http://yoursite.com/categories/利器/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"next","slug":"next","permalink":"http://yoursite.com/tags/next/"}]},{"title":"Git基本操作","slug":"Git基本操作","date":"2019-02-21T12:38:37.000Z","updated":"2019-02-21T10:46:29.612Z","comments":true,"path":"2019/02/21/Git基本操作/","link":"","permalink":"http://yoursite.com/2019/02/21/Git基本操作/","excerpt":"(一) 从远程仓库克隆(拉取)项目到本地$ git clone [remote_url] 成功执行后, 本地就已经有配置好git的远程项目了(项目路径默认为终端当前所在路径, 可以通过pwd查看当前路径, 并通过cd调整你想让项目存放的路径)","text":"(一) 从远程仓库克隆(拉取)项目到本地$ git clone [remote_url] 成功执行后, 本地就已经有配置好git的远程项目了(项目路径默认为终端当前所在路径, 可以通过pwd查看当前路径, 并通过cd调整你想让项目存放的路径) (二)为本地项目添加远程库 创建本地版本库$ git init 通过git init命令把本地项目目录变成Git可以管理的仓库 关联远程仓库$ git remote add origin [remote_url]若操作过程中出现问题,想删除关联远程仓库,可使用:$ git remote remove origin 把本地库的内容推送到远程$ git add .$ git commit -m &quot;the first commit project&quot;$ git push -u origin master 把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。 由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。 若远程仓库有些初始文件(如readme, .gitignore), 则需要在push前先使用命令git pull origin master同步代码 推送成功后，可以立刻在远程仓库页面中看到远程库的内容已经和本地一模一样了. 若过程中出现错误, 解决参照传送门 若.gitignore文件未生效, 解决参照传送门 (三)代码的更新与提交更新取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch] 提交$ cd projectname //转到项目文件夹下$ git add . //追踪新文件,并放到暂存区$ git commit -m &quot;update message&quot; //将文件纳入本地仓库$ git push // 将本地仓库同步到远程仓库 刷新远程仓库页面, 可以发现代码已经上传到远程仓库了","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/categories/学习笔记/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}]},{"title":"OpenGL(七)-纹理(下)","slug":"OpenGL(七)-纹理(下)","date":"2019-02-19T16:38:43.000Z","updated":"2019-02-21T10:04:12.856Z","comments":true,"path":"2019/02/20/OpenGL(七)-纹理(下)/","link":"","permalink":"http://yoursite.com/2019/02/20/OpenGL(七)-纹理(下)/","excerpt":"绘制一个隧道","text":"绘制一个隧道 定义绘制批次类123456789101112131415161718192021222324GLShaderManager shaderManager; //着色器管理器GLMatrixStack modelViewMatrix; //模型视图矩阵GLMatrixStack projectionMatrix; //投影矩阵GLFrustum viewFrustum; //视景体GLGeometryTransform transformPipeline; //几何变换管线//4个批次容器类GLBatch floorBatch;//地面GLBatch ceilingBatch;//天花板GLBatch leftWallBatch;//左墙面GLBatch rightWallBatch;//右墙面//深度初始值，-65。GLfloat viewZ = -65.0f;// 纹理标识符号#define TEXTURE_BRICK 0 //墙面#define TEXTURE_FLOOR 1 //地板#define TEXTURE_CEILING 2 //纹理天花板#define TEXTURE_COUNT 3 //纹理个数GLuint textures[TEXTURE_COUNT];//纹理标记数组//文件tag名字数组const char *szTextureFiles[TEXTURE_COUNT] = &#123; \"brick.tga\", \"floor.tga\", \"ceiling.tga\" &#125;; 初始化 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176//在这个函数里能够在渲染环境中进行任何需要的初始化，它这里的设置并初始化纹理对象void SetupRC()&#123; GLbyte *pBytes; GLint iWidth,iHeight,iComponents; GLenum eFormat; GLint iLoop; //背景 glClearColor(0.0f, 0.0f, 0.0f,1.0f); shaderManager.InitializeStockShaders(); //1.加载纹理 /* glGenTextures (GLsizei n, GLuint *textures) 参数1:n,纹理数量 参数2:textures,纹理对象标识数组 */ glGenTextures(TEXTURE_COUNT, textures); for (iLoop =0; iLoop &lt; TEXTURE_COUNT; iLoop++) &#123; //2.绑定纹理 /* glBindTexture (GLenum target, GLuint texture); 参数1:target,使用的纹理类型GL_TEXTURE_1D\\GL_TEXTURE_2D\\GL_TEXTURE_3D 参数2:texture,纹理的标记 */ glBindTexture(GL_TEXTURE_2D, textures[iLoop]); //3.加载tga文件 /* GLbyte *gltReadTGABits(const char *szFileName, GLint *iWidth, GLint *iHeight, GLint *iComponents, GLenum *eFormat, GLbyte *pData); 参数1:szFileName 纹理文件的名称 参数2:iWidth 获取纹理文件的宽度 参数3:iHeight获取纹理文件的高度 参数4:iComponents获取纹理文件的组件 参数5:eFormat获取纹理文件的格式 返回值:指向图像数据的指针 */ pBytes = gltReadTGABits(szTextureFiles[iLoop], &amp;iWidth, &amp;iHeight, &amp;iComponents, &amp;eFormat); //放大过滤器 glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST); //缩小过滤器 glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST); //环绕方式--S glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE); //环绕方式--T glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE); //载入纹理 /* glTexImage2D (GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels); 参数1:target,使用的纹理类型GL_TEXTURE_1D\\GL_TEXTURE_2D\\GL_TEXTURE_3D 参数2:level ,Mip贴图的层次 参数3:internalformat,纹理单元的颜色组成方式(从读取像素图中获得) 参数4:width 参数5:height 参数6:border 参数7:format 参数8:type,像素数据的数据类型-GL_UNSIGNED_BYTE 参数9:pixels,指向纹理图像数据的指针 */ glTexImage2D(GL_TEXTURE_2D, 0, iComponents, iWidth, iHeight, 0, eFormat, GL_UNSIGNED_BYTE, pBytes); //生成MIP图层 /* 参数1:GL_TEXTURE_1D\\GL_TEXTURE_2D\\GL_TEXTURE_3D */ glGenerateMipmap(GL_TEXTURE_2D); free(pBytes); &#125; //建立立体图像!!! GLfloat z; /* void Begin(GLenum primitive, GLuint nVerts, GLuint nTextureUnits = 0); 参数1:绘图模式 参数2:顶点个数 参数3:纹理,默认等于0 */ floorBatch.Begin(GL_TRIANGLE_STRIP, 28,1);//共绘制了7个四边形, 共28个顶点 //参考图 - floor.png for (z = 60.0f; z &gt;= 0.0f; z -= 10.0f) &#123; //指定顶点对应纹理的坐标 floorBatch.MultiTexCoord2f(0, 0, 0); //指定左下角顶点 floorBatch.Vertex3f(-10.0f, -10.0f, z); //指定右下角顶点以及纹理坐标 floorBatch.MultiTexCoord2f(0, 1, 0); floorBatch.Vertex3f(10.0f, -10.0f, z); //指定顶点对应纹理的坐标 floorBatch.MultiTexCoord2f(0, 0, 1.0f); floorBatch.Vertex3f(-10.0f, -10.0f, z-10.0f); //指定顶点对应纹理的坐标 floorBatch.MultiTexCoord2f(0, 1.0f, 1.0f); floorBatch.Vertex3f(10.0f, -10.0f, z-10.0f); &#125; floorBatch.End(); //参考图- ceiling.png ceilingBatch.Begin(GL_TRIANGLE_STRIP, 28, 1); for(z = 60.0f; z &gt;= 0.0f; z -=10.0f) &#123; ceilingBatch.MultiTexCoord2f(0, 0.0f, 1.0f); ceilingBatch.Vertex3f(-10.0f, 10.0f, z - 10.0f); ceilingBatch.MultiTexCoord2f(0, 1.0f, 1.0f); ceilingBatch.Vertex3f(10.0f, 10.0f, z - 10.0f); ceilingBatch.MultiTexCoord2f(0, 0.0f, 0.0f); ceilingBatch.Vertex3f(-10.0f, 10.0f, z); ceilingBatch.MultiTexCoord2f(0, 1.0f, 0.0f); ceilingBatch.Vertex3f(10.0f, 10.0f, z); &#125; ceilingBatch.End(); //参考图 - leftWall.png leftWallBatch.Begin(GL_TRIANGLE_STRIP, 28, 1); for(z = 60.0f; z &gt;= 0.0f; z -=10.0f) &#123; leftWallBatch.MultiTexCoord2f(0, 0.0f, 0.0f); leftWallBatch.Vertex3f(-10.0f, -10.0f, z); leftWallBatch.MultiTexCoord2f(0, 0.0f, 1.0f); leftWallBatch.Vertex3f(-10.0f, 10.0f, z); leftWallBatch.MultiTexCoord2f(0, 1.0f, 0.0f); leftWallBatch.Vertex3f(-10.0f, -10.0f, z - 10.0f); leftWallBatch.MultiTexCoord2f(0, 1.0f, 1.0f); leftWallBatch.Vertex3f(-10.0f, 10.0f, z - 10.0f); &#125; leftWallBatch.End(); //参考图 - rightWall.png rightWallBatch.Begin(GL_TRIANGLE_STRIP, 28, 1); for(z = 60.0f; z &gt;= 0.0f; z -=10.0f) &#123; rightWallBatch.MultiTexCoord2f(0, 0.0f, 0.0f); rightWallBatch.Vertex3f(10.0f, -10.0f, z); rightWallBatch.MultiTexCoord2f(0, 0.0f, 1.0f); rightWallBatch.Vertex3f(10.0f, 10.0f, z); rightWallBatch.MultiTexCoord2f(0, 1.0f, 0.0f); rightWallBatch.Vertex3f(10.0f, -10.0f, z - 10.0f); rightWallBatch.MultiTexCoord2f(0, 1.0f, 1.0f); rightWallBatch.Vertex3f(10.0f, 10.0f, z - 10.0f); &#125; rightWallBatch.End();&#125; 窗口设置123456789101112131415161718192021222324//改变视景体和视口，在改变窗口大小或初始化窗口调用void ChangeSize(int w, int h)&#123; if (h == 0) &#123; h = 1; &#125; glViewport(0, 0, w, h); //透视投影纵横比 GLfloat fAspect; fAspect = (GLfloat)w / (GLfloat)h; //设置透视投影 viewFrustum.SetPerspective(80.0f, fAspect, 1.0, 120.0); //获取到投影矩阵 projectionMatrix.LoadMatrix(viewFrustum.GetProjectionMatrix()); //通过变换管线来管理投影矩阵堆栈 transformPipeline.SetMatrixStacks(modelViewMatrix, projectionMatrix); &#125; 调用，绘制场景123456789101112131415161718192021222324252627282930313233343536void RenderScene(void)&#123; glClear(GL_COLOR_BUFFER_BIT); modelViewMatrix.PushMatrix(); modelViewMatrix.Translate(0.0f, 0.0f, viewZ); //纹理替换矩阵着色器 /* 参数1:GLT_SHADER_TEXTURE_REPLACE 参数2:模型视图矩阵 &amp; 投影矩阵 参数3:纹理层次 */ shaderManager.UseStockShader(GLT_SHADER_TEXTURE_REPLACE,transformPipeline.GetModelViewProjectionMatrix(),0); //地板 glBindTexture(GL_TEXTURE_2D, textures[TEXTURE_FLOOR]); floorBatch.Draw(); //天花板 glBindTexture(GL_TEXTURE_2D, textures[TEXTURE_CEILING]); ceilingBatch.Draw(); //左右墙壁 glBindTexture(GL_TEXTURE_2D, textures[TEXTURE_BRICK]); leftWallBatch.Draw(); rightWallBatch.Draw(); modelViewMatrix.PopMatrix(); glutSwapBuffers(); &#125; 效果图","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/categories/学习笔记/"}],"tags":[{"name":"opengl","slug":"opengl","permalink":"http://yoursite.com/tags/opengl/"}]},{"title":"OpenGL(七)-纹理(上)","slug":"OpenGL(七)-纹理(上)","date":"2019-02-19T16:38:42.000Z","updated":"2019-02-21T10:04:06.817Z","comments":true,"path":"2019/02/20/OpenGL(七)-纹理(上)/","link":"","permalink":"http://yoursite.com/2019/02/20/OpenGL(七)-纹理(上)/","excerpt":"设定金字塔坐标注意纹理坐标的设置方式:1234567//设置顶点对应的纹理坐标// s , t 相当于 x , y// MultiTexCoord2f(GLuint texture, GLclampf s, GLclampf t);//参数1:纹理的层次//参数2:s坐标//参数3:t坐标pyramidBatch.MultiTexCoord2f(0, 0.0f, 0.0f);","text":"设定金字塔坐标注意纹理坐标的设置方式:1234567//设置顶点对应的纹理坐标// s , t 相当于 x , y// MultiTexCoord2f(GLuint texture, GLclampf s, GLclampf t);//参数1:纹理的层次//参数2:s坐标//参数3:t坐标pyramidBatch.MultiTexCoord2f(0, 0.0f, 0.0f); 绘制金字塔纹理1.顶点/纹理坐标数据设置及图形绘制123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137GLBatch pyramidBatch;//绘制批次类 //1.pyramidBatch //通过三角形批次类pyramidBatch 来组件图形 //参数1:类型 //参数2:顶点数 6 * 3 = 18 //参数3:需要使用到纹理,默认为0,可以不写这个参数 pyramidBatch.Begin(GL_TRIANGLES, 18,1); //2.金字塔各个面的点坐标设置 //金字塔底部 //底部四边形 = 三角形X + 三角形Y //三角形X //----------vBlackLeft------------ //设置法线坐标-光照 pyramidBatch.Normal3f(0.0f, -1.0f, 0.0f); //设置顶点对应的纹理坐标 // MultiTexCoord2f(GLuint texture, GLclampf s, GLclampf t); //参数1:纹理的层次 //参数2:s坐标 //参数3:t坐标 pyramidBatch.MultiTexCoord2f(0, 0.0f, 0.0f); //设置顶点坐标 pyramidBatch.Vertex3f(-1.0f, -1.0f, -1.0f); //------vBackRight------------ pyramidBatch.Normal3f(0.0f, -1.0f, 0.0f); pyramidBatch.MultiTexCoord2f(0, 1.0f, 0.0f); pyramidBatch.Vertex3f(1.0f, -1.0f, -1.0f); //------vFrontRight点------------ pyramidBatch.Normal3f(0.0f, -1.0f, 0.0f); pyramidBatch.MultiTexCoord2f(0, 1.0f, 1.0f); pyramidBatch.Vertex3f(1.0f, -1.0f, 1.0f); //三角形Y pyramidBatch.Normal3f(0.0f, -1.0f, 0.0f); pyramidBatch.MultiTexCoord2f(0, 0.0f, 1.0f); pyramidBatch.Vertex3f(-1.0f, -1.0f, 1.0f); pyramidBatch.Normal3f(0.0f, -1.0f, 0.0f); pyramidBatch.MultiTexCoord2f(0, 0.0f, 0.0f); pyramidBatch.Vertex3f(-1.0f, -1.0f, -1.0f); pyramidBatch.Normal3f(0.0f, -1.0f, 0.0f); pyramidBatch.MultiTexCoord2f(0, 1.0f, 1.0f); pyramidBatch.Vertex3f(1.0f, -1.0f, 1.0f); //塔顶 M3DVector3f vApex = &#123;0.0f,1.0f,0.0f&#125;; M3DVector3f vFrontLeft = &#123;-1.0f,-1.0f,1.0f&#125;; M3DVector3f vFrontRight = &#123;1.0f,-1.0f,1.0f&#125;; M3DVector3f vBackLeft = &#123;-1.0f,-1.0f,-1.0f&#125;; M3DVector3f vBackRight = &#123;1.0f,-1.0f,-1.0f&#125;; //目的:为了临时存储法线向量 M3DVector3f n; //金字塔的前面 //三角形:(Apex,vFrontLeft,vFrontRight) //找法线 //m3dFindNormal(M3DVector3f result, const M3DVector3f point1, const M3DVector3f point2,const M3DVector3f point3); //参数1:结果 //参数2-4:3个顶点 m3dFindNormal(n, vApex, vFrontLeft, vFrontRight); //vApex pyramidBatch.Normal3fv(n); pyramidBatch.MultiTexCoord2f(0, 0.5, 1.0f); pyramidBatch.Vertex3fv(vApex); //vFrontLeft pyramidBatch.Normal3fv(n); pyramidBatch.MultiTexCoord2f(0, 0.0f, 0.0f); pyramidBatch.Vertex3fv(vFrontLeft); //vFrongRight pyramidBatch.Normal3fv(n); pyramidBatch.MultiTexCoord2f(0, 1.0f, 0.0f); pyramidBatch.Vertex3fv(vFrontRight); //金字塔的左边 //三角形:(Apex,vBackLeft,vFrontLeft) m3dFindNormal(n, vApex, vBackLeft, vFrontLeft); //vApex pyramidBatch.Normal3fv(n); pyramidBatch.MultiTexCoord2f(0, 0.5f, 1.0f); pyramidBatch.Vertex3fv(vApex); //vBackLeft pyramidBatch.Normal3fv(n); pyramidBatch.MultiTexCoord2f(0, 1.0f, 0.0f); pyramidBatch.Vertex3fv(vBackLeft); //vFrontLeft pyramidBatch.Normal3fv(n); pyramidBatch.MultiTexCoord2f(0, 0.0f, 0.0f); pyramidBatch.Vertex3fv(vFrontLeft); //金字塔右边 //三角形：（vApex, vFrontRight, vBackRight） m3dFindNormal(n, vApex, vFrontRight, vBackRight); pyramidBatch.Normal3fv(n); pyramidBatch.MultiTexCoord2f(0, 0.5f, 1.0f); pyramidBatch.Vertex3fv(vApex); pyramidBatch.Normal3fv(n); pyramidBatch.MultiTexCoord2f(0, 1.0f, 0.0f); pyramidBatch.Vertex3fv(vFrontRight); pyramidBatch.Normal3fv(n); pyramidBatch.MultiTexCoord2f(0, 0.0f, 0.0f); pyramidBatch.Vertex3fv(vBackRight); //金字塔后边 //三角形：（vApex, vBackRight, vBackLeft） m3dFindNormal(n, vApex, vBackRight, vBackLeft); pyramidBatch.Normal3fv(n); pyramidBatch.MultiTexCoord2f(0, 0.5f, 1.0f); pyramidBatch.Vertex3fv(vApex); pyramidBatch.Normal3fv(n); pyramidBatch.MultiTexCoord2f(0, 0.0f, 0.0f); pyramidBatch.Vertex3fv(vBackRight); pyramidBatch.Normal3fv(n); pyramidBatch.MultiTexCoord2f(0, 1.0f, 0.0f); pyramidBatch.Vertex3fv(vBackLeft); //结束批次设置 pyramidBatch.End(); 2.加载2D纹理1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980// 将TGA文件加载为2D纹理。//参数1:纹理文件名称//参数2:缩小时过滤器使用的哪一种//参数3:放大小时过滤器使用的哪一种//参数4:纹理坐标环绕方式bool LoadTGATexture(const char *szFileName, GLenum minFilter, GLenum magFilter, GLenum wrapMode)&#123; GLbyte *pBits; int nWidth,nHeight,nComponents; GLenum eFormat; //1.读取纹理的像素 //参数1:纹理文件的名称 //参数2:文件的宽度地址 //参数3:文件的高度地址 //参数4:文件的组件地址 //参数5:文件格式地址 //返回值:pBits ,指向图像数据的指针 pBits = gltReadTGABits(szFileName, &amp;nWidth, &amp;nHeight, &amp;nComponents, &amp;eFormat); if (pBits == NULL) &#123; printf(\"读取纹理像素失败\\n\"); return false; &#125; //2.设置纹理参数 //设置s,t的环绕方式 //glTexParameteri (GLenum target, GLenum pname, GLint param); //参数1:纹理维度 //参数2:为S/T坐标设置环绕模式 //参数3:wrapMode,环绕模式 glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, wrapMode); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, wrapMode); //设置放大\\缩小的过滤方式 glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, minFilter); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, magFilter); //3.精密包装像素数据 //glPixelStorei (GLenum pname, GLint param); //参数1:GL_UNPACK_ALIGNMENT ,OpenGL 如何从数据缓存区中解包图像数据 //参数2:设置GL_UNPACK_ALIGNMENT的值 glPixelStorei(GL_UNPACK_ALIGNMENT, 1); //4.载入纹理 //glTexImage2D (GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels); //参数1:纹理的维度 //参数2:mip贴图层次 //参数3:加载纹理颜色成分(从读取像素图获取的) //参数4:加载纹理的宽 //参数5:加载纹理的高 //参数6:纹理的边框 //参数7:像素数据的类型 //参数8:指向纹理数据的指针 //详细可参考PPT glTexImage2D(GL_TEXTURE_2D, 0, nComponents, nWidth, nHeight, 0, eFormat, GL_UNSIGNED_BYTE, pBits); //使用完释放 free(pBits); //只有minFilter 等于以下四种模式，才可以生成Mip贴图 //GL_NEAREST_MIPMAP_NEAREST具有非常好的性能，并且闪烁现象非常弱 //GL_LINEAR_MIPMAP_NEAREST常常用于对游戏进行加速，它使用了高质量的线性过滤器 //GL_LINEAR_MIPMAP_LINEAR 和GL_NEAREST_MIPMAP_LINEAR 过滤器在Mip层之间执行了一些额外的插值，以消除他们之间的过滤痕迹。 //GL_LINEAR_MIPMAP_LINEAR 三线性Mip贴图。纹理过滤的黄金准则，具有最高的精度。 if(minFilter == GL_LINEAR_MIPMAP_LINEAR || minFilter == GL_LINEAR_MIPMAP_NEAREST || minFilter == GL_NEAREST_MIPMAP_LINEAR || minFilter == GL_NEAREST_MIPMAP_NEAREST) //加载Mip,纹理生成所有的Mip层 //参数：GL_TEXTURE_1D、GL_TEXTURE_2D、GL_TEXTURE_3D glGenerateMipmap(GL_TEXTURE_2D); return true;&#125; 3.SetUp12345678910111213141516171819202122232425262728293031323334353637void SetupRC()&#123; glClearColor(0.7f, 0.7f,0.7f, 1.0f); shaderManager.InitializeStockShaders(); //开启深度测试 glEnable(GL_DEPTH_TEST); //纹理对象的处理 //1.分配纹理对象 // glGenTextures (GLsizei n, GLuint *textures); //参数1:纹理对象的个数 //参数2:纹理对象的指针 glGenTextures(1, &amp;textureID); //2.绑定纹理状态 //glBindTexture (GLenum target, GLuint texture); //参数1:纹理的状态,GL_TEXTURE_1D\\GL_TEXTURE_2D\\GL_TEXTURE_3D glBindTexture(GL_TEXTURE_2D, textureID); //3.将TGA文件加载成2D纹理 //函数是开发者自己设计的 //参数1:纹理文件名称 //参数2:缩小时过滤器使用的哪一种 //参数3:放大小时过滤器使用的哪一种 //参数4:纹理坐标环绕方式 LoadTGATexture(\"brick.tga\", GL_LINEAR, GL_LINEAR, GL_CLAMP_TO_EDGE); //4.设置渲染图像的顶点--金字塔 MakePyramid(pyramidBatch); cameraFrame.MoveForward(-10.0); &#125; 4.渲染1234567891011121314151617181920212223242526272829303132333435363738394041424344454647void RenderScene(void)&#123; //光照位置 static GLfloat vLightPos[] = &#123;1.0f,1.0f,0.0f&#125;; //关照颜色 static GLfloat vWhite[] = &#123;1.0f,0.0f,0.0f,1.0f&#125;; //glClear(GL_COLOR_BUFFER_BIT| GL_DEPTH_BUFFER|GL_STENCIL_BUFFER_BIT); glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT); modelViewMatrix.PushMatrix(); //观察者 M3DMatrix44f mCamera; cameraFrame.GetCameraMatrix(mCamera); modelViewMatrix.MultMatrix(mCamera); // M3DMatrix44f mObjectFrame; objectFrame.GetMatrix(mObjectFrame); modelViewMatrix.MultMatrix(mObjectFrame); //错误地方!!! //glBindTexture(GL_TEXTURE_2D, 0); glBindTexture(GL_TEXTURE_2D, textureID); //点光源着色器 //参数1:GLT_SHADER_TEXTURE_POINT_LIGHT_DIFF //参数2:模型视图矩阵 //参数3:投影矩阵 //参数4:光源的位置 //参数5:光的颜色 //参数6:图形颜色(如使用了纹理,则设置为0) shaderManager.UseStockShader(GLT_SHADER_TEXTURE_POINT_LIGHT_DIFF,transformPipeline.GetModelViewMatrix(),transformPipeline.GetProjectionMatrix(),vLightPos,vWhite,0); pyramidBatch.Draw(); modelViewMatrix.PopMatrix(); glutSwapBuffers(); &#125; 效果图","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/categories/学习笔记/"}],"tags":[{"name":"opengl","slug":"opengl","permalink":"http://yoursite.com/tags/opengl/"}]},{"title":"OpenGL(六)-坐标系统","slug":"OpenGL(六)-坐标系统","date":"2019-02-19T16:38:41.000Z","updated":"2019-02-25T09:16:49.100Z","comments":false,"path":"2019/02/20/OpenGL(六)-坐标系统/","link":"","permalink":"http://yoursite.com/2019/02/20/OpenGL(六)-坐标系统/","excerpt":"在OpenGL 中有5种坐标系。1.局部坐标系(物体空间)2.世界空间3.观察空间(视觉空间)4.裁剪空间5.屏幕空间 下图是一个顶点最终转化到片段之前需要经历的所有不同的状态变化: 局部空间： 指的是物体所在的坐标空间，即是建立一个建模软件创建一个模型立方体。创建的立方体的原点可能是[0,0,0]。但它在你的程序里可能处于不同的位置。所以你的模型文件的顶点都以[0,0,0]这个为初始位置。但是他们最终显示在世界坐标系的那个位置不由局部坐标系决定。 你的模型文件所有的顶点都处于局部空间中。 比如我创建一个立体箱子,它的范围和原点都是针对局部坐标的。","text":"在OpenGL 中有5种坐标系。1.局部坐标系(物体空间)2.世界空间3.观察空间(视觉空间)4.裁剪空间5.屏幕空间 下图是一个顶点最终转化到片段之前需要经历的所有不同的状态变化: 局部空间： 指的是物体所在的坐标空间，即是建立一个建模软件创建一个模型立方体。创建的立方体的原点可能是[0,0,0]。但它在你的程序里可能处于不同的位置。所以你的模型文件的顶点都以[0,0,0]这个为初始位置。但是他们最终显示在世界坐标系的那个位置不由局部坐标系决定。 你的模型文件所有的顶点都处于局部空间中。 比如我创建一个立体箱子,它的范围和原点都是针对局部坐标的。 世界空间： 如果我们将我们所有的物体导入到程序当中，它们有可能会全挤在世界的原点(0, 0, 0)上，这并不是我们想要的结果。我们想为每一个物体定义一个位置，从而能在更大的世界当中放置它们。世界空间中的坐标正如其名：是指顶点相对于（游戏）世界的坐标。如果你希望将物体分散在世界上摆放（特别是非常真实的那样），这就是你希望物体变换到的空间。物体的坐标将会从局部变换到世界空间；该变换是由模型矩阵(Model Matrix)实现的 模型矩阵是一种变换矩阵，它能通过对物体进行位移、缩放、旋转来将它置于它本应该在的位置或朝向。你可以将它想像为变换一个房子，你需要先将它缩小（它在局部空间中太大了），并将其位移至郊区的一个小镇，然后在y轴上往左旋转一点以搭配附近的房子。你也可以把上一节将箱子到处摆放在场景中用的那个矩阵大致看作一个模型矩阵；我们将箱子的局部坐标变换到场景/世界中的不同位置。 观察空间： 观察空间经常被人们称之OpenGL的摄像机(Camera)（所以有时也称为摄像机空间(Camera Space)或视觉空间(Eye Space)）。观察空间是将世界空间坐标转化为用户视野前方的坐标而产生的结果。因此观察空间就是从摄像机的视角所观察到的空间。而这通常是由一系列的位移和旋转的组合来完成，平移/旋转场景从而使得特定的对象被变换到摄像机的前方。这些组合在一起的变换通常存储在一个观察矩阵(View Matrix)里，它被用来将世界坐标变换到观察空间 裁剪空间： 在一个顶点着色器运行的最后，OpenGL期望所有的坐标都能落在一个特定的范围内，且任何在这个范围之外的点都应该被裁剪掉(Clipped)。被裁剪掉的坐标就会被忽略，所以剩下的坐标就将变为屏幕上可见的片段。这也就是裁剪空间(Clip Space)名字的由来。 因为将所有可见的坐标都指定在-1.0到1.0的范围内不是很直观，所以我们会指定自己的坐标集(Coordinate Set)并将它变换回标准化设备坐标系，就像OpenGL期望的那样。 为了将顶点坐标从观察变换到裁剪空间，我们需要定义一个投影矩阵(Projection Matrix)，它指定了一个范围的坐标，比如在每个维度上的-1000到1000。投影矩阵接着会将在这个指定的范围内的坐标变换为标准化设备坐标的范围(-1.0, 1.0)。所有在范围外的坐标不会被映射到在-1.0到1.0的范围之间，所以会被裁剪掉。在上面这个投影矩阵所指定的范围内，坐标(1250, 500, 750)将是不可见的，这是由于它的x坐标超出了范围，它被转化为一个大于1.0的标准化设备坐标，所以被裁剪掉了。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/categories/学习笔记/"}],"tags":[{"name":"opengl","slug":"opengl","permalink":"http://yoursite.com/tags/opengl/"}]},{"title":"OpenGL(五)-矩阵变换","slug":"OpenGL(五)-矩阵变换","date":"2019-02-19T16:38:40.000Z","updated":"2019-02-21T10:03:52.070Z","comments":true,"path":"2019/02/20/OpenGL(五)-矩阵变换/","link":"","permalink":"http://yoursite.com/2019/02/20/OpenGL(五)-矩阵变换/","excerpt":"关键函数讲解平移123456789101112//创建单元矩阵 M3DMatrix44f m3;m3dLoadIdentity44(m3);/* m3dTranslationMatrix44(M3DMatrix44f m, float x, float y, float z) 参数1:结果矩阵,平移之后的结果矩阵 参数2:沿着X轴移动多少,正数\\负数 参数3:沿着Y轴移动多少,正数\\负数 参数4:沿着Z轴移动多少,正数\\负数 */m3dTranslationMatrix44(m3, 0.0f, 10.0f, 0.0f);","text":"关键函数讲解平移123456789101112//创建单元矩阵 M3DMatrix44f m3;m3dLoadIdentity44(m3);/* m3dTranslationMatrix44(M3DMatrix44f m, float x, float y, float z) 参数1:结果矩阵,平移之后的结果矩阵 参数2:沿着X轴移动多少,正数\\负数 参数3:沿着Y轴移动多少,正数\\负数 参数4:沿着Z轴移动多少,正数\\负数 */m3dTranslationMatrix44(m3, 0.0f, 10.0f, 0.0f); 旋转1234567891011121314151617181920 /* m3dRotationMatrix44(M3DMatrix44f m, float angle, float x, float y, float z); 参数1:结果矩阵,旋转之后的结果矩阵 参数2:旋转多少弧度 参数3:是否围绕X轴旋转,是(1),不是(0) 参数4:是否围绕Y轴旋转,是(1),不是(0) 参数5:是否围绕Z轴旋转,是(1),不是(0) */ m3dRotationMatrix44(m3, m3dDegToRad(45.0f), 1.0f, 0.0f, 0.0f);``` ### 缩放```objc /* void m3dScaleMatrix44(M3DMatrix44f m, float xScale, float yScale, float zScale) 参数1:结果矩阵 参数2:围绕X轴放大\\缩小;放大x&gt;1,缩小:0.5f 参数3:围绕Y轴放大\\缩小;放大x&gt;1,缩小:0.5f 参数4:围绕Z轴放大\\缩小;放大x&gt;1,缩小:0.5f */ m3dScaleMatrix44(m3, 1.0f, 10.0f, 1.0f); 案例1 : 利用矩阵的平移、旋转、综合变化等, 实现矩阵的移动.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119GLBatch squareBatch;GLfloat blockSize = 0.1f;GLfloat vVerts[] = &#123; -blockSize, -blockSize, 0.0f, blockSize, -blockSize, 0.0f, blockSize, blockSize, 0.0f, -blockSize, blockSize, 0.0f&#125;;GLfloat xPos = 0.0f;GLfloat yPos = 0.0f;void SetupRC()&#123; //背景颜色 glClearColor(0.0f, 0.0f, 1.0f, 1.0f ); shaderManager.InitializeStockShaders(); // 加载矩形 squareBatch.Begin(GL_TRIANGLE_FAN, 4); squareBatch.CopyVertexData3f(vVerts); squareBatch.End();&#125;//移动（移动只是计算了X,Y移动的距离，以及碰撞检测）void SpecialKeys(int key, int x, int y)&#123; GLfloat stepSize = 0.025f; if(key == GLUT_KEY_UP) yPos += stepSize; if(key == GLUT_KEY_DOWN) yPos -= stepSize; if(key == GLUT_KEY_LEFT) xPos -= stepSize; if(key == GLUT_KEY_RIGHT) xPos += stepSize; // 碰撞检测 if(xPos &lt; (-1.0f + blockSize)) xPos = -1.0f + blockSize; if(xPos &gt; (1.0f - blockSize)) xPos = 1.0f - blockSize; if(yPos &lt; (-1.0f + blockSize)) yPos = -1.0f + blockSize; if(yPos &gt; (1.0f - blockSize)) yPos = 1.0f - blockSize; // 每次操作方向键之后, 重新调用RenderScene进行新的场景渲染 glutPostRedisplay();&#125;void RenderScene(void)&#123; glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT); GLfloat vRed[] = &#123; 1.0f, 0.0f, 0.0f, 1.0f &#125;; //!!!矩阵变化 - 关键代码!!! M3DMatrix44f mFinalTransform, mTranslationMatrix, mRotationMatrix; //平移 xPos,yPos m3dTranslationMatrix44(mTranslationMatrix, xPos, yPos, 0.0f); // 每次重绘时，旋转5度 static float yRot = 0.0f; yRot += 5.0f; m3dRotationMatrix44(mRotationMatrix, m3dDegToRad(yRot), 0.0f, 0.0f, 1.0f); //将旋转和移动的结果合并到mFinalTransform 中 m3dMatrixMultiply44(mFinalTransform, mTranslationMatrix, mRotationMatrix); //将矩阵结果提交到固定着色器（平面着色器）中。 shaderManager.UseStockShader(GLT_SHADER_FLAT, mFinalTransform, vRed); //!!!矩形重新绘制, 即会出现一个既平移了方向又旋转了角度的新矩形 squareBatch.Draw(); // 执行缓冲区交换 glutSwapBuffers();&#125;void ChangeSize(int w, int h)&#123; glViewport(0, 0, w, h);&#125;int main(int argc, char* argv[])&#123; gltSetWorkingDirectory(argv[0]); glutInit(&amp;argc, argv); glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGBA | GLUT_DEPTH); glutInitWindowSize(600, 600); glutCreateWindow(\"Move Block with Arrow Keys\"); GLenum err = glewInit(); if (GLEW_OK != err) &#123; fprintf(stderr, \"Error: %s\\n\", glewGetErrorString(err)); return 1; &#125; glutReshapeFunc(ChangeSize);//设置视口大小 glutDisplayFunc(RenderScene);//渲染场景 glutSpecialFunc(SpecialKeys);//键盘方向键操作 SetupRC(); glutMainLoop(); return 0;&#125; 效果图:注: 本例是键盘的上下左右方向键来控制矩形的旋转平移, 具体代码参见上面 案例2 : 利用模型视图矩阵和投影矩阵让一个球体旋转绘制球体123gltMakeSphere(torusBatch, 0.4f, 10, 20);glPolygonMode(GL_FRONT_AND_BACK, GL_LINE); 设置模型视图矩阵 和 投影矩阵12345678910111213141516171819202122232425262728293031323334//建立一个基于时间变化的动画static CStopWatch rotTimer;//当前时间 * 60sfloat yRot = rotTimer.GetElapsedSeconds() * 60.0f;glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);//矩阵变量M3DMatrix44f mTranlate,mRotate,mModelView,mModelViewProjection;//将圆球像Z轴负方向移动2.5个单位长度m3dTranslationMatrix44(mTranlate, 0.0f , 0.0f,-2.5f);//旋转m3dRotationMatrix44(mRotate, m3dDegToRad(yRot), 0.0f, 1.0f, 0.0f);//将平移和旋转的矩阵进行叉乘,产生一个新的矩阵mModelViewm3dMatrixMultiply44(mModelView, mTranlate, mRotate);//模型视图矩阵 和 投影矩阵//将投影矩阵 与 模型视图矩阵进行叉乘 ,将变化最终结果通过矩阵叉乘的方式应用到mModelViewProjection中来m3dMatrixMultiply44(mModelViewProjection, viewFrustum.GetProjectionMatrix(), mModelView);GLfloat vBlack[] = &#123;0.0f,0.0f,0.0f,1.0f&#125;;//平面着色器来渲染图像shaderManager.UseStockShader(GLT_SHADER_FLAT,mModelViewProjection,vBlack);//开始绘图torusBatch.Draw();glutSwapBuffers();glutPostRedisplay(); 效果图","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/categories/学习笔记/"}],"tags":[{"name":"opengl","slug":"opengl","permalink":"http://yoursite.com/tags/opengl/"}]},{"title":"OpenGL(四)-两种方式实现抗锯齿效果","slug":"OpenGL(四)-两种方式实现抗锯齿效果","date":"2019-02-19T16:38:39.000Z","updated":"2019-02-21T10:03:43.262Z","comments":true,"path":"2019/02/20/OpenGL(四)-两种方式实现抗锯齿效果/","link":"","permalink":"http://yoursite.com/2019/02/20/OpenGL(四)-两种方式实现抗锯齿效果/","excerpt":"方式一 : 利用混合(GLBlend)实现抗锯齿","text":"方式一 : 利用混合(GLBlend)实现抗锯齿 核心代码如下:12345678910111213141516171819202122232425262728293031323334// 选择菜单void ProcessMenu(int value)&#123; switch (value) &#123; case 1: //打开抗锯齿功能 //1.开启混合功能 glEnable(GL_BLEND); //2.指定混合因子 //注意:如果你修改了混合方程式,当你使用混合抗锯齿功能时,请一定要改为默认混合方程式 glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); //3.开启对点\\线\\多边形的抗锯齿功能 glEnable(GL_POINT_SMOOTH); glEnable(GL_LINE_SMOOTH); glEnable(GL_POLYGON_SMOOTH); break; case 2: //关闭抗锯齿功能 glDisable(GL_BLEND); glDisable(GL_LINE_SMOOTH); glDisable(GL_POINT_SMOOTH); glDisable(GL_POLYGON_SMOOTH); break; default: break; &#125; glutPostRedisplay();&#125; 方式二 : 利用多重采样实现抗锯齿12345678//用多重采样来解决锯齿问题.可选 glEnable(GLUT_MULTISAMPLE); //绘制 moonBatch.Draw(); //绘制完成,则关闭 glDisable(GLUT_MULTISAMPLE); 效果图: 关闭抗锯齿: 打开抗锯齿:","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/categories/学习笔记/"}],"tags":[{"name":"opengl","slug":"opengl","permalink":"http://yoursite.com/tags/opengl/"}]},{"title":"OpenGL(三)-深度测试","slug":"OpenGL(三)-深度测试","date":"2019-02-19T16:38:38.000Z","updated":"2019-02-21T10:03:36.278Z","comments":true,"path":"2019/02/20/OpenGL(三)-深度测试/","link":"","permalink":"http://yoursite.com/2019/02/20/OpenGL(三)-深度测试/","excerpt":"什么叫深度?所谓深度,就是在坐标系中,像素Z坐标距离观察者的距离.观察者可以在任何位置.OpenGL会有专门一块缓存区来存放Z值, 即深度缓冲区. 深度缓冲区作用?一般情况下,我们绘制图形时,后面绘制的会覆盖前面的图形.这样就会产生一个性能问题:就是遮盖部分,先绘制的会被覆盖,那么这块区域就是无意义的绘制.深度测试就是用来解决这个问题的.它是如何处理的呢?有了深度缓冲区之后,绘制的时候会检查Z值,靠近观察者的不覆盖, 远离观察者的被覆盖,而不是靠绘制顺序来决定.","text":"什么叫深度?所谓深度,就是在坐标系中,像素Z坐标距离观察者的距离.观察者可以在任何位置.OpenGL会有专门一块缓存区来存放Z值, 即深度缓冲区. 深度缓冲区作用?一般情况下,我们绘制图形时,后面绘制的会覆盖前面的图形.这样就会产生一个性能问题:就是遮盖部分,先绘制的会被覆盖,那么这块区域就是无意义的绘制.深度测试就是用来解决这个问题的.它是如何处理的呢?有了深度缓冲区之后,绘制的时候会检查Z值,靠近观察者的不覆盖, 远离观察者的被覆盖,而不是靠绘制顺序来决定. 如何使用深度缓冲区测试?glEnable(GLDEPTHTEST);开启之后,就会先测试深度值再绘制默认情况下, Z值小的会被覆盖 如果观察者,在Z轴的正方向,Z值大则靠近观察者如果观察者,在Z轴的负方向,Z值小则靠近观察者 如何解决深度值相同,造成的冲突问题? 第一种方法:在第二次绘制时, 稍微偏移一点点解决这个问题.注意:必须非常小心确保Z值的间隙.(比如贴在飞机上的五角星会悬浮起来的风险) 第二种方法:采用glPolygonOffset函数,使得可以调节片段的深度值.使深度值偏移而不产生悬浮.","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/categories/学习笔记/"}],"tags":[{"name":"opengl","slug":"opengl","permalink":"http://yoursite.com/tags/opengl/"}]},{"title":"OpenGL(二)-基本图元绘制","slug":"OpenGL(二)-基本图元绘制","date":"2019-02-19T16:38:37.000Z","updated":"2019-02-21T10:03:28.606Z","comments":true,"path":"2019/02/20/OpenGL(二)-基本图元绘制/","link":"","permalink":"http://yoursite.com/2019/02/20/OpenGL(二)-基本图元绘制/","excerpt":"OpenGL与着色器在OpenGL 3.0之前，OpenGL包含一个固定功能的管线，它可以在不使用着色器的情况下处理几何与像素数据。从3.1版本开始，固定管线从核心模式去掉。因此现在需要使用着色器来完成工作.我们会使用GLSL,(OpenGL Shading Language，它是在OpenGL 2.0版本发布的)。 语法与“C、C++”类似。","text":"OpenGL与着色器在OpenGL 3.0之前，OpenGL包含一个固定功能的管线，它可以在不使用着色器的情况下处理几何与像素数据。从3.1版本开始，固定管线从核心模式去掉。因此现在需要使用着色器来完成工作.我们会使用GLSL,(OpenGL Shading Language，它是在OpenGL 2.0版本发布的)。 语法与“C、C++”类似。 基础图形管线OpenGL中的图元只不过是顶点的集合以预定义的方式结合在一起。管线分为:2个部分，上半部分是 客户机端，下半部分是服务器端。服务器 和 客户端 在功能和运行上都是异步的。它们是各自独立的软件块或硬件块。 三种向OpenGL 着色器传递渲染数据的方法: 属性: 就是对一个顶点都要作改变的数据元素。实际上，顶点位置本身就是一个属性。属性可以是浮点类型、整型、布尔类型. Uniform: 通过设置Uniform 变量发送一个图元批次命令。Uniform 变量实际上可以无限次限制地使用，比如设置一个应用于整个表面的单个颜色值。还可以设置一个时间值 纹理 基本图元类型 注意着重区分以下三种绘制方式的区别 存储着色器的使用着色器有以下分类：• 单位着色器• 平面着色器• 上色着色器• 默认光源着色器• 点光源着色器• 纹理替换矩阵• 纹理调整着色器• 纹理光源着色器123456//定义着色器GLShaderMananger shaderManager;//初始化着色器 shaderManager.InitalizeStockShaders()//使用shaderManager userStockManager(参数列表) 单位着色器 GLShaderManager::UserStockShader(GLT_ATTRIBUTE_VERTEX,GLfloat vColor[4]); 平面着色器 GLShaderManager::UserStockShader(GLT_SHADER_FLAT,GLfloat mvp[16],GLfloat vColor[4]); 上色着色器 GLShaderManager::UserStockShader(GLT_SHADER_SHADED,GLfloat mvp[16]); 默认光源着色器 GLShaderManager::UserStockShader(GLT_SHADER_DEFAULT_LIGHT,GLfloat mvMatrix[16],GLfloat pMatrix[16],GLfloat vColor[4]); 点光源着色器 GLShaderManager::UserStockShader(GLT_SHADER_DEFAULT_LIGHT_DIEF,GLfloat mvMatrix[16],GLfloat pMatrix[16],GLfloat vLightPos[3],GLfloat vColor[4]); 纹理替换矩阵着色器 GLShaderManager::UserStockShader(GLT_SHADER_TEXTURE_REPLACE,GLfloat mvMatrix[16],GLint nTextureUnit); 纹理调整着色器 GLShaderManager::UserStockShader(GLT_SHADER_TEXTURE_MODULATE,GLfloat mvMatrix[16],GLfloat vColor[4],GLint nTextureUnit); 纹理光源着色器 GLShaderManager::UserStockShader(GLT_SHADER_TEXTURE_POINT_LIGHT_DIEF,GLfloat mvMatrix[16],GLfloat pMatrix[16],GLfloat vLightPos[3],GLfloat vBaseColor[4],GLint nTextureUnit); 绘制不同类型的图元123456789101112131415161718192021// 各种需要的类GLShaderManager shaderManager;GLMatrixStack modelViewMatrix;GLMatrixStack projectionMatrix;GLFrame cameraFrame;GLFrame objectFrame;//投影矩阵GLFrustum viewFrustum;//容器类（7种不同的图元对应7种容器对象）GLBatch pointBatch;GLBatch lineBatch;GLBatch lineStripBatch;GLBatch lineLoopBatch;GLBatch triangleBatch;GLBatch triangleStripBatch;GLBatch triangleFanBatch;//几何变换的管道GLGeometryTransform transformPipeline;M3DMatrix44f shadowMatrix; 点/线/线段/线环绘制12345678910111213141516171819202122232425262728293031323334// 准备一些随机点数据 GLfloat vCoast[24][3] = &#123; &#123;2.80, 1.20, 0.0 &#125;, &#123;2.0, 1.20, 0.0 &#125;, &#123;2.0, 1.08, 0.0 &#125;, &#123;2.0, 1.08, 0.0 &#125;, &#123;0.0, 0.80, 0.0 &#125;, &#123;-.32, 0.40, 0.0 &#125;, &#123;-.48, 0.2, 0.0 &#125;, &#123;-.40, 0.0, 0.0 &#125;, &#123;-.60, -.40, 0.0 &#125;, &#123;-.80, -.80, 0.0 &#125;, &#123;-.80, -1.4, 0.0 &#125;, &#123;-.40, -1.60, 0.0 &#125;, &#123;0.0, -1.20, 0.0 &#125;, &#123; .2, -.80, 0.0 &#125;, &#123;.48, -.40, 0.0 &#125;, &#123;.52, -.20, 0.0 &#125;, &#123;.48, .20, 0.0 &#125;, &#123;.80, .40, 0.0 &#125;, &#123;1.20, .80, 0.0 &#125;, &#123;1.60, .60, 0.0 &#125;, &#123;2.0, .60, 0.0 &#125;, &#123;2.2, .80, 0.0 &#125;, &#123;2.40, 1.0, 0.0 &#125;, &#123;2.80, 1.0, 0.0 &#125;&#125;; //用点的形式绘制(GL_POINTS) pointBatch.Begin(GL_POINTS, 24); pointBatch.CopyVertexData3f(vCoast); pointBatch.End(); //通过线的形式绘制(GL_LINES) lineBatch.Begin(GL_LINES, 24); lineBatch.CopyVertexData3f(vCoast); lineBatch.End(); //通过线段的形式绘制(GL_LINE_STRIP) lineStripBatch.Begin(GL_LINE_STRIP, 24); lineStripBatch.CopyVertexData3f(vCoast); lineStripBatch.End(); //通过线环的形式绘制(GL_LINE_LOOP) lineLoopBatch.Begin(GL_LINE_LOOP, 24); lineLoopBatch.CopyVertexData3f(vCoast); lineLoopBatch.End(); 效果如下: 三角形绘制方式 - GL_TRIANGLES123456789101112131415161718192021222324252627 //通过三角形绘制(GL_TRIANGLES) -- 生成一个金字塔的形状 GLfloat vPyramid[12][3] = &#123; -2.0f, 0.0f, -2.0f, 2.0f, 0.0f, -2.0f, 0.0f, 4.0f, 0.0f, 2.0f, 0.0f, -2.0f, 2.0f, 0.0f, 2.0f, 0.0f, 4.0f, 0.0f, 2.0f, 0.0f, 2.0f, -2.0f, 0.0f, 2.0f, 0.0f, 4.0f, 0.0f, -2.0f, 0.0f, 2.0f, -2.0f, 0.0f, -2.0f, 0.0f, 4.0f, 0.0f&#125;; //GL_TRIANGLES 每3个顶点定义一个新的三角形 triangleBatch.Begin(GL_TRIANGLES, 12); triangleBatch.CopyVertexData3f(vPyramid); triangleBatch.End();``` * 效果图:![GL_TRIANGLES.png](http://upload-images.jianshu.io/upload_images/1352344-a577c287b2f55072.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)###### 三角形扇绘制方式 - GL_TRIANGLE_FAN // 三角形扇绘制(GL_TRIANGLE_FAN) -- 生成一个六边形 GLfloat vPoints[100][3]; //超过我们需要的数组 int nVerts = 0; //半径 GLfloat r = 3.0f; //原点(x,y,z) = (0,0,0); vPoints[nVerts][0] = 0.0f; vPoints[nVerts][1] = 0.0f; vPoints[nVerts][2] = 0.0f; //M3D_2PI 就是2Pi 的意思，就一个圆的意思。 绘制圆形 for(GLfloat angle = 0; angle &lt; M3D_2PI; angle += M3D_2PI / 6.0f) { //数组下标自增（每自增1次就表示一个顶点） nVerts++; /* 弧长=半径*角度,这里的角度是弧度制,不是平时的角度制 既然知道了cos值,那么角度=arccos,求一个反三角函数就行了 */ //x点坐标 cos(angle) * 半径 vPoints[nVerts][0] = float(cos(angle)) * r; //y点坐标 sin(angle) * 半径 vPoints[nVerts][1] = float(sin(angle)) * r; //z点的坐标 vPoints[nVerts][2] = -0.5f; } // 结束扇形 : 前面一共绘制7个顶点（包括圆心） printf(&quot;三角形扇形顶点数:%d\\n&quot;,nVerts); //添加闭合的终点, 若不添加, 则三角形扇形是无法闭合的。 nVerts++; vPoints[nVerts][0] = r; vPoints[nVerts][1] = 0; vPoints[nVerts][2] = 0.0f; //GL_TRIANGLE_FAN 以一个圆心为中心呈扇形排列，共用相邻顶点的一组三角形 triangleFanBatch.Begin(GL_TRIANGLE_FAN, 8); triangleFanBatch.CopyVertexData3f(vPoints); triangleFanBatch.End(); 1234* 效果图:![GL_TRIANGLE_FAN.png](http://upload-images.jianshu.io/upload_images/1352344-ec20836c62236f9b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)###### 三角形条带绘制方式 - GL_TRIANGLE_STRIP //三角形条带绘制(GL_TRIANGLE_STRIP) -- 生成一个小环或圆柱段 //顶点下标 int iCounter = 0; //半径 GLfloat radius = 3.0f; //从0度~360度，以0.3弧度为步长 for(GLfloat angle = 0.0f; angle &lt;= (2.0f*M3D_PI); angle += 0.3f) { //或许圆形的顶点的X,Y GLfloat x = radius * sin(angle); GLfloat y = radius * cos(angle); //绘制2个三角形（他们的x,y顶点一样，只是z点不一样） vPoints[iCounter][0] = x; vPoints[iCounter][1] = y; vPoints[iCounter][2] = -0.5; iCounter++; vPoints[iCounter][0] = x; vPoints[iCounter][1] = y; vPoints[iCounter][2] = 0.5; iCounter++; } // 关闭循环 printf(&quot;三角形带的顶点数：%d\\n&quot;,iCounter); //结束循环，在循环位置生成2个三角形 vPoints[iCounter][0] = vPoints[0][0]; vPoints[iCounter][1] = vPoints[0][1]; vPoints[iCounter][2] = -0.5; iCounter++; vPoints[iCounter][0] = vPoints[1][0]; vPoints[iCounter][1] = vPoints[1][1]; vPoints[iCounter][2] = 0.5; iCounter++; // GL_TRIANGLE_STRIP 共用一个条带（strip）上的顶点的一组三角形 triangleStripBatch.Begin(GL_TRIANGLE_STRIP, iCounter); triangleStripBatch.CopyVertexData3f(vPoints); triangleStripBatch.End(); ` 效果图:","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/categories/学习笔记/"}],"tags":[{"name":"opengl","slug":"opengl","permalink":"http://yoursite.com/tags/opengl/"}]},{"title":"OpenGL(一)-初识OpenGL及其在Mac上的环境搭建","slug":"OpenGL(一)-初识OpenGL及其在Mac上的环境搭建","date":"2019-02-19T16:38:36.000Z","updated":"2019-02-21T09:59:43.161Z","comments":true,"path":"2019/02/20/OpenGL(一)-初识OpenGL及其在Mac上的环境搭建/","link":"","permalink":"http://yoursite.com/2019/02/20/OpenGL(一)-初识OpenGL及其在Mac上的环境搭建/","excerpt":"OpenGL是一种用于创建实时3D图像的编程接口。 走向3D三维(3D)表示一个正在描述或显示的物体具有三个维度：宽度，高度，深度。几个世纪以来，艺术家们已经知道如何让一幅画有立体感并具有真实感的深度，通过颜料在二维画布上创作的作品，它其实本质上画的是一个二维物体。类似，计算机3D图像实质上也是平面的，它只是在计算机屏幕上所显示的二维图像，但它可以提供深度的错觉。实际上如果我们需要一个物体的二维画面从不同角度上感知三维空间，我们可以通过透视、隐藏直线消除、颜色、着色和其他技巧来创建深度幻觉。 2D + 透视 = 3D 3D图形术语 变化&amp;投影 光栅化：实际绘制或填充每个顶点之间的像素形成过程 着色：沿着顶点之间改变颜色值。着色器则是图形硬件上执行的单独程序，用来处理顶点和光栅化任务。 纹理贴图：初学可以简单理解为贴到图形上的图片（但纹理并不是图片， 二者不等价）。在GPU上，纹理是快捷有效的。 混合：混合是将不同的颜色混合在一起。","text":"OpenGL是一种用于创建实时3D图像的编程接口。 走向3D三维(3D)表示一个正在描述或显示的物体具有三个维度：宽度，高度，深度。几个世纪以来，艺术家们已经知道如何让一幅画有立体感并具有真实感的深度，通过颜料在二维画布上创作的作品，它其实本质上画的是一个二维物体。类似，计算机3D图像实质上也是平面的，它只是在计算机屏幕上所显示的二维图像，但它可以提供深度的错觉。实际上如果我们需要一个物体的二维画面从不同角度上感知三维空间，我们可以通过透视、隐藏直线消除、颜色、着色和其他技巧来创建深度幻觉。 2D + 透视 = 3D 3D图形术语 变化&amp;投影 光栅化：实际绘制或填充每个顶点之间的像素形成过程 着色：沿着顶点之间改变颜色值。着色器则是图形硬件上执行的单独程序，用来处理顶点和光栅化任务。 纹理贴图：初学可以简单理解为贴到图形上的图片（但纹理并不是图片， 二者不等价）。在GPU上，纹理是快捷有效的。 混合：混合是将不同的颜色混合在一起。 3D图形的常见用途实时3D图形的应用范围包括交互式游戏和模拟数据的可视化显示（供科学、医学或商业应用）；在计算机领域，3D图形的应用几乎没有止境。目前最常见的用途，游戏、AR、VR，都是基于openGL的。3D图形在科学视觉和工程应用中非常流行，物美价廉的3D硬件大量涌现使得这些应用技术空前的流行火爆。Mac OS X以及iOS都是使用openGL对所有窗口和控件进行渲染，从而创建了功能强大，引人入胜的可视化界面。例如设计使用的3D Max， 游戏制作的Unity 3D， Cocos2D底层都是使用了openGL。医学上的影像渲染也是依托于openGL。着色器在实时计算机图形中，最前沿的技术是可编程着色器（Programmable Shading）。图形卡不再是低能的渲染芯片。而是功能强大的高度可编程的渲染计算机。类似CPU的术语GPU应运而生。它代表图形处理单元，特指当今图形卡上的可编程芯片。它们是高度并行，并且具有非常快的速度。同样重要的是， 程序员可以进行重新配置图形卡的工作方式，几乎可以实现任何想要得到的特殊效果。3D编程的基本原则 并发工具包openGL基于一种底层渲染API，我们不能告诉它“在什么地方绘制”， 而是我们需要自己动手，通过载入三角形，应用必要的变化和正确的纹理、着色器并在必要应用混合模式来组合一个模型。这使得我们能够进行大量的底层控制，与使用高层工具包相比，使用openGL这样的底层API动人之处在于，我们不能仅仅是重现许多标准3D渲染，我们可以创造自己的算法，甚至可以取发现一些新的捷径、性能技巧和艺术视觉技术。 坐标系统在openGL或几乎所有的3D API中创建一个用于绘图窗口时， 必须制定希望使用的坐标系统以及指定的坐标如何映射到实际的屏幕像素。OpenGL在Mac上的环境搭建准备资源 CLTools glew libGLTools.a这些资源都可以从网上下载到配置Xcode的openGL环境 打开Xcode -&gt; macOS -&gt; Cocoa Application 添加OpenGL.framework 和 GLUT.framework 两个系统库 libGLTools.a直接拖到工程的Frameworks文件里面，另外删除文件：AppDelegate.h、AppDelegate.m、main.m、ViewController.h、ViewController.m；创建main.cpp文件 在main.cpp中复制以下代码， 来测试环境是否配置成功： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include &lt;stdio.h&gt;#include \"GLTools.h\"#include &lt;GLUT/GLUT.h&gt;GLBatch triangleBatch;GLShaderManager shaderManager;//窗口大小改变时接受新的宽度和高度，其中0,0代表窗口中视口的左下角坐标，w，h代表像素void ChangeSize(int w,int h)&#123; glViewport(0,0, w, h); &#125;//为程序作一次性的设置void SetupRC()&#123; //设置背影颜色 glClearColor(0.0f,0.0f,1.0f,1.0f); //初始化着色管理器 shaderManager.InitializeStockShaders(); //设置三角形，其中数组vVert包含所有3个顶点的x,y,笛卡尔坐标对。 GLfloat vVerts[] = &#123; -0.5f,0.0f,0.0f, 0.5f,0.0f,0.0f, 0.0f,0.5f,0.0f, &#125;; //批次处理 triangleBatch.Begin(GL_TRIANGLES,3); triangleBatch.CopyVertexData3f(vVerts); triangleBatch.End(); &#125;//开始渲染void RenderScene(void)&#123; //清除一个或一组特定的缓冲区 glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT|GL_STENCIL_BUFFER_BIT); //设置一组浮点数来表示红色 GLfloat vRed[] = &#123;1.0f,0.0f,0.0f,1.0f&#125;; //传递到存储着色器，即GLT_SHADER_IDENTITY着色器，这个着色器只是使用指定颜色以默认笛卡尔坐标第在屏幕上渲染几何图形 shaderManager.UseStockShader(GLT_SHADER_IDENTITY,vRed); //提交着色器 triangleBatch.Draw(); //将在后台缓冲区进行渲染，然后在结束时交换到前台 glutSwapBuffers(); &#125;int main(int argc,char* argv[])&#123; //设置当前工作目录，针对MAC OS X gltSetWorkingDirectory(argv[0]); //初始化GLUT库 glutInit(&amp;argc, argv); /*初始化双缓冲窗口，其中标志GLUT_DOUBLE、GLUT_RGBA、GLUT_DEPTH、GLUT_STENCIL分别指 双缓冲窗口、RGBA颜色模式、深度测试、模板缓冲区*/ glutInitDisplayMode(GLUT_DOUBLE|GLUT_RGBA|GLUT_DEPTH|GLUT_STENCIL); //GLUT窗口大小，标题窗口 glutInitWindowSize(800,600); glutCreateWindow(\"Triangle\"); //注册回调函数 glutReshapeFunc(ChangeSize); glutDisplayFunc(RenderScene); //驱动程序的初始化中没有出现任何问题。 GLenum err = glewInit(); if(GLEW_OK != err) &#123; fprintf(stderr,\"glew error:%s\\n\",glewGetErrorString(err)); return 1; &#125; //调用SetupRC SetupRC(); glutMainLoop(); return 0; &#125; 编译， 将报错的地方文件&lt;&gt;系统引入， 改为“”普通引入 效果图 那么环境搭建到此就成功了。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/categories/学习笔记/"}],"tags":[{"name":"opengl","slug":"opengl","permalink":"http://yoursite.com/tags/opengl/"}]}]}