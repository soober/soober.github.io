{"meta":{"title":"Sober's Notes","subtitle":null,"description":"GET SOBER. STAY SOBER.","author":"Sober","url":"http://yoursite.com"},"pages":[{"title":"文章分类","date":"2019-02-20T10:16:44.000Z","updated":"2019-02-20T10:22:15.194Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-02-20T10:25:04.000Z","updated":"2019-02-20T10:25:20.604Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"OpenGL-ES Tips","slug":"OpenGL-ES-Tips","date":"2019-02-19T16:38:36.000Z","updated":"2019-02-20T10:24:25.825Z","comments":true,"path":"2019/02/20/OpenGL-ES-Tips/","link":"","permalink":"http://yoursite.com/2019/02/20/OpenGL-ES-Tips/","excerpt":"","text":"Opengl ES( Opengl for Embedded Systems)是 Opengl三维图形API的子集,针对手机、PDA和游戏主机等嵌入式设备而设计。API由图形软硬件行业协会 Khronos Group定义推广该协会主要关注图形和多媒体方面的开放标准。Opengl ES是从 Opengl裁剪定制而来的,去除了 glbegin/glend、四边形(GL_ QUADS)、多边形( GL POLYGONS)等复杂图元中许多非绝对必要的特性。经过多年发展,现在主要有两个版本: Opengl ES1.x,针对固定管线硬件; Opengl ES2x,针对可编程管线硬件。 以下转载自网络: CAEAGLLayer，在CAEAGLLayer层上进行OpenGL的绘制. EAGLContext，创建OpenGL context，管理所有使用OpenGL ES进行绘制的状态，命令及资源信息。 需要生命API，设置为当前context 渲染缓冲区 renderbuffer，三种colorbuffer，depthbuffer，stencilbuffer 123void glGenRenderbuffers (GLsizei n, GLuint* renderbuffers) 将分配到的renderbuffer的id存于renderbuffers中。 void glBindRenderbuffer (GLenum target, GLuint renderbuffer) 将指定id的renderbuffer设置为当前renderbuffer。 (BOOL)renderbufferStorage:(NSUInteger)target fromDrawable:(id&lt;EAGLDrawable&gt;)drawable 为renderbuffer分配存储空间 帧缓冲区 framebuffer， 123void glGenFramebuffers (GLsizei n, GLuint* framebuffers) void glBindFramebuffer (GLenum target, GLuint framebuffer) 设置为当前framebuffer void glFramebufferRenderbuffer (GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer) 将renderbuffer装配到attachment这个装配点上 设置clearColor 12glClearColor(1.0, 1.0, 1.0, 1.0)// 设置clearColor glClear(GL_COLOR_BUFFER_BIT) 调用presentRenderbuffer方法, 将renderbuffer和colorbuffer呈现到UIView上. 着色器由类似C的语言GLSL编写. Vertex shader: 顶点着色器. 如在长方形中vertex shader会被调用四次. 负责执行灯光, 几何变换等计算, 得出最终的顶点位置后, 为片段着色器提供数据. Fragment shader: 片段着色器, 负责计算每个像素的最终颜色. 着色器使用之前要先编译,以及其他的一些操作. glVertexAttribPointer指定了渲染时索引值为index的顶点属性数组的数据格式和位置. 1234567void glVertexAttribPointer( GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride,const GLvoid * pointer) size和type分别指定每个顶点属性的组件数量和数据类型, normalized指定当被访问时, 固定点数据值是否应该被归一化或直接转换为固定点值. stride指定连续顶点属性之间的偏移量, 用于描述每个vertex数据大小. pointer指定第一个组件在数组的第一个顶点属性中的偏移量, 与GL_ARRAY_BUFFER绑定存储于缓冲区中. 如: glVertexAttribPointer(_positionSlot, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), 0); glVertexAttribPointer(_colorSlot, 4, GL_FLOAT, GL_FALSE, sizeof(Vertex), (GLvoid *)(sizeof(float)*3)); 指定triangle的三个顶点, 然后调用glVertexAttribPointer和glEnableVertexAttribArray来加载vertex数据. 最后调用glDrawArrays(GL_TRIANGLES, 0, 3)来绘制triangle. 在compileShaders中的glGetAttribLocation方法, “vPosition”要和shader中的对应一致. 使用CoreImage的filter.导入CIImage图片-&gt;创建CIFilter-&gt;用CIContext将滤镜中的图片渲染出来-&gt;导出并显示图片. 使用CoreImage+OpenGL ES实现filter.获取OpenGL ES渲染的context-&gt;创建渲染buffer-&gt;创建CoreImage使用的CIContext-&gt;设置CoreImage-&gt;渲染图片. 使用OpenGL ES绘制已有图片. 1234567891011121314151617创建并添加GLKView到view, 调用[_glkView bindDrawable];和[_glkView display]; 绘制长方形(通过vertex), 启用颜色. 启用vertex贴图坐标: glEnableVertexAttribArray(GLKVertexAttribTexCoord0); glVertexAttribPointer(GLKVertexAttribTexCoord0, 2, GL_FLOAT, GL_FALSE, 0, texCoords); // 因为读取图片信息的时候默认是从图片左上角读取的, 而OpenGL绘制却是从左下角开始的.所以我们要从左下角开始读取图片数据. NSDictionary *options = [NSDictionary dictionaryWithObjectsAndKeys:@(YES), GLKTextureLoaderOriginBottomLeft, nil]; GLKTextureInfo *textureInfo = [GLKTextureLoader textureWithCGImage:image.CGImage options:options error:nil]; 创建并设置GLKBaseEffect: GLKBaseEffect *baseEffect = [[GLKBaseEffect alloc] init]; // 创建一个二维的投影矩阵, 即定义一个视野区域(镜头看到的东西) // GLKMatrix4MakeOrtho(float left, float right, float bottom, float top, float nearZ, float farZ) baseEffect.transform.projectionMatrix = GLKMatrix4MakeOrtho(-1, 1, -1, 1, -1, 1); baseEffect.texture2d0.name = textureInfo.name; [baseEffect prepareToDraw]; // 最后绘制图片 glDrawArrays(GL_TRIANGLE_STRIP, 0, 4); 使用CGContextRef等绘制图片: 12345678910111213CGContextRef context = UIGraphicsGetCurrentContext(); CGImageRef image = CGImageRetain([[UIImage imageNamed:@&quot;testImage.png&quot;] CGImage]); CGContextDrawImage(context, CGRectMake(0, 0, self.frame.size.width, self.frame.size.height), image); 在图片上使用画笔: 先通过touchesMoved等方法将划过的点(调用UITouch的locationInView方法取得CGPoint)存入_linesCompleted中, 然后在drawRect中: CGContextSetLineWidth(context, 5.0);CGContextSetLineCap(context, kCGLineCapRound);CGContextSetRGBStrokeColor(context, 0.5, 0.5, 0.5, 0.5);for (Line *l in _linesCompleted) &#123; CGContextMoveToPoint(context, l.begin.x, l.begin.y); CGContextAddLineToPoint(context, l.end.x, l.end.y); CGContextStrokePath(context);&#125;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/categories/学习笔记/"}],"tags":[{"name":"opengles","slug":"opengles","permalink":"http://yoursite.com/tags/opengles/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-02-19T08:49:29.259Z","updated":"2019-02-19T08:49:29.259Z","comments":true,"path":"2019/02/19/hello-world/","link":"","permalink":"http://yoursite.com/2019/02/19/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}